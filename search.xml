<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/bloger/2022/03/11/%E5%9B%BE%E8%A7%A3Google%20V8/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E6%98%AF%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%EF%BC%9F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>JS面试系列</title>
    <url>/bloger/1970/01/01/JS%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<h2 id="JS面试系列"><a href="#JS面试系列" class="headerlink" title="JS面试系列"></a>JS面试系列</h2><h3 id="defer和asnyc"><a href="#defer和asnyc" class="headerlink" title="defer和asnyc"></a>defer和asnyc</h3><p>参考：<a href="https://segmentfault.com/a/1190000011577248">带你玩转prefetch, preload, dns-prefetch，defer和async - SegmentFault 思否</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span> src=<span class="string">&quot;foo.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 等同于 --&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span> src=<span class="string">&quot;foo.js&quot;</span> defer&gt;&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://www.imooc.com/article/20630?block_id=tuijian_wz">阮一峰的ES6—Module的加载实现_慕课手记 (imooc.com)</a></p>
<p><a href="https://www.cnblogs.com/lvdabao/p/5953884.html">webpack解惑：require的五种用法 - 吕大豹 - 博客园 (cnblogs.com)</a></p>
<h2 id="5、介绍下-Set、Map的区别？"><a href="#5、介绍下-Set、Map的区别？" class="headerlink" title="5、介绍下 Set、Map的区别？"></a><strong>5、介绍下 Set、Map的区别？</strong></h2><blockquote>
<p>应用场景Set用于数据重组，Map用于数据储存Set：　<br>（1）成员不能重复<br>（2）只有键值没有键名，类似数组<br>（3）可以遍历，方法有add, delete,has<br>Map:<br>（1）本质上是健值对的集合，类似集合<br>（2）可以遍历，可以跟各种数据格式转换</p>
</blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/102442557">ES6常见面试题总结 - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/33843378">深入理解 ES6 模块机制 - 知乎 (zhihu.com)</a></p>
<p><a href="https://www.jianshu.com/p/f1e54dde30c8">JS中的「import」和「require 」 - 简书 (jianshu.com)</a></p>
<h2 id="前端性能优化-24-条建议"><a href="#前端性能优化-24-条建议" class="headerlink" title="前端性能优化 24 条建议"></a>前端性能优化 24 条建议</h2><p><a href="https://zhuanlan.zhihu.com/p/121056616">https://zhuanlan.zhihu.com/p/121056616</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/26559480">https://zhuanlan.zhihu.com/p/26559480</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/147178478">https://zhuanlan.zhihu.com/p/147178478</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&chksm=fc531be6cb2492f04475bac0fecbd1a9f9781ca67f35bd30c320964b24a8cbc2ca3d7bbd5345&idx=1&mid=2247483933&scene=21&sn=c2729ef1fd4a28f4707bb923a5ffae79#wechat_redirect">web性能优化的15条实用技巧 (qq.com)</a></p>
<p><a href="https://www.zhihu.com/question/265631914">如何理解es6中的import是静态编译执行的？（一说是编译期执行的）？ - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/32561606">CSS预加载Preload - 知乎 (zhihu.com)</a></p>
<p>Preload是为处理当前页面所生，Prefetch是告诉浏览器加载下一页面可能会用到的资源，优先级自然在当前页面之后</p>
<p>[TypeScript 和 JavaScript 究竟哪个更好？_Web_hls33的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_42554191/article/details/103889161#:~:text=%E4%BA%8C%E8%80%85%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%E4%B8%BA%EF%BC%9A,TypeScript">https://blog.csdn.net/weixin_42554191/article/details/103889161#:~:text=二者的主要区别为：,TypeScript</a><br>是静态类型，js是动态类型（详见强类型、弱类型、静态类型、动态类型的区别）。)</p>
<p><a href="https://github.com/vercel/next.js/issues/10713">Telemetry needs to be disabled without voodoo · Issue #10713 · vercel/next.js (github.com)</a></p>
<p><a href="https://www.zhihu.com/question/367871981">如何评价首发于 2020 年 1 月下旬的 JavaScript 依赖管理器 Yarn 2？ - 知乎 (zhihu.com)</a></p>
]]></content>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/bloger/2022/03/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>一些名词解释</title>
    <url>/bloger/1970/01/01/%E4%B8%80%E4%BA%9B%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<h2 id="一些名词解释"><a href="#一些名词解释" class="headerlink" title="一些名词解释"></a>一些名词解释</h2><h3 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h3><blockquote>
<p>参考：《前端技术架构与工程》作者: <a href="https://book.douban.com/search/%E5%91%A8%E4%BF%8A%E9%B9%8F">周俊鹏</a></p>
</blockquote>
<p>前端工程化是前端开发的一种思维方式，是针对前端开发过程中遇到的一些列问题的解决方案。前端工程化围绕编码、方法、工具三个要素展开。从前端应用的技术架构本身出发，关注点聚焦于模块解耦、数据管理架构模式、性能以及前后端分离，目标是实现架构的高可用性、可扩展性、可伸缩性，同时提高独立开发和跨团队协作开发的效率；从架构之外的角度出发，关注点聚焦于前端应用的开发、架构、测试、部署以及持续化工程体系，目标是建立规范、有序、高效的迭代流程，降低产品迭代所消耗的人力和沟通成本。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><blockquote>
<p>参考：<a href="https://github.com/Matthrews/rfzhu_blogs/blob/main/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%5B%E5%90%B4%E6%B5%A9%E9%BA%9F%5D%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Webpack.md">模块化</a></p>
</blockquote>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>首先说一下 MVC，是 SOC 的具体实践。在此模式下，一个服务将被划分为 Model、View、Controller 三层，Model 层描述数据模型，存储数据，View 层展示 UI 界面和响应用户交互，Controller 层监听模型数据改变和控制视图行为、处理用户交互。最终实现服务交付。</p>
<p><strong>MVVM</strong><br>将复杂的 Controller 层数据和逻辑抽离，用一个专门的对象 ViewModel 管理，然后实现 Controller 与 ViewModel 的绑定</p>
<h4 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h4><p>Vue 是基于双向绑定的，但是 React 不是，需要手动实现。 在数据到视图过程中，使用 setState 修改数据重新渲染视图 在视图到数据过程中，使用合成事件动态录入数据</p>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/bloger/2022/03/21/%E5%9B%BE%E8%A7%A3GoogleV8/</url>
    <content><![CDATA[<h1 id="图解-Google-V8"><a href="#图解-Google-V8" class="headerlink" title="图解 Google V8"></a>图解 Google V8</h1><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><h3 id="如何学习谷歌高性能-JavaScript-引擎V8？"><a href="#如何学习谷歌高性能-JavaScript-引擎V8？" class="headerlink" title="如何学习谷歌高性能 JavaScript 引擎V8？"></a>如何学习谷歌高性能 JavaScript 引擎V8？</h3><h4 id="什么是-V8？"><a href="#什么是-V8？" class="headerlink" title="什么是 V8？"></a>什么是 V8？</h4><p>V8 是 JavaScript 虚拟机的一种。我们可以简单地把 JavaScript 虚拟机 理解成翻译程序，将人类能够理解的<strong>编程语言  JavaScript</strong> ，翻译成为机器能够理解的<strong>机器语言</strong>。如下图所示：<br><img src="https://static001.geekbang.org/resource/image/8a/a1/8a40fd003baa9be179fe2e55a1be5fa1.jpg" alt="JavaScript引擎"></p>
<p>上图中，中间的“黑盒”就是 JavaScript 引擎 V8。目前市面上有很多种 JavaScript 引擎，诸如 SpiderMonkey、V8、JavaScriptCore 等。而由谷歌开发的开源项目 V8 是当下使用最广泛的 JavaScript 虚拟机，全球有超过 25 亿台安卓设备，而这些设备中都使用了 Chrome 浏览器，所以我们写的 JavaScript 应用，大都跑在 V8 上。</p>
<p>V8 之所以拥有如此庞大的生态圈，也和它许多革命性的设计是分不开的。</p>
<p>在 V8 出现之前，所有的 JavaScript 虚拟机所采用的都是解释执行的方式，这是 JavaScript 执行速度过慢的一个主要原因。而 V8 率先引入了即时编译（JIT）的双轮驱动的设计，这是一种权衡策略，混合编译执行和解释执行这两种手段，给 JavaScript 的执行速度带来了极大的提升。</p>
<p>可以说，V8 的出现，将 JavaScript 虚拟机技术推向了一个全新的高度。</p>
<p>即便 V8 具有诸多优点，但我相信对于大部分同学来说，V8 虚拟机还只是一个黑盒，我们将一段代码丢给这个黑盒，它便会返回结果，并没有深入了解过它的工作原理。</p>
<p>如果只是单纯使用 JavaScript 和调用 Web  API，并不了解虚拟机内部是怎样工作的，在项目中遇到的很多问题很可能找不到解决的途径。比如，有时项目的占用内存过高，或者页面响应速度过慢，又或者使用 Node.js 的时候导致任务被阻塞等问题，都与 V8 的基本运行机制有关。如果你熟悉 V8 的工作机制，就会有系统性的思路来解决这些问题。</p>
<p>另外，V8 的主要功能，就是结合 JavaScript 语言的特性和本质来编译执行它。通过深入地学习 V8，你对 JavaScript 语言本质和设计思想会有很直观的感受。这些设计思想像是更加高级的工具，你掌握了它，就可以提升你的语言使用和架构设计水平。</p>
]]></content>
  </entry>
  <entry>
    <title>模块化发展</title>
    <url>/bloger/2021/08/25/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95/</url>
    <content><![CDATA[<h1 id="模块化发展"><a href="#模块化发展" class="headerlink" title="模块化发展"></a>模块化发展</h1><blockquote>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/108217164">https://zhuanlan.zhihu.com/p/108217164</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>模块标准</tag>
        <tag>TreeShaking</tag>
      </tags>
  </entry>
  <entry>
    <title>Electron Forge 入门</title>
    <url>/bloger/2021/04/12/Electron/%5B%E8%AF%91%5DElectron%20Forge%20%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Electron-Forge-入门"><a href="#Electron-Forge-入门" class="headerlink" title="Electron Forge 入门"></a>Electron Forge 入门</h1><blockquote>
<p>Electron Forge 是一个集创建，发布和安装现代 Electron 应用于一身的完备工具链。</p>
</blockquote>
<hr>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>首先初始化一个项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># with yarn</span></span><br><span class="line">yarn create electron-app my-app</span><br><span class="line"><span class="comment"># with npm</span></span><br><span class="line">npx create-electron-app my-app</span><br></pre></td></tr></table></figure>

<p>现在你的 <code>my-app</code>文件夹下面就有了一个超级小的 Electron 应用模板。进入 <code>my-app</code>文件夹，启动项目，你就可以开始开发了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># with yarn</span></span><br><span class="line"><span class="built_in">cd</span> my-app</span><br><span class="line">yarn start</span><br><span class="line"><span class="comment"># with npm</span></span><br><span class="line"><span class="built_in">cd</span> my-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

<h2 id="构建发行版"><a href="#构建发行版" class="headerlink" title="构建发行版"></a>构建发行版</h2><p>现在你可以把你的应用和全世界分享。当你运行<code>make</code> 脚本时， Electron Forge<br>会生成对应平台的发行版。了解你可以构建的发行版类型，请参考<a href="https://www.electronforge.io/config/makers">Makers </a>文档。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># with yarn</span></span><br><span class="line">yarn make</span><br><span class="line"><span class="comment"># with npm</span></span><br><span class="line">npm run make</span><br></pre></td></tr></table></figure>

<h2 id="高阶使用"><a href="#高阶使用" class="headerlink" title="高阶使用"></a>高阶使用</h2><p>有了一个入门级的应用，你就可以构建发行版了。了解更多高阶功能，可以参考：</p>
<p><a href="https://www.electronforge.io/config/publishers">Publishers</a></p>
<p><a href="https://www.electronforge.io/advanced/debugging">Debugging your app</a></p>
<p><a href="https://www.electronforge.io/config/plugins/webpack">Webpack support</a></p>
<p><a href="https://www.electronforge.io/advanced/extending-electron-forge">Writing your own makers, publishers and plugins</a></p>
]]></content>
      <categories>
        <category>Electron</category>
      </categories>
  </entry>
  <entry>
    <title>How to build an Electron app using Create React App and Electron Builder</title>
    <url>/bloger/2022/03/11/Electron/%5B%E8%AF%91%5D%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Create%20React%20App%E5%92%8CElectron%20Builder%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAElectron%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="如何使用-Create-React-App-和-Electron-Builder-构建-Electron-应用"><a href="#如何使用-Create-React-App-和-Electron-Builder-构建-Electron-应用" class="headerlink" title="如何使用 Create React App 和 Electron Builder 构建 Electron 应用"></a>如何使用 Create React App 和 Electron Builder 构建 Electron 应用</h1><p><img src="https://finbits.io/images/blog/electron-react.jpg" alt="Electron-React"></p>
<p>最近我决定做一个桌面应用来下载和保存我的 Google Photos。因为我曾被丢失所有照片折磨够了。虽然 Google 本身有一些选项可以配置实现，但是实践下来貌似都有问题。</p>
<p>如果你想使用这款应用，你可以在这里下载 <a href="https://finbits.io/downloads/photosdownloader-0.1.1.dmg">OSX</a><br>或者 <a href="https://finbits.io/downloads/photosdownloader-0.1.1.exe">WIN</a>。</p>
<p>技术栈上我选择 Electron 和 React,因为这使得我的工作很有趣,而且最终效果不错.</p>
<p>在这篇博客中,我会分享一些配置和我踩过的坑。</p>
<p>我刚开始开发的时候，我参考了这两篇博客 <a href="https://medium.com/@kitze/%EF%B8%8F-from-react-to-an-electron-app-ready-for-production-a0468ecb1da3">1</a><br>和 <a href="https://medium.freecodecamp.org/building-an-electron-application-with-create-react-app-97945861647c">2</a>，感谢。</p>
<p>好的，结下来我们一起来学学如何构建一个使用 Create React App 开发的 Electron 应用，然后在使用 Electron Builder 进行打包分发。</p>
<p>我们先来了解一下整个技术栈然后再开始。如果你想跳过，可以直接看<a href="https://github.com/rgfindl/electron-cra-boilerplate">源码</a></p>
<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul>
<li><a href="https://electronjs.org/">Electron</a></li>
<li><a href="https://github.com/facebook/create-react-app">React - Create React App</a></li>
<li><a href="https://github.com/harrysolovay/rescripts">Rescripts</a></li>
<li><a href="https://github.com/electron-userland/electron-builder">Electron Builder</a></li>
</ul>
<p><a href="https://electronjs.org/">Electron</a> 是一个使用 JavaScript, HTML, and CSS 等 Web 技术创建原生应用的框架。在我们的案例中，我们使用的是 React</p>
<p><a href="https://reactjs.org/">React</a> 是构建用户界面的 JavaScript 库……</p>
<p>为了让我们的 React 项目配置更容易，我们使用<a href="https://github.com/facebook/create-react-app">Create React App</a>快速创建 React 项目。Create React<br>App (CRA)很棒，因为它节省了时间，并消除了配置难题。</p>
<p>Create React App 是一个可以让你在构建应用时获得先发优势的工具，由 Facebook 开发者创建。它节省了安装和配置的时间。你只需要简单地运行一个命令，Create React App 就会帮你安装好用于启动项目的工具</p>
<p><a href="https://github.com/harrysolovay/rescripts">Rescripts</a> 可以让你无需<code>eject</code>也可以自定义 CRA。</p>
<p>弹出(<code>eject</code>) CRA 是你应该避免的操作，因为这将意味着你再也不会受益于 CRA 的未来更新。</p>
<p><a href="https://github.com/electron-userland/electron-builder">Electron Builder</a> 用于打包我们的桌面应用进行分发。</p>
<h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><p>使用 Create React App 快速创建项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx create-react-app my-app</span><br><span class="line">cd my-app</span><br></pre></td></tr></table></figure>

<p>安装 Electron</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add electron electron-builder --dev</span><br></pre></td></tr></table></figure>

<p>和一些我们需要的工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add wait-on concurrently --dev</span><br><span class="line">yarn add electron-is-dev</span><br></pre></td></tr></table></figure>

<p>创建<code>public/electron.js</code>文件，内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> electron = <span class="built_in">require</span>(<span class="string">&quot;electron&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = electron.app;</span><br><span class="line"><span class="keyword">const</span> BrowserWindow = electron.BrowserWindow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> isDev = <span class="built_in">require</span>(<span class="string">&quot;electron-is-dev&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mainWindow;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  mainWindow = <span class="keyword">new</span> BrowserWindow(&#123; <span class="attr">width</span>: <span class="number">900</span>, <span class="attr">height</span>: <span class="number">680</span> &#125;);</span><br><span class="line">  mainWindow.loadURL(</span><br><span class="line">    isDev</span><br><span class="line">      ? <span class="string">&quot;http://localhost:3000&quot;</span></span><br><span class="line">      : <span class="string">`file://<span class="subst">$&#123;path.join(__dirname, <span class="string">&quot;../build/index.html&quot;</span>)&#125;</span>`</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (isDev) &#123;</span><br><span class="line">    <span class="comment">// Open the DevTools.</span></span><br><span class="line">    <span class="comment">//BrowserWindow.addDevToolsExtension(&#x27;&lt;location to your react chrome extension&gt;&#x27;);</span></span><br><span class="line">    mainWindow.webContents.openDevTools();</span><br><span class="line">  &#125;</span><br><span class="line">  mainWindow.on(<span class="string">&quot;closed&quot;</span>, <span class="function">() =&gt;</span> (mainWindow = <span class="literal">null</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">&quot;ready&quot;</span>, createWindow);</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">&quot;window-all-closed&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">&quot;darwin&quot;</span>) &#123;</span><br><span class="line">    app.quit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">&quot;activate&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (mainWindow === <span class="literal">null</span>) &#123;</span><br><span class="line">    createWindow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在<code>package.json</code>文件的<code>scripts</code> 项添加如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;electron-dev&quot;: &quot;concurrently \&quot;BROWSER=none yarn start\&quot; \&quot;wait-on http://localhost:3000 &amp;&amp; electron .\&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>这个<code>script</code>将会在启动 Electron 之前 等待应用在<code>localhost:3000</code>运行起来。</p>
<p>在<code>package.json</code>文件的<code>main</code> 项添加如下内容：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;main&quot;: &quot;public/electron.js&quot;,</span><br></pre></td></tr></table></figure>

<p>现在，你的 <code>package.json</code>应该是这样的</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;my-app&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;private&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;electron-is-dev&quot;</span>: <span class="string">&quot;^1.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react&quot;</span>: <span class="string">&quot;^16.8.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react-dom&quot;</span>: <span class="string">&quot;^16.8.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react-scripts&quot;</span>: <span class="string">&quot;2.1.5&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;public/electron.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;react-scripts start&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;react-scripts build&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;react-scripts test&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eject&quot;</span>: <span class="string">&quot;react-scripts eject&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;electron-dev&quot;</span>: <span class="string">&quot;concurrently \&quot;BROWSER=none yarn start\&quot; \&quot;wait-on http://localhost:3000 &amp;&amp; electron .\&quot;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;eslintConfig&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;extends&quot;</span>: <span class="string">&quot;react-app&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;browserslist&quot;</span>: [<span class="string">&quot;&gt;0.2%&quot;</span>, <span class="string">&quot;not dead&quot;</span>, <span class="string">&quot;not ie &lt;= 11&quot;</span>, <span class="string">&quot;not op_mini all&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;concurrently&quot;</span>: <span class="string">&quot;^4.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;electron&quot;</span>: <span class="string">&quot;^4.0.6&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;electron-builder&quot;</span>: <span class="string">&quot;^20.38.5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;wait-on&quot;</span>: <span class="string">&quot;^3.2.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，你可以通过以下命令以开发模式启动你的项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn electron-dev</span><br></pre></td></tr></table></figure>

<p>你应该会看到下图这样<br><img src="https://finbits.io/images/blog/electron-boilerplate.png" alt="electron-boilerplate"><br>如果你看到了，恭喜你可以进行接下来的开发了。🤩</p>
<p>Now, if you need to access the <code>fs</code> module like I did, you’ll quickly hit the <code>Module not found</code> error.<br>See <a href="https://stackoverflow.com/questions/35428639/how-can-i-use-fs-in-react-with-electron">here</a>. 如果你需要使用<code>fs</code><br>模块，你可能很快就会遇到<code>Module not found</code><br>这样的错误。<a href="https://stackoverflow.com/questions/35428639/how-can-i-use-fs-in-react-with-electron">参考</a></p>
<p>要解决这个问题，我们需要设置<code>Webpack</code>的<code>target</code>为<code>electron-renderer</code>。但是哦我们不想弹出(eject) CRA<br>去做这件事。所以我们使用<a href="https://github.com/harrysolovay/rescripts">Rescripts</a>。下面教你如何使用。</p>
<p>首先，安装<code>Rescripts</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add @rescripts/cli @rescripts/rescript-env --dev</span><br></pre></td></tr></table></figure>

<p>然后，将 <code>package.json</code>里面的<code>scripts</code> 项从</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;start&quot;: &quot;react-scripts start&quot;,</span><br><span class="line">&quot;build&quot;: &quot;react-scripts build&quot;,</span><br><span class="line">&quot;test&quot;: &quot;react-scripts test&quot;,</span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;start&quot;: &quot;rescripts start&quot;,</span><br><span class="line">&quot;build&quot;: &quot;rescripts build&quot;,</span><br><span class="line">&quot;test&quot;: &quot;rescripts test&quot;,</span><br></pre></td></tr></table></figure>

<p>现在新建 <code>.rescriptsrc.js</code>文件，内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = [<span class="built_in">require</span>.resolve(<span class="string">&quot;./.webpack.config.js&quot;</span>)];</span><br></pre></td></tr></table></figure>

<p>最后新建<code>.webpack.config.js</code>，内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// define child rescript</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  config.target = <span class="string">&quot;electron-renderer&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在就可以无需担心地使用<code>fs</code> 模块了</p>
<h2 id="开始打包"><a href="#开始打包" class="headerlink" title="开始打包"></a>开始打包</h2><p>非常棒，现在我们可以准备打包我们的项目了</p>
<p>首先，安装 Electron Builder 和 Typescript</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add electron-builder typescript --dev</span><br></pre></td></tr></table></figure>

<p>默认情况下 CRA 会使用绝对路径构建修改<code>index.html</code>文件。这会使得 Electron 加载出错。这需要一些配置来修正。</p>
<p>将 <code>package.json</code>中的<code>homepage</code>项的值设为</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;homepage&quot;: &quot;./&quot;,</span><br></pre></td></tr></table></figure>

<p>接下来我们添加给<code>package.json</code>的<code>scripts</code> 项添加<code>electron-pack</code>命令用于打包构建(build)结果</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;postinstall&quot;: &quot;electron-builder install-app-deps&quot;,</span><br><span class="line">&quot;preelectron-pack&quot;: &quot;yarn build&quot;,</span><br><span class="line">&quot;electron-pack&quot;: &quot;build -mw&quot;</span><br></pre></td></tr></table></figure>

<p><code>&quot;postinstall&quot;: &quot;electron-builder install-app-deps&quot;</code> 将会确保你的原生依赖总是会匹配 <code>electron</code> 的版本</p>
<p><code>&quot;preelectron-pack&quot;: &quot;yarn build&quot;</code> 用于构建(build) CRA 项目</p>
<p><code>&quot;electron-pack&quot;: &quot;build -mw&quot;</code> 用于打包 <code>Mac (m) </code>和 <code>Windows (w)</code>应用</p>
<p>在我们可以运行这个命令之前在<code>package.json</code>里给 Electron Builder 配置如下内容：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;author&quot;: &#123;</span><br><span class="line">&quot;name&quot;: &quot;Your Name&quot;,</span><br><span class="line">&quot;email&quot;: &quot;your.email@domain.com&quot;,</span><br><span class="line">&quot;url&quot;: &quot;https://your-website.com&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;build&quot;: &#123;</span><br><span class="line">&quot;appId&quot;: &quot;com.my-website.my-app&quot;,</span><br><span class="line">&quot;productName&quot;: &quot;MyApp&quot;,</span><br><span class="line">&quot;copyright&quot;: &quot;Copyright © 2019 $&#123;author&#125;&quot;,</span><br><span class="line">&quot;mac&quot;: &#123;</span><br><span class="line">&quot;category&quot;: &quot;public.app-category.utilities&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;files&quot;: [</span><br><span class="line">&quot;build/**/*&quot;,</span><br><span class="line"><span class="string">&quot;node_modules/**/*&quot;</span></span><br><span class="line">],</span><br><span class="line">&quot;directories&quot;: &#123;</span><br><span class="line">&quot;buildResources&quot;: &quot;assets&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以在在 <a href="https://www.electron.build/configuration/configuration">这里</a>查看在所有的 Electron Builder 配置项</p>
<p>你可能还会创建<code>assets</code> 文件夹以存放应用的图标(icon)。格式可以参考 <a href="https://www.electron.build/icons">这里</a></p>
<p>最终整个 <code>package.json</code> 内容如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;my-app&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Electron + Create React App + Electron Builder&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;private&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Your Name&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;your.email@domain.com&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://your-website.com&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;build&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;appId&quot;</span>: <span class="string">&quot;com.my-website.my-app&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;productName&quot;</span>: <span class="string">&quot;MyApp&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;copyright&quot;</span>: <span class="string">&quot;Copyright © 2019 $&#123;author&#125;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;mac&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;public.app-category.utilities&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;files&quot;</span>: [<span class="string">&quot;build/**/*&quot;</span>, <span class="string">&quot;node_modules/**/*&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;directories&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;buildResources&quot;</span>: <span class="string">&quot;assets&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;electron-is-dev&quot;</span>: <span class="string">&quot;^1.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react&quot;</span>: <span class="string">&quot;^16.8.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react-dom&quot;</span>: <span class="string">&quot;^16.8.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react-scripts&quot;</span>: <span class="string">&quot;2.1.5&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;homepage&quot;</span>: <span class="string">&quot;./&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;public/electron.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;rescripts start&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;rescripts build&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;rescripts test&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eject&quot;</span>: <span class="string">&quot;react-scripts eject&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;electron-dev&quot;</span>: <span class="string">&quot;concurrently \&quot;BROWSER=none yarn start\&quot; \&quot;wait-on http://localhost:3000 &amp;&amp; electron .\&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;postinstall&quot;</span>: <span class="string">&quot;electron-builder install-app-deps&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;preelectron-pack&quot;</span>: <span class="string">&quot;yarn build&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;electron-pack&quot;</span>: <span class="string">&quot;build -mw&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;eslintConfig&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;extends&quot;</span>: <span class="string">&quot;react-app&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;browserslist&quot;</span>: [<span class="string">&quot;&gt;0.2%&quot;</span>, <span class="string">&quot;not dead&quot;</span>, <span class="string">&quot;not ie &lt;= 11&quot;</span>, <span class="string">&quot;not op_mini all&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;@rescripts/cli&quot;</span>: <span class="string">&quot;^0.0.10&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@rescripts/rescript-env&quot;</span>: <span class="string">&quot;^0.0.5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;concurrently&quot;</span>: <span class="string">&quot;^4.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;electron&quot;</span>: <span class="string">&quot;^4.0.6&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;electron-builder&quot;</span>: <span class="string">&quot;^20.38.5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;typescript&quot;</span>: <span class="string">&quot;^3.3.3333&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;wait-on&quot;</span>: <span class="string">&quot;^3.2.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们准备好打包应用。运行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn electron-pack</span><br></pre></td></tr></table></figure>

<p>最终你会在 <code>dist</code> 目录看到打包结果</p>
<p>好了，该你上手实践了。</p>
<p>源码在 <a href="https://github.com/rgfindl/electron-cra-boilerplate">这里</a></p>
<p>希望这这篇博客对你有所帮助。 Bye!</p>
]]></content>
      <categories>
        <category>Electron</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/bloger/2021/04/16/Linux/%E4%BD%A0%E5%BF%85%E9%A1%BB%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%8430%E4%B8%AA%20Linux%20%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="你必须要知道的30个-Linux-命令"><a href="#你必须要知道的30个-Linux-命令" class="headerlink" title="你必须要知道的30个 Linux 命令"></a>你必须要知道的30个 Linux 命令</h2><ol>
<li>pwd</li>
</ol>
<blockquote>
<p>列出当前所在目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/mnt/c/Users/Matthew/Desktop</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="2">
<li>cd</li>
</ol>
<blockquote>
<p>文件夹切换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew$ <span class="built_in">cd</span> Downloads/</span><br><span class="line">root@matthew:/mnt/c/Users/Matthew/Downloads$</span><br></pre></td></tr></table></figure>
<p>快捷方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..   <span class="comment"># 返回上一层</span></span><br><span class="line"><span class="built_in">cd</span>      <span class="comment"># 直接到home目录</span></span><br><span class="line"><span class="built_in">cd</span> -    <span class="comment"># 退回到上一次目录</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="3">
<li>ls</li>
</ol>
<blockquote>
<p>列出当前文件夹内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Videos$ ls</span><br><span class="line">Captures  desktop.ini</span><br></pre></td></tr></table></figure>
<p>快捷方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -R  <span class="comment"># 列出当前文件夹以及当前文件夹子文件夹内容</span></span><br><span class="line">ls -a  <span class="comment"># 列出隐藏文件</span></span><br><span class="line">ls -al <span class="comment"># 列出当前文件夹内容以及详情，包括文件权限，大小，拥有者等等</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="4">
<li>cat</li>
</ol>
<blockquote>
<p>通过标准输出查看文件内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ cat 1.txt</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>如何使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &gt;4.txt   				<span class="comment"># 创建新文件4.txt</span></span><br><span class="line">cat 1.txt 2.txt&gt;3.txt 	<span class="comment"># 把1.txt和2.txt文件内容拼接起来输出到新文件3.txt</span></span><br><span class="line">cat 1.txt | tr a-z A-Z &gt;3.txt <span class="comment"># 将1.txt文件内容小写转大写，然后输出到3.txt</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="5">
<li>cp</li>
</ol>
<blockquote>
<p>把当前文件夹下文件复制到其他文件夹下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ cp 2.txt .. <span class="comment"># 把当前文件夹下2.txt复制到上一层目录下</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="6">
<li>mv</li>
</ol>
<blockquote>
<p>主要用于移动文件，也可以用来重命名文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ mv 2.txt .. <span class="comment"># 把当前文件夹下2.txt移动到上一层目录下</span></span><br><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ mv 1.txt out.txt <span class="comment"># 将当前文件夹下1.txt文件名改为out.txt</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="7">
<li>mkdir</li>
</ol>
<blockquote>
<p>创建文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ mkdir dir1 </span><br></pre></td></tr></table></figure>
<p>快捷方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir p1/p2  <span class="comment"># 创建文件夹p1的子文件夹p2</span></span><br><span class="line">mkdir -p p1/parentDir/p2 <span class="comment"># 在已经创建的文件夹p1和p2之间创建新文件夹parentDir, p2成为parentDir的子文件夹</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="8">
<li>rmdir</li>
</ol>
<blockquote>
<p>删除文件夹，但是只允许你删除空文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ rmdir dir1</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="9">
<li>rm</li>
</ol>
<blockquote>
<p>删除文件夹以及文件夹内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ rm 2.txt</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -r dir2  <span class="comment">## 删除文件夹dir2以及内容</span></span><br><span class="line">rm -rf dir2 <span class="comment">## 强制删除文件夹dir2以及内容</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="10">
<li>touch</li>
</ol>
<blockquote>
<p>创建新文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ touch index.js</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="11">
<li>locate</li>
</ol>
<blockquote>
<p>搜索文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ locate -i <span class="keyword">in</span>*x.html</span><br><span class="line">/usr/lib/python3/dist-packages/twisted/python/_pydoctortemplates/index.html</span><br><span class="line">/usr/share/doc/adduser/examples/adduser.local.conf.examples/skel.other/index.html /usr/share/doc/gdisk/index.html</span><br><span class="line">/usr/share/doc/python3/python-policy.html/index.html</span><br><span class="line">/usr/share/doc/shared-mime-info/shared-mime-info-spec.html/index.html</span><br></pre></td></tr></table></figure>
<p>注意<br>locate 与 find 不同: find 是去硬盘找，locate 只在 /var/lib/slocate 资料库中找<br>locate 的速度比 find 快，它并不是真的查找，而是查数据库</p>
</blockquote>
<ol start="11">
<li>find</li>
</ol>
<blockquote>
<p>在给定的文件夹内搜索文件或文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ find . -name 3.txt</span><br><span class="line">./3.txt</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -name tran.txt     <span class="comment"># 在当前文件夹下寻找tran.txt文件</span></span><br><span class="line">find . -iname tran.txt     <span class="comment"># 在当前文件夹下寻找tran.txt文件，并且不区分大小写</span></span><br><span class="line">find . -<span class="built_in">type</span> d -name dir  <span class="comment"># 在当前文件夹下找dir文件夹</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="12">
<li>grep</li>
</ol>
<blockquote>
<p>文件内容搜索</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ grep 123 index.js 123 123 123</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -i -w <span class="string">&#x27;hello&#x27;</span> index.js        <span class="comment"># index.js文件里搜索hello，区分大小写</span></span><br><span class="line">grep -E -i -w <span class="string">&#x27;123|hello&#x27;</span> index.js <span class="comment"># index.js文件里搜索123或者hello，区分大小写，并且使用正则匹配</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="13">
<li>sudo</li>
</ol>
<blockquote>
<p>以管理员权限运行</p>
</blockquote>
<ol start="14">
<li>df</li>
</ol>
<blockquote>
<p>查看系统磁盘使用情况，展示单位为%或者KB，使用<code>df -m</code>以MB展示磁盘使用情况</p>
</blockquote>
<ol start="15">
<li>du</li>
</ol>
<blockquote>
<p>查看文件夹和文件的磁盘占用情况<br>注意：磁盘占用情况不等于文件大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop$ du jquery-ui-table</span><br><span class="line">16      jquery-ui-table/.git/hooks</span><br><span class="line">0       jquery-ui-table/.git/inf</span><br><span class="line">108     jquery-ui-table/.git/objects/pack</span><br><span class="line">108     jquery-ui-table/.git/objects</span><br><span class="line">124     jquery-ui-table/.git</span><br><span class="line">40      jquery-ui-table/src</span><br><span class="line">40      jquery-ui-table/<span class="built_in">test</span></span><br><span class="line">204     jquery-ui-table</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">du -sh babel  <span class="comment"># 统计babel文件夹磁盘占用情况，并以合适的单位显示</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="16">
<li>head</li>
</ol>
<blockquote>
<p>展示文件前几行内容，默认前10行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ head index.js</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">head -n 5 index.js        <span class="comment"># 查看index.js文件前5行内容</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="17">
<li>tail</li>
</ol>
<blockquote>
<p>和head类似，展示后面几行</p>
</blockquote>
<ol start="18">
<li>diff</li>
</ol>
<blockquote>
<p>文件内容逐行对比</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ diff 2.txt 3.txt</span><br><span class="line">5d4</span><br><span class="line">&lt; world</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="19">
<li>chmod</li>
</ol>
<blockquote>
<p>修改文件的读写可执行权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x deploy.sh  <span class="comment"># 让deploy.sh脚本有可执行权限</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="20">
<li>chown</li>
</ol>
<blockquote>
<p>修改文件的所有权</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown anotheruser deploy.sh  <span class="comment"># 将deploy.sh文件所有权赋予非anotheruser</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="21">
<li>kill</li>
</ol>
<blockquote>
<p>终止进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -KILL 123456 <span class="comment"># 杀死进程号PID为123456的进程</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="22">
<li>ping</li>
</ol>
<blockquote>
<p>测试与服务器连接状况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew$ ping baidu.com</span><br><span class="line">PING baidu.com (39.156.69.79) 56(84) bytes of data. 64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=1 ttl=52</span><br><span class="line">time=28.0ms 64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=2 ttl=52 time=30.9ms 64 bytes from 39.156.69.79 (</span><br><span class="line">39.156.69.79): icmp_seq=3 ttl=52 time=123 ms ... --- baidu.com ping statistics --- 34 packets transmitted, 34 received,</span><br><span class="line">0% packet loss, time 33235ms rtt min/avg/max/mdev = 27.417/39.384/123.661/22.443 ms</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="23">
<li>wget</li>
</ol>
<blockquote>
<p>下载文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew$ wget https://baidu.com.cn</span><br><span class="line">--2021-04-16 18:27:05--  https://baidu.com.cn/</span><br><span class="line">Resolving baidu.com.cn (baidu.com.cn)... 39.156.69.79, 220.181.38.148</span><br><span class="line">Connecting to baidu.com.cn (baidu.com.cn)|39.156.69.79|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 302 Moved Temporarily</span><br><span class="line">Location: http://www.baidu.com/ [following]</span><br><span class="line">--2021-04-16 18:27:06--  http://www.baidu.com/</span><br><span class="line">Resolving www.baidu.com (www.baidu.com)... 36.152.44.95, 36.152.44.96</span><br><span class="line">Connecting to www.baidu.com (www.baidu.com)|36.152.44.95|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 2381 (2.3K) [text/html]</span><br><span class="line">Saving to: ‘index.html’</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="24">
<li>uname</li>
</ol>
<blockquote>
<p>打印Unix系统名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew$ uname</span><br><span class="line">Linux</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="25">
<li>top</li>
</ol>
<blockquote>
<p>持续监听进程运行状态</p>
</blockquote>
<ol start="26">
<li>history</li>
</ol>
<blockquote>
<p>查询输入记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew$ <span class="built_in">history</span> | grep baidu <span class="comment"># 查询输入baidu相关历史命令</span></span><br><span class="line">268 ping baidu.com 269 wget htts://baidu.com.cn 270 wget https://baidu.com.cn</span><br><span class="line">279 <span class="built_in">history</span> | grep baidu</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="27">
<li>man</li>
</ol>
<blockquote>
<p>查看Linux中的指令帮助、配置文件帮助和编程帮助等信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man vim <span class="comment"># 查询vim使用说明</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="28">
<li>echo</li>
</ol>
<blockquote>
<p>输出指定的字符串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello </span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ <span class="built_in">echo</span> Hello, my name is John &gt;&gt; name.txt <span class="comment"># 将给定字符串写入name.txt文件</span></span><br><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ cat name.txt</span><br><span class="line">Hello, my name is John</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="29">
<li>zip, unzip</li>
</ol>
<blockquote>
<p>压缩，解压文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将当前目录下所有文件和文件夹打包为当前目录下的out.zip，加-q表示不显示过程</span></span><br><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ zip  -r out.zip .</span><br><span class="line">adding: 2.txt (deflated 4%)</span><br><span class="line">adding: 3.txt (deflated 6%)</span><br><span class="line">adding: dir/ (stored 0%)</span><br><span class="line">adding: dir/index.html (stored 0%)</span><br><span class="line">adding: dir/index.js (deflated 41%)</span><br><span class="line">adding: dir/name.txt (stored 0%)</span><br><span class="line">adding: dir/ss.tex (stored 0%)</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="30">
<li>hostname</li>
</ol>
<blockquote>
<p>查看主机名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ hostname</span><br><span class="line">matthew</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <tags>
        <tag>linux, command</tag>
      </tags>
  </entry>
  <entry>
    <title>Node流和子进程</title>
    <url>/bloger/2021/02/10/NodeJS/Node%E6%B5%81%E5%92%8C%E5%AD%90%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="核心一：流-Stream"><a href="#核心一：流-Stream" class="headerlink" title="核心一：流 Stream"></a>核心一：流 Stream</h3><p>####流</p>
<ul>
<li>非阻塞式的数据处理方式可提升效率</li>
<li>chunk 数据分块可以节省内存</li>
<li>管道可提高扩展性，方便组合</li>
</ul>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><ul>
<li>pipe</li>
<li>两种方式实现 pipe</li>
</ul>
<h4 id="Stream-对象的原型链"><a href="#Stream-对象的原型链" class="headerlink" title="Stream 对象的原型链"></a>Stream 对象的原型链</h4><ul>
<li>fs.createReadStream</li>
<li>自身属性 由 fs.ReadStream 构造</li>
<li>原型：stream.Readable.prototype</li>
<li>二级原型：stream.Stream.prototype</li>
<li>三级原型：events.EventEmitter.prototype</li>
<li>四级原型：Object.prototype</li>
<li>结论：Stream 对象都继承了 EventEmitter</li>
</ul>
<h4 id="Stream-分类"><a href="#Stream-分类" class="headerlink" title="Stream 分类"></a>Stream 分类</h4><ul>
<li>Readable Stream</li>
<li>Writable Stream</li>
<li>Duplex Stream</li>
<li>Transform Stream</li>
</ul>
<h4 id="如何自定义-Stream"><a href="#如何自定义-Stream" class="headerlink" title="如何自定义 Stream"></a>如何自定义 Stream</h4><h3 id="核心二：子进程-child-process"><a href="#核心二：子进程-child-process" class="headerlink" title="核心二：子进程 child_process"></a>核心二：子进程 child_process</h3><h4 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h4><ul>
<li>进程是程序的执行实例</li>
<li>程序在 CPU 上执行时的活动叫做进程</li>
<li>一个进程可以创建另一个进程（父进程与子进程）</li>
<li>通过任务管理器可以看到进程</li>
</ul>
<h4 id="了解-CPU"><a href="#了解-CPU" class="headerlink" title="了解 CPU"></a>了解 CPU</h4><ul>
<li>特点：一个单核 CPU，在一个时刻，只能做一件事</li>
<li>那如何让他用户用时看电影，听音乐，写代码呢？答案是在不同的进程中快速切换</li>
<li>【多程序并发执行】是指多个程序在宏观上并行，微观上串行</li>
<li>每个进程会出现【执行-暂停-执行】的规律，多个进程之间会出现抢资源的现象</li>
</ul>
<h4 id="什么是阻塞进程"><a href="#什么是阻塞进程" class="headerlink" title="什么是阻塞进程"></a>什么是阻塞进程</h4><ul>
<li>等待执行的进程队列中，都是非运行态的，一些在等待 CPU 资源，另一些 B 在等待 I/O 完成，<br>此时把 CPU 分配给 B 进程，B 还是在等 I/O，我们把这个 B 叫做阻塞进程，<br>因此，分派程序只会把 CPU 分配给非阻塞进程</li>
<li><a href="https://blog.csdn.net/Shangxingya/article/details/113799269">进程状态</a></li>
</ul>
<h4 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h4><h5 id="线程引入原因"><a href="#线程引入原因" class="headerlink" title="线程引入原因"></a>线程引入原因</h5><ul>
<li>进程是执行的基本实体，也是资源分配的基本实体</li>
<li>导致进程的创建，切换，和销毁太耗时间</li>
<li>于是引入线程，线程作为执行的基本实体</li>
<li>而进程只作为资源分配的基本实体</li>
</ul>
<h5 id="线程-Thread"><a href="#线程-Thread" class="headerlink" title="线程 Thread"></a>线程 Thread</h5><ul>
<li>CPU 调度和执行的最小单元</li>
<li>一个进程中至少有一个线程，可以有多个线程，同时一个线程只能属于一个进程</li>
<li>一个进程中的所有线程共享该进程的所有资源</li>
<li>进程的第一个线程叫做初始化线程</li>
<li>线程的调度可以由操作系统负责，也可以由用户自己负责</li>
<li>举例：浏览器进程里面有渲染引擎，V8 引擎，存储模块，网络模块，用户界面模块等，每一个模块都可以放在一个线程里面</li>
</ul>
<h4 id="Node-js-的进程控制"><a href="#Node-js-的进程控制" class="headerlink" title="Node.js 的进程控制"></a>Node.js 的进程控制</h4><ul>
<li>使用目的：子进程运行结果存储在系统缓存中（最大 200KB），等到子进程运行结束后，主进程再用回调函数读取子进程运行结果</li>
<li>API<ul>
<li>exec</li>
<li>流式</li>
<li>Promise</li>
<li>为防止 cmd 注入，推荐使用 execFile</li>
<li>execFile</li>
<li>spawn<ul>
<li>用法和 execFile 类似</li>
<li>没有回调函数，只能通过留流事件获取结果</li>
<li>没有最大 200KB 限制，因为是流式的</li>
</ul>
</li>
<li>fork<ul>
<li>创建一个子进程，执行 Node 脚本</li>
<li>fork(‘./child.js’)相当于 spawn(‘node’, [‘./child.js’])</li>
<li>特点 1：会多出一个 message 事件，用于父子通信</li>
<li>特点 2：会多出一个 send 方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Node-js-的线程控制"><a href="#Node-js-的线程控制" class="headerlink" title="Node.js 的线程控制"></a>Node.js 的线程控制</h4><ul>
<li>加入较迟，效率不如内置 I/O 操作</li>
<li>API<ul>
<li>isMainThread</li>
<li>new Worker(filename)</li>
<li>parentPort</li>
<li>postMessage</li>
<li>message</li>
<li>exit</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
  </entry>
  <entry>
    <title>深入REACT技术栈 阅读笔记</title>
    <url>/bloger/2021/02/03/UI%E6%A1%86%E6%9E%B6/%5B%E9%99%88%E5%B1%B9%5D%E6%B7%B1%E5%85%A5REACT%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
    <content><![CDATA[<h2 id="React-事件系统"><a href="#React-事件系统" class="headerlink" title="React 事件系统"></a>React 事件系统</h2><h3 id="描述性定义"><a href="#描述性定义" class="headerlink" title="描述性定义"></a>描述性定义</h3><ol>
<li>React 基于 Virtual DOM 实现的一个 SyntheticEvent （合成事件）层</li>
<li>比如我们在 JSX 里给一个按钮添加的 onClick 处理方法就是 React 合成事件</li>
<li>它完全符合 W3C 标准，不存在浏览器兼容问题</li>
<li>与原生浏览器事件接口一样，同样支持事件冒泡</li>
<li>所有事件都自动绑定到最外层，如果需要访问原生事件对象，可以使用 nativeEvent 属性</li>
</ol>
<h4 id="合成事件如何绑定？"><a href="#合成事件如何绑定？" class="headerlink" title="合成事件如何绑定？"></a>合成事件如何绑定？</h4><ol>
<li>在 React 组件中，每个方法的上下文都会指向该组件的实例，即自动绑定 this 为当前组件</li>
<li>在使用 ES6 class 或者 函数组件的时候，需要手动绑定</li>
<li>手动绑定方法有：bind 绑定，constructor 绑定，箭头函数这三种</li>
</ol>
<h4 id="合成事件代理机制"><a href="#合成事件代理机制" class="headerlink" title="合成事件代理机制"></a>合成事件代理机制</h4><ol>
<li>React 并不会把事件处理函数直接绑定到真实节点上，而是绑定在最外层，使用一个统一的事件监听器，这个事件监听器维持了一个映射来保存所有组件内部的事件监听和处理函数</li>
<li>当组件挂载或者卸载时，只是在这个统一的事件监听器上插入或者删除一些对象</li>
<li>当组件事件发生时，首先被这个统一的事件监听器处理，然后再映射里找到真正的事件处理函数并调用</li>
</ol>
<h4 id="可以在-React-中使用原生事件吗？"><a href="#可以在-React-中使用原生事件吗？" class="headerlink" title="可以在 React 中使用原生事件吗？"></a>可以在 React 中使用原生事件吗？</h4><ol>
<li>可以的。虽然 React 事件好处多多，但是并没有实现所有的应用场景，比如 resize 事件</li>
<li>在 React 中有三种方法使用原生事件</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  btnRef = createRef();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;handleClick&quot;</span>, e.target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 原生事件refs</span></span><br><span class="line">    <span class="comment">// this.refs.button.addEventListener(&#x27;click&#x27;, this.handleClick);</span></span><br><span class="line">    <span class="comment">// callback</span></span><br><span class="line">    <span class="comment">// this.btn.addEventListener(&#x27;click&#x27;, this.handleClick);</span></span><br><span class="line">    <span class="comment">// createRef</span></span><br><span class="line">    <span class="built_in">this</span>.btnRef.current.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="built_in">this</span>.handleClick);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="comment">/* &lt;button type=&quot;button&quot; ref=&quot;button&quot;&gt;Test button&lt;/button&gt; */</span>&#125;</span><br><span class="line">        &#123;<span class="comment">/* &lt;button type=&quot;button&quot; ref=&#123;obj =&gt; this.btn = obj&#125;&gt;Test button&lt;/button&gt; */</span>&#125;</span><br><span class="line">        &lt;button type=<span class="string">&quot;button&quot;</span> ref=&#123;<span class="built_in">this</span>.btnRef&#125;&gt;</span><br><span class="line">          Test button</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对比-React-合成事件和-JavaScript-原生事件"><a href="#对比-React-合成事件和-JavaScript-原生事件" class="headerlink" title="对比 React 合成事件和 JavaScript 原生事件"></a>对比 React 合成事件和 JavaScript 原生事件</h4><ol>
<li>事件传播和阻止事件传播</li>
</ol>
<ul>
<li>浏览器原生 DOM 事件传播分三个阶段：事件捕获阶段，目标处理阶段，事件冒泡阶段</li>
<li>但是事件捕获阶段兼容性并不好，所以 React 并没有实现事件捕获阶段，只实现了事件冒泡</li>
<li>阻止原生事件需要使用<code>e.preventDefault()</code>和<code>e.cancelBubble = true</code>，React 事件系统中只需使用<code>e.preventDefault()</code>即可</li>
</ul>
<ol start="2">
<li>事件类型 React 合成事件的事件类型是原生事件类型的子集</li>
<li>事件绑定方式</li>
</ol>
<ul>
<li><p>原生事件绑定有三种</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>// 直接在 DOM 元素中绑定：<br><button onclick="alert(1);">Test</button><br>// 在 JavaScript 中，通过为元素的事件属性赋值的方式实现绑定： el.onclick = e =&gt; { console.log(e); } // 通过事件监听函数来实现绑定： el.addEventListener(‘<br>click’, () =&gt; { }, false); el.attachEvent(‘onclick’, () =&gt; { });</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 相比而言，React 合成事件的绑定方式则简单得多：&#96;&lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;Test&lt;&#x2F;button&gt; &#96;</span><br><span class="line"></span><br><span class="line">4. 事件对象 原生DOM事件对象在W3C标准和IE标准下实现有所不同，儿在React合成事件系统中，不存在兼容问题</span><br><span class="line"></span><br><span class="line">## CSS Modules是什么</span><br><span class="line"></span><br><span class="line">1. CSS模块化解决方案主要有两类：Inline和MOdule</span><br><span class="line">2. CSS模块化过程中遇到了如下问题：</span><br><span class="line">  - 全局污染</span><br><span class="line">  - 命名混乱</span><br><span class="line">  - 依赖管理不彻底</span><br><span class="line">  - 无法共享变量</span><br><span class="line">  - 代码压缩不彻底</span><br><span class="line">3. CSS模块化方案实践发展：SMACSS-&gt;OOCSS-&gt;BEM</span><br><span class="line">4. webpack的css-loader支持模块化CSS</span><br><span class="line">5. CSS Modules 结合 React 实践</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">&#x2F;* dialog.css *&#x2F;</span><br><span class="line">.</span><br><span class="line">root</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">.</span><br><span class="line">confirm</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">.</span><br><span class="line">disabledConfirm</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* dialog.js *&#x2F;</span><br><span class="line">import React, &#123;Component&#125; from &#39;react&#39;;</span><br><span class="line">import classNames from &#39;classnames&#39;;</span><br><span class="line">import CSSModules from &#39;react-css-modules&#39;;</span><br><span class="line">import styles from &#39;.&#x2F;dialog.css&#39;;</span><br><span class="line"></span><br><span class="line">class Dialog extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">      const cx &#x3D; classNames(&#123;</span><br><span class="line">          confirm: !this.state.disabled,</span><br><span class="line">          disabledConfirm: this.state.disabled,</span><br><span class="line">      &#125;);</span><br><span class="line">      return (</span><br><span class="line">          &lt;div styleName&#x3D;&quot;root&quot;&gt;</span><br><span class="line">              &lt;a styleName&#x3D;&#123;cx&#125;&gt;Confirm&lt;&#x2F;a&gt;</span><br><span class="line">          &lt;&#x2F;div&gt;</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default CSSModules(Dialog, styles);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>这篇文章写的差不多：<a href="https://zhuanlan.zhihu.com/p/100133524">https://zhuanlan.zhihu.com/p/100133524</a></li>
</ol>
<h2 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h2><h4 id="父组件到子组件"><a href="#父组件到子组件" class="headerlink" title="父组件到子组件"></a>父组件到子组件</h4><p>props</p>
<h4 id="子组件到父组件"><a href="#子组件到父组件" class="headerlink" title="子组件到父组件"></a>子组件到父组件</h4><ol>
<li>回调函数</li>
<li>自定义事件机制</li>
</ol>
<h4 id="无嵌套关系的组件间"><a href="#无嵌套关系的组件间" class="headerlink" title="无嵌套关系的组件间"></a>无嵌套关系的组件间</h4><p>自定义事件机制，比如 EventEmitter</p>
<h4 id="跨级组件通信"><a href="#跨级组件通信" class="headerlink" title="跨级组件通信"></a>跨级组件通信</h4><p>context</p>
<h2 id="组件间抽象"><a href="#组件间抽象" class="headerlink" title="组件间抽象"></a>组件间抽象</h2><h4 id="minxin"><a href="#minxin" class="headerlink" title="minxin"></a>minxin</h4><p>不推荐使用：<a href="https://github.com/tcatche/tcatche.github.io/issues/53">https://github.com/tcatche/tcatche.github.io/issues/53</a></p>
<h4 id="decorator"><a href="#decorator" class="headerlink" title="decorator"></a>decorator</h4><p>core-decorators stage-2</p>
<h4 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h4><ol>
<li>实现高阶组件两种方法：属性代理和反向继承</li>
<li>具体参考：<a href="https://github.com/Matthrews/rfzhu_blogs/blob/main/%E6%8A%80%E6%9C%AF/React/React%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.md">高阶组件及其应用场景</a></li>
</ol>
<h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p><a href="https://jestjs.io/">Jest</a><br><a href="https://enzymejs.github.io/enzyme/">Enzyme</a><br><a href="https://github.com/Matthrews/edb/actions/new">GitHub Actions</a></p>
]]></content>
      <categories>
        <category>UI框架</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>前端路由</title>
    <url>/bloger/1970/01/01/React/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h1 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h1><blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2016/05/react_router.html">http://www.ruanyifeng.com/blog/2016/05/react_router.html</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/78176856">https://zhuanlan.zhihu.com/p/78176856</a></p>
<p><a href="https://reactrouter.com/web/guides/quick-start">https://reactrouter.com/web/guides/quick-start</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1520537">https://cloud.tencent.com/developer/article/1520537</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>前端路由</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/bloger/2021/04/21/React/%E6%BA%90%E7%A0%81%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="React16-8-0"><a href="#React16-8-0" class="headerlink" title="React16.8.0"></a>React16.8.0</h2><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><ol>
<li><p>hooks</p>
</li>
<li><p>useReducer 懒初始化</p>
</li>
</ol>
<h3 id="React-DOM"><a href="#React-DOM" class="headerlink" title="React DOM"></a>React DOM</h3><ol>
<li><p>使用 Object.is 比较 useState 和 useReducer 的值</p>
</li>
<li><p>React.lazy() 支持异步</p>
</li>
<li><p>Effect 的清楚函数要么返回 undefined 要么返回 function, 否则是不允许的</p>
</li>
</ol>
<h4 id="React-Test"><a href="#React-Test" class="headerlink" title="React Test"></a>React Test</h4><ol>
<li><p>支持 hooks</p>
</li>
<li><p>新增 ReactTestRenderer.act() 和 ReactTestUtils.act() 用于批量操作以贴近实际场景</p>
</li>
</ol>
<h4 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h4><ol>
<li>支持 hooks</li>
</ol>
<h2 id="React17-0-0"><a href="#React17-0-0" class="headerlink" title="React17.0.0"></a>React17.0.0</h2><h3 id="React-1"><a href="#React-1" class="headerlink" title="React"></a>React</h3><ol>
<li><p>新增 react/jsx-runtime 和 react/jsx-dev-runtime 处理 JSX 转换</p>
</li>
<li><p>context 可以设置 displayName 以便调试</p>
</li>
<li><p>停止使用 fb.me 进行重定向(@cylim refactor fb.me url to reactjs.org/link)</p>
</li>
</ol>
<h3 id="React-DOM-1"><a href="#React-DOM-1" class="headerlink" title="React DOM"></a>React DOM</h3><ol>
<li><p>dom 绑定到 root 上而不是 document 上</p>
</li>
<li><p>在运行下一个 effect 会把之前的所有 effect 清除</p>
</li>
<li><p>异步运行 effect 清除函数</p>
</li>
<li><p>合成事件系统完善，移除事件池等</p>
</li>
<li><p>Fix</p>
</li>
</ol>
<h2 id="React15-0-0"><a href="#React15-0-0" class="headerlink" title="React15.0.0"></a>React15.0.0</h2>]]></content>
      <tags>
        <tag>react, 源码</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工程化实践</title>
    <url>/bloger/2021/05/05/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="前端工程化实践"><a href="#前端工程化实践" class="headerlink" title="前端工程化实践"></a>前端工程化实践</h1><blockquote>
<p>参考：《前端技术架构与工程》作者: <a href="https://book.douban.com/search/%E5%91%A8%E4%BF%8A%E9%B9%8F">周俊鹏</a></p>
</blockquote>
<p>前端工程化是前端开发的一种思维方式，是针对前端开发过程中遇到的一些列问题的解决方案。前端工程化围绕编码、方法、工具三个要素展开。<br>从前端应用的技术架构本身出发，关注点聚焦于模块解耦、数据管理架构模式、性能以及前后端分离，目标是实现架构的高可用性、可扩展性、可伸缩性，同时提高独立开发和跨团队协作开发的效率；<br>从架构之外的角度出发，关注点聚焦于前端应用的开发、架构、测试、部署以及持续化工程体系，目标是建立规范、有序、高效的迭代流程，降低产品迭代所消耗的人力和沟通成本。</p>
<h2 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h2><ul>
<li><p>统一技术栈减少团队成员学习成本以及协作成本</p>
</li>
<li><p>自建 Mock 平台让加快前端开发效率</p>
<p><a href="https://github.com/Matthrews/mock_server">具体实践</a></p>
</li>
<li><p>通过 Git 进行代码版本管理, 便于 Code Review 和 Version Revert</p>
</li>
<li><p>通过 husky, @commitlint/cli, @commitlint/config-conventional 规范 Git commit</p>
</li>
<li><p>通过 ESLint 检查代码错误，使用 Prettier 格式化代码</p>
</li>
<li><p>通过 Code Review 责任连带机制严格把控代码质量</p>
</li>
</ul>
<h2 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h2><p>构建阶段主要围绕以下方面展展开：</p>
<ul>
<li><p>编程语言，将源代码编译为客户端可执行代码代码的过程，Babel/Typescript/PostCSS 等工具均属于此类</p>
</li>
<li><p>性能优化，比如压缩混淆，自动生成 CSS Sprite，动态模块按需加载，文件 hash，图片优化等</p>
</li>
<li><p>部署策略，比如给静态资源 URL 加入 Hash 指纹或者 CDN 路径等</p>
</li>
<li><p>开发效率，比如文档生成，动态构建等<br><a href="https://github.com/Matthrews/typescript-doc-gen">具体实践</a></p>
</li>
<li><p>审查评估，比如规范审查，性能评估等</p>
</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><a href="https://testing-library.com/docs/ecosystem-jest-dom/">jest-dom</a><br><a href="https://www.jestjs.cn/">Jest</a><br><a href="https://mochajs.cn/">JavaScript 测试框架 Mocha</a><br><a href="https://www.chaijs.com/">断言库 Chai</a><br><a href="https://www.cypress.io/">下一代自动化测试框架 Cypress</a></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>其目的就是将资源准确地放到不同环境的服务器上，其核心在于流程的控制。</p>
<h2 id="持续化"><a href="#持续化" class="headerlink" title="持续化"></a>持续化</h2><ul>
<li>CI/CD</li>
</ul>
<h2 id="监控与统计"><a href="#监控与统计" class="headerlink" title="监控与统计"></a>监控与统计</h2><p><a href="https://www.elastic.co/cn/elastic-stack/">The Elastic Stack</a></p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>以用户为中心的性能指标</title>
    <url>/bloger/1970/01/01/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96----%E4%BB%A5%E7%94%A8%E6%88%B7%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<h1 id="以用户为中心的性能指标"><a href="#以用户为中心的性能指标" class="headerlink" title="以用户为中心的性能指标"></a>以用户为中心的性能指标</h1><p>[TOC]</p>
<p>我们都听说过性能如何重要如何重要，但当我们讨论性能——可能就是让网站“快”，那么具体是什么意思呢？ 事实上，性能是一个相对的概念：</p>
<ul>
<li>一个网站可能对某一个用户来说很快(在一个功能强大并且网络优质的设备上的时候)，但是对另一个用户来说就很慢(在一个网速很慢的低端设备上的时候)。</li>
<li>两个网站同时加载完成可能总耗时相同，但是有一个可能会加载地更快(如果这个网站渐进式加载而不是等到最后才展示页面)</li>
<li>一个网站可能看起来加载的很快，但是对用户交互却响应的很慢(甚至不响应)</li>
</ul>
<p>所以当谈到性能，精确化和可以使用量化的客观标准计算是非常重要的。这些标准我们称之为指标。</p>
<p>但是仅仅因为指标是基于客观标准并且可以被量化，那也并不意味着这些计算是有用的。</p>
<h2 id="指标定义"><a href="#指标定义" class="headerlink" title="指标定义"></a>指标定义</h2><p>传统上，web性能是通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event">加载事件</a>来计算的。但是，即使<code>加载事件</code>是一个页面生命周期中定义的一个精准的时刻，这个时刻也并不与用户关心的任何东西相对应。</p>
<p>比如，一个服务器可能发送了一个最小化的页面立刻就加载了，但是推迟拉取内容和展示内容，直到数秒后<code>负载事件</code>发起。虽然这个页面可能加载的很快，但是这个很快并不对应一个用户感觉这个页面很快。</p>
<p>过去数年里，Chrome团队成员和<a href="https://www.w3.org/webperf/">W3C Web Performance Working Group</a>一直齐心努力标准化一些可以更精确计算用户如何感知网页性能的API和指标。</p>
<p>为了确保这些指标是用户相关的，我们围绕一些关键性问题展开：</p>
<table>
<thead>
<tr>
<th>关键性问题</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>是否发生</td>
<td>导航成功启动了吗？服务器响应了吗？</td>
</tr>
<tr>
<td>是否有用</td>
<td>是否内容都渲染完毕了？</td>
</tr>
<tr>
<td>是否可用</td>
<td>用户可可以与页面交互了吗，还是页面很忙？</td>
</tr>
<tr>
<td>是否优雅</td>
<td>交互是否顺畅自然，没有滞后和停顿？</td>
</tr>
</tbody></table>
<h2 id="指标如何计算"><a href="#指标如何计算" class="headerlink" title="指标如何计算"></a>指标如何计算</h2><p>性能指标一般有以下两种方式可以计算：</p>
<ul>
<li><strong>实验环境：</strong>使用工具模拟页面在一个相同的受控环境下加载</li>
<li><strong>真实环境：</strong>通过实际加载页面和与之交互的用户计算</li>
</ul>
<p>这些方法并没有一个确定的孰优孰劣的关系。实际上，你通常会同时使用两种方法以确保更好的性能</p>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>当开发新功能的时候，开发环境下测试性能是非常重要的。在生产环境下新功能发布之前，通过真实用户测试性能特征是不可能的，所以在产品发布之前，开发环境测试以免性能降低是最好的方法。</p>
<h2 id="真实环境"><a href="#真实环境" class="headerlink" title="真实环境"></a>真实环境</h2><p>另一方面，虽然在开发环境下测试是测试性能的一种合理替代，但是这也并不一定反映了所有用户在你的网站上的体验。</p>
<p>用户设备的不同和用户网络质量好的好坏都会使得不同用户对应的网页性能差距很大。当然这还基于用户是否与页面交互或者如何与页面进行交互。</p>
<p>此外，加载的网页不一定是确定的。比如，一些加载个性化内容或者广告的网站的性能可能会因人而异。而开发环境并不能捕捉到这些不同。</p>
<h2 id="指标类型"><a href="#指标类型" class="headerlink" title="指标类型"></a>指标类型</h2><p>还有一些其他类型的指标和用户看待性能有关</p>
<ul>
<li><strong>感知加载速度：</strong> 页面加载并渲染所有可见元素到屏幕上的速度</li>
<li><strong>加载响应度：</strong> 页面加载和执行<code>JavaScript</code>代码生成用来交互的组件的速度</li>
<li><strong>运行时响应度：</strong> 页面加载完毕后，页面可以响应网页交互的速度</li>
<li><strong>视觉稳定性：</strong> 网页元素是否不如用户期待那样移动了并且还潜在的干扰了用户的交互</li>
</ul>
<p>鉴于以上所有类型的性能指标，我们可以清楚地意识到：没有一个单独的指标可以非常有效的捕捉到一个页面的所有性能特征。</p>
<h2 id="重要的指标"><a href="#重要的指标" class="headerlink" title="重要的指标"></a>重要的指标</h2><ul>
<li><a href="https://web.dev/fcp/">First Contentful Paint(FCP)</a>：页面丛开始加载到任一元素渲染到屏幕上的时间。</li>
<li><a href="https://web.dev/lcp/">Largest Contentful Paint(LCP)</a>：页面丛开始加载到最多的元素渲染到屏幕上的时间。</li>
<li><a href="https://web.dev/fid/">First Input Delay(FID)</a>：用户首次与页面交互(比如当点击链接或者一个按钮或者使用一个自定义的<code>JavaScript</code>驱动)到浏览器实际响应的时间。</li>
<li><a href="https://web.dev/tti/">Time to Interactive(TTI)</a>：页面从加载到进行视觉渲染并可能可靠响应用户输入的页面的时间。</li>
<li><a href="https://web.dev/tbt/">Total Blocking Time(TBT)</a>：页面丛开始加载到任一元素渲染到屏幕上的时间。</li>
</ul>
<h2 id="自定义指标"><a href="#自定义指标" class="headerlink" title="自定义指标"></a>自定义指标</h2>]]></content>
      <tags>
        <tag>前端，性能</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化----雅虎35条军规</title>
    <url>/bloger/1970/01/01/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96----%E9%9B%85%E8%99%8E35%E6%9D%A1%E5%86%9B%E8%A7%84/</url>
    <content><![CDATA[<h4 id="前端性能优化—-雅虎35条军规"><a href="#前端性能优化—-雅虎35条军规" class="headerlink" title="前端性能优化—-雅虎35条军规"></a>前端性能优化—-雅虎35条军规</h4><ol>
<li><p>减少HTTP请求</p>
<p>80%的终端响应时间主要花费在前端，而这部分时间主要在下载网页中的图片，样式文件，脚本文件，flash等资源。减少这些资源的数量就相应地减少了用于渲染页面的HTT请求数量。以下是一些具体的方法</p>
</li>
</ol>
<ul>
<li><p>简化设计</p>
</li>
<li><p>打包文件，将多个JS文件打包成一个JS文件，同样地，将多个CSS文件打包成一个CSS文件</p>
</li>
<li><p>使用CSS Sprites，将页面中用到的背景小图标并合成一张图片，再使用CSS中的<code>bakground-image</code>和<code>background-position</code>来显示所需图像部分</p>
</li>
<li><p>图像映射，html标签<map>，可以创建可点击的图像区域，具体参考<code>w3school</code>或者W3C文档</p>
</li>
<li><p>内嵌图片，通过<code>data:URL scheme</code>内嵌</p>
</li>
</ul>
<ol start="2">
<li><p>使用CDN</p>
<p>在现有的网络中增加一层新的网络架构，将网站的内容发布到最接近用户的Cache服务器内，通过DNS负责均衡技术，判断用户来源就近访问Cache服务器上所需的内容。如此便可以减少数据在网络上传输的时间，提高速度</p>
</li>
<li><p>设置头文件过期时间或者缓存策略</p>
<ul>
<li>静态内容：将 Expires 响应头设置为将来很远的时间，实现「永不过期」策略；</li>
<li>动态内容：设置合适的 Cache-Control 响应头，让浏览器有条件地发起请求。</li>
</ul>
</li>
<li><p><code>Gzip</code>压缩</p>
<ul>
<li><p><code>Gzip</code>压缩通常可以减少70%的响应大小，对某些文件更可能高达90%，比<code>Deflate</code>更高效</p>
</li>
<li><p>主流 Web 服务器都有相应模块，而且绝大多数浏览器支持<code>gzip</code>解码</p>
</li>
<li><p>图片和 PDF 文件不要使用 <code>gzip</code>，它们本身已经压缩过，再使用<code>gzip</code> 压缩不仅浪费 CPU 资源，而且还可能增加文件体积</p>
</li>
<li><p>从HTTP/1.1开始，web客户端就有了支持压缩的Accept-Encoding HTTP请求头</p>
</li>
</ul>
</li>
<li><p>把CSS文件放在顶部</p>
<p>把样式表放在<code>&lt;head&gt;</code>中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉。</p>
</li>
<li><p>把JS文件放在底部</p>
<ul>
<li><p>浏览器下载脚本时，会阻塞其他资源并行下载，即使是来自不同域名的资源。因此，最好将脚本放在底部，以提高页面加载速度。</p>
</li>
<li><p>一些特殊场景无法将脚本放到页面底部的，可以考虑<code>&lt;script&gt;</code>的以下属性：</p>
</li>
<li><p>defer 属性；</p>
</li>
<li><p>HTML5 新增的<code>async</code>属性。</p>
</li>
</ul>
</li>
<li><p>避免CSS表达式</p>
<p>CSS表达式可以在CSS里执行JavaScript，仅IE5-IE7支持，IE8标准模式已经废弃。 CSS表达式超出预期的频繁执行，页面滚动、鼠标移动时都会不断执行，带来很大的性能损耗。</p>
</li>
<li><p>将JS和CSS外链</p>
<p>外部JavaScript和CSS文件可以被浏览器缓存，在不同页面间重用，也能降低页面大小。</p>
</li>
<li><p>减少DNS查询</p>
<ul>
<li>用户输入URL以后，浏览器首先要查询域名（hostname）对应服务器的IP地址，一般需要耗费20-120毫秒时间。DNS查询完成之前，浏览器无法从服务器下载任何数据。</li>
<li>基于性能考虑，ISP、局域网、操作系统、浏览器都会有相应的DNS缓存机制。 IE缓存30分钟，可以通过注册表中DnsCacheTimeout项设置；<br>Firefox缓存1分钟，通过network.dnsCacheExpiration配置；</li>
</ul>
</li>
<li><p>减小JSS和CSS体积</p>
<ul>
<li><p>压缩代码可以移除非功能性的字符（注释、空格、空行等），减少文件大小，提高载入速度</p>
</li>
<li><p>开源社区有很多前端优化工具，比如：<a href="https://cssnano.co/">cssnano</a>  , <a href="https://www.crockford.com/jsmin.html">JSMin</a><br>, <a href="https://skalman.github.io/UglifyJS-online/">UglifyJS</a></p>
</li>
<li><p><a href="https://gulpjs.com/">Gulp</a>, <a href="https://webpack.js.org/">Webpack</a>等流行构建工具都有相应的支持</p>
</li>
</ul>
</li>
<li><p>避免重定向</p>
<ul>
<li>客户端收到服务器的重定向响应后，会根据响应头中Location的地址再次发送请求。重定向会影响用户体验，尤其是多次重定向时，用户在一段时间内看不到任何内容，只看到浏览器进度条一直在刷新。</li>
<li>最浪费的重定向经常发生、而且很容易被忽略：URL 末尾应该添加<code>/</code><br>但未添加。比如，访问<code>http://astrology.yahoo.com/astrology</code>将被<code>301</code>重定向到 <code>http://astrology.yahoo.com/astrology/</code>（注意末尾的 /）。如果使用<br>Apache，可以通过<code>Alias</code>或<code>mod_rewrite</code>或<code>DirectorySlash</code>解决这个问题。</li>
<li>网站域名变更：<code>CNAME</code>结合<code>Alias</code>或<code>mod_rewrite</code>或者其他服务器类似功能实现跳转。</li>
</ul>
</li>
<li><p>移除重复脚本</p>
<p>重复的脚本不仅产生不必要的HTTP请求，而且重复解析执行浪费时间和计算资源。</p>
</li>
<li><p>配置<code>ETags</code></p>
<p><code>ETags</code>通过文件版本标识，方便服务器判断请求的内容是否有更新，如果没有就响应 304，避免重新下载</p>
</li>
<li><p>缓存Ajax</p>
<p>有尚未过期的Expires或者Cache-Control HTTP头，那么之前的资源就可以从缓存中读出。必须通知浏览器，应该继续使用之前缓存的资源响应，还是去请求一个新的。可以通过给资源的Ajax<br>URL里添加一个表明用户资源最后修改时间的时间戳来实现。如果资源从上一次下载之后再没有被修改过，时间戳不变，资源就将从浏览器缓存中直接读出，从而避免一次额外的HTTP往返消耗。具体参考[3. 设置头文件过期时间或者缓存策略](#3.<br>设置头文件过期时间或者缓存策略)</p>
</li>
<li><p>尽早释放缓冲</p>
<p>用户请求页面时，服务器通常需要花费200 ~ 500毫秒来组合 HTML 页面。在此期间，浏览器处于空闲、等待数据状态。使用PHP中的flush()函数，可以发送部分已经准备好的<br>HTML到浏览器，以便服务器还在忙于处理剩余页面时，浏览器可以提前开始获取资源。</p>
</li>
<li><p>用GET方式进行Ajax请求</p>
<p>浏览器执行POST请求时分成两步，先发送Http Header，再发送data。而GET只使用一个TCP数据包（Http Header与data）发送数据，所以首选GET方法。</p>
<p>根据HTTP规范，GET用于获取数据，POST则用于向服务器发送数据，所以Ajax请求数据时使用GET更符合规范。</p>
</li>
<li><p>预加载组件</p>
<p>预先加载利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应</p>
</li>
<li><p>延迟加载组件</p>
<p>页面初始加载时哪些内容是绝对必需的？不在答案之列的资源都可以延迟加载。比如：</p>
<ul>
<li>非首屏使用的数据、样式、脚本、图片等</li>
<li>用户交互时才会显示的内容</li>
</ul>
</li>
<li><p>减少DOM元素数量</p>
<p>从以下几个角度考虑移除不必要的标记：</p>
<ul>
<li>是否还在使用表格布局？</li>
<li>塞进去更多的<div>仅为了处理布局问题？也许有更好、更语义化的标记。</li>
<li>能通过伪元素实现的功能，就没必要添加额外元素，如清除浮动。 浏览器控制台中输入以下代码可以计算出页面中有多少 DOM 元素：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;*&#x27;</span>).length;</span><br></pre></td></tr></table></figure></li>
<li>为什么不使用表格布局？<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+ 更多的标签，增加文件大小；</span><br><span class="line">+ 不易维护，无法适应响应式设计；</span><br><span class="line">+ 性能考量，默认的表格布局算法会产生大量重绘</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>跨域分离组件</p>
<p>浏览器一般会限制每个域的并行线程（一般为6个，甚至更少），使用不同的域名可以最大化下载线程，但注意保持在2-4个域名内，以避免DNS查询损耗。</p>
</li>
<li><p>减少<code>iframe</code>数量</p>
<ul>
<li>用<code>iframe</code>可以把一个HTML文档插入到父文档里，重要的是明白<code>iframe</code>是如何工作的并高效地使用它。</li>
<li><code>iframe</code>的优点：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+ 可以用来加载速度较慢的第三方资源，如广告、徽章；</span><br><span class="line">+ 可用作安全沙箱；</span><br><span class="line">+ 可以并行下载脚本。</span><br></pre></td></tr></table></figure></li>
<li><code>iframe</code>的缺点：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+ 加载代价昂贵，即使是空的页面；</span><br><span class="line">+ 阻塞页面 load 事件触发；</span><br><span class="line">+ <span class="string">`iframe`</span> 完全加载以后，父页面才会触发 load 事件。 Safari、Chrome 中通过 JavaScript 动态设置 iframe src 可以避免这个问题。</span><br><span class="line">+ 缺乏语义。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>不要出现404页面</p>
<p>HTTP请求很昂贵，返回无效的响应（如404未找到）完全没必要，降低用户体验而且毫无益处</p>
</li>
<li><p>减小Cookie</p>
<p>Cookie被用于身份认证、个性化设置等诸多用途。Cookie通过HTTP头在服务器和浏览器间来回传送，减少Cookie大小可以降低其对响应速度的影响。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">- 去除不必要的 Cookie；</span><br><span class="line">- 尽量压缩 Cookie 大小；</span><br><span class="line">- 注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；</span><br><span class="line">- 设置合适的过期时间。</span><br></pre></td></tr></table></figure></li>
<li><p>对静态资源使用无Cookie的域名</p>
<p>静态资源一般无需使用Cookie，可以把它们放在使用二级域名或者专门域名的无Cookie服务器上，降低Cookie传送的造成的流量浪费，提高响应速度。</p>
</li>
<li><p>较少DOM访问次数</p>
<ul>
<li><p>JavaScript 操作操作 DOM 很慢，尤其是 DOM 节点很多时。</p>
</li>
<li><p>使用时应该注意：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">- 缓存已经访问过的元素；</span><br><span class="line">- 使用DocumentFragment暂存DOM，整理好以后再插入DOM树；</span><br><span class="line">- 操作className，而不是多次读写style；</span><br><span class="line">- 避免使用JavaScript修复布局。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>开发高效的事件处理句柄</p>
<ul>
<li>减少绑定事件监听的节点，如通过事件委托；</li>
<li>尽早处理事件，在DOMContentLoaded即可进行，不用等到load以后。</li>
</ul>
</li>
<li><p>使用<code>&lt;link&gt;</code>而非@import</p>
</li>
<li><p>避免使用过滤器</p>
<p>避免使用AlphaImageLoader，可以使用PNG8替代</p>
</li>
<li><p>优化图片</p>
<ul>
<li><a href="https://github.com/imagemin/imagemin">imagemin</a></li>
<li><a href="https://imageoptim.com/mac">imageoptim</a></li>
<li><a href="https://www.queness.com/post/2507/most-effective-method-to-reduce-and-optimize-png-images">PNG 优化1</a></li>
<li><a href="https://www.smashingmagazine.com/2009/07/clever-png-optimization-techniques/">PNG 优化2</a></li>
<li><a href="https://blog.csdn.net/whh181/article/details/94449493">Webp 相关内容</a></li>
<li><a href="https://segmentfault.com/a/1190000038521158">SVG 相关内容</a></li>
<li><a href="https://pmt.sourceforge.io/pngcrush/">Pngcrush</a></li>
</ul>
</li>
<li><p>优化CSS Sprites</p>
</li>
</ol>
<ul>
<li>水平排列<code>Sprite</code>中的图片，垂直排列会增加图片大小；</li>
<li><code>Sprite</code>中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以适用PNG8格式；</li>
<li>不要在<code>Sprite</code>的图像中间留有较大空隙。减少空隙虽然不太影响文件大小，但可以降低用户代理把图片解压为像素图的内存消耗，对移动设备更友好。</li>
</ul>
<ol start="31">
<li><p>不要再HTML中伸缩图片</p>
<p>不要使用<img>的width、height缩放图片，如果用到小图片，就使用相应大小的图片</p>
</li>
</ol>
<ol start="32">
<li><p>缩小<code>favicon.ico</code>的大小并使用缓存</p>
<p>Favicon.ico一般存放在网站根目录下，无论是否在页面中设置，浏览器都会尝试请求这个文件。所以确保这个图标：</p>
<ul>
<li>存在（避免 404）；</li>
<li>尽量小，最好小于 1K；</li>
<li>设置较长的过期时间。</li>
<li>对于较新的浏览器，可以使用PNG格式的favicon。</li>
</ul>
</li>
<li><p>保证组件在25K以下</p>
<p>这个限制是因为iPhone不能缓存大于25K(压缩前)的组件</p>
</li>
<li><p>将组件打包进一个多部分的文档中</p>
</li>
</ol>
<p>把各个组件打包成一个像有附件的电子邮件一样的复合文档里，可以用一个HTTP请求获取多个组件（记住一点：HTTP请求是代价高昂的）。用这种方式的时候，要先检查用户代理是否支持（iPhone就不支持）</p>
<ol start="35">
<li><p>避免空的图像<code>src</code>属性</p>
<ul>
<li>虽然src属性为空字符串，但浏览器仍然会向服务器发起一个HTTP请求</li>
<li>空的href属性也存在类似问题</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>前端，性能</tag>
      </tags>
  </entry>
  <entry>
    <title>前端监控</title>
    <url>/bloger/1970/01/01/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<h1 id="前端监控"><a href="#前端监控" class="headerlink" title="前端监控"></a>前端监控</h1><blockquote>
<p>参考：<a href="https://cloud.tencent.com/developer/article/1650831">https://cloud.tencent.com/developer/article/1650831</a></p>
</blockquote>
<h2 id="1-为什么要做前端性能监控？"><a href="#1-为什么要做前端性能监控？" class="headerlink" title="1. 为什么要做前端性能监控？"></a>1. 为什么要做前端性能监控？</h2><ul>
<li>更快发现问题和解决问题</li>
<li>做产品的决策依据</li>
<li>提升前端工程师的技术广度和打造简历亮点</li>
<li>为业务酷派站提供更多可能性</li>
</ul>
<h2 id="2-前端监控目标"><a href="#2-前端监控目标" class="headerlink" title="2. 前端监控目标"></a>2. 前端监控目标</h2><h3 id="2-1-稳定性"><a href="#2-1-稳定性" class="headerlink" title="2.1 稳定性"></a>2.1 稳定性</h3><ul>
<li>JS错误  JS执行错误或Promise异常</li>
<li>资源异常  script, link等资源加载异常</li>
<li>接口错误  网络请求异常</li>
<li>白屏  页面空白</li>
</ul>
<h3 id="2-2-用户体验"><a href="#2-2-用户体验" class="headerlink" title="2.2 用户体验"></a>2.2 用户体验</h3><ul>
<li>加载时间  各阶段加载时间</li>
<li>TTFB</li>
<li>FP</li>
<li>FCP</li>
<li>FMP</li>
<li>FID</li>
<li>卡顿  超过50ms的长任务</li>
</ul>
<h3 id="2-3-业务"><a href="#2-3-业务" class="headerlink" title="2.3 业务"></a>2.3 业务</h3><ul>
<li>PV</li>
<li>UV</li>
<li>TP</li>
</ul>
<h2 id="3-前端监控流程"><a href="#3-前端监控流程" class="headerlink" title="3. 前端监控流程"></a>3. 前端监控流程</h2><p>埋点 ==&gt; 数据采集  ==&gt; 数据建模存储  ==&gt; 数据传输（实时/批量） ==&gt; 数据统计（分析/挖掘）==&gt; 数据可视化或者预警</p>
<h3 id="3-1-常见埋点方案"><a href="#3-1-常见埋点方案" class="headerlink" title="3.1 常见埋点方案"></a>3.1 常见埋点方案</h3><h4 id="3-1-1-代码埋点"><a href="#3-1-1-代码埋点" class="headerlink" title="3.1.1 代码埋点"></a>3.1.1 代码埋点</h4><ul>
<li>嵌入代码的形式进行代码埋点，比如点击事件时保存用户行为发送至服务端</li>
<li>优点是可以任意时刻精准发送或保存数据</li>
<li>缺点是工作量较大</li>
</ul>
<h4 id="3-1-2-可视化埋点"><a href="#3-1-2-可视化埋点" class="headerlink" title="3.1.2 可视化埋点"></a>3.1.2 可视化埋点</h4><ul>
<li>不需要开发人员参与，一般是通过三方实现，实质时使用系统代替人工代码埋点</li>
</ul>
<h4 id="3-1-3-无痕埋点"><a href="#3-1-3-无痕埋点" class="headerlink" title="3.1.3 无痕埋点"></a>3.1.3 无痕埋点</h4><ul>
<li>前端任意一个事件都被绑定一个标识，所有的事件都记录下来</li>
<li>通过定期上传文件，配合文件解析，解析出我们想要的数据，并生成可视化报告</li>
<li>优点是采集全面，不会出现漏埋和误埋现象</li>
<li>缺点是给数据传输和服务器增加压力，也无法灵活定制数据结构</li>
</ul>
<h2 id="4-脚本编写"><a href="#4-脚本编写" class="headerlink" title="4. 脚本编写"></a>4. 脚本编写</h2><h3 id="4-1-开通日志服务"><a href="#4-1-开通日志服务" class="headerlink" title="4.1 开通日志服务"></a>4.1 开通日志服务</h3><p><a href="https://help.aliyun.com/document_detail/31752.htm?spm=a2c4g.11186623.2.24.19542e93WSQKIL#t13028.html">https://help.aliyun.com/document_detail/31752.htm?spm=a2c4g.11186623.2.24.19542e93WSQKIL#t13028.html</a></p>
<h3 id="4-2-监控错误"><a href="#4-2-监控错误" class="headerlink" title="4.2 监控错误"></a>4.2 监控错误</h3><blockquote>
<p>参考：<a href="https://cloud.tencent.com/developer/article/1650831">https://cloud.tencent.com/developer/article/1650831</a></p>
</blockquote>
<ul>
<li>jsError</li>
<li>promiseError</li>
<li>resourceError</li>
</ul>
<h3 id="4-3-接口异常采集脚本"><a href="#4-3-接口异常采集脚本" class="headerlink" title="4.3 接口异常采集脚本"></a>4.3 接口异常采集脚本</h3><h3 id="4-4-白屏"><a href="#4-4-白屏" class="headerlink" title="4.4 白屏"></a>4.4 白屏</h3><h3 id="4-5-加载时间"><a href="#4-5-加载时间" class="headerlink" title="4.5 加载时间"></a>4.5 加载时间</h3><h3 id="4-6-性能指标"><a href="#4-6-性能指标" class="headerlink" title="4.6 性能指标"></a>4.6 性能指标</h3>]]></content>
      <tags>
        <tag>前端监控</tag>
      </tags>
  </entry>
  <entry>
    <title>以用户为中心的性能指标</title>
    <url>/bloger/2021/05/04/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BB%A5%E7%94%A8%E6%88%B7%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<p>我们都听说过性能如何重要如何重要，但当我们讨论性能——可能就是让网站“快”，那么具体是什么意思呢？ 事实上，性能是一个相对的概念：</p>
<ul>
<li>一个网站可能对某一个用户来说很快(在一个功能强大并且网络优质的设备上的时候)，但是对另一个用户来说就很慢(在一个网速很慢的低端设备上的时候)。</li>
<li>两个网站同时加载完成可能总耗时相同，但是有一个可能会加载地更快(如果这个网站渐进式加载而不是等到最后才展示页面)</li>
<li>一个网站可能看起来加载的很快，但是对用户交互却响应的很慢(甚至不响应)</li>
</ul>
<p>所以当谈到性能，精确化和可以使用量化的客观标准计算是非常重要的。这些标准我们称之为指标。</p>
<p>但是仅仅因为指标是基于客观标准并且可以被量化，那也并不意味着这些计算是有用的。</p>
<h2 id="指标定义"><a href="#指标定义" class="headerlink" title="指标定义"></a>指标定义</h2><p>传统上，web 性能是通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event">加载事件</a>来计算的。但是，即使<code>加载事件</code>是一个页面生命周期中定义的一个精准的时刻，这个时刻也并不与用户关心的任何东西相对应。</p>
<p>比如，一个服务器可能发送了一个最小化的页面立刻就加载了，但是推迟拉取内容和展示内容，直到数秒后<code>负载事件</code>发起。虽然这个页面可能加载的很快，但是这个很快并不对应一个用户感觉这个页面很快。</p>
<p>过去数年里，Chrome 团队成员和<a href="https://www.w3.org/webperf/">W3C Web Performance Working Group</a>一直齐心努力标准化一些可以更精确计算用户如何感知网页性能的 API 和指标。</p>
<p>为了确保这些指标是用户相关的，我们围绕一些关键性问题展开：</p>
<table>
<thead>
<tr>
<th>关键性问题</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>是否发生</td>
<td>导航成功启动了吗？服务器响应了吗？</td>
</tr>
<tr>
<td>是否有用</td>
<td>是否内容都渲染完毕了？</td>
</tr>
<tr>
<td>是否可用</td>
<td>用户可可以与页面交互了吗，还是页面很忙？</td>
</tr>
<tr>
<td>是否优雅</td>
<td>交互是否顺畅自然，没有滞后和停顿？</td>
</tr>
</tbody></table>
<h2 id="指标如何计算"><a href="#指标如何计算" class="headerlink" title="指标如何计算"></a>指标如何计算</h2><p>性能指标一般有以下两种方式可以计算：</p>
<ul>
<li><strong>实验环境：</strong>使用工具模拟页面在一个相同的受控环境下加载</li>
<li><strong>真实环境：</strong>通过实际加载页面和与之交互的用户计算</li>
</ul>
<p>这些方法并没有一个确定的孰优孰劣的关系。实际上，你通常会同时使用两种方法以确保更好的性能</p>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>当开发新功能的时候，开发环境下测试性能是非常重要的。在生产环境下新功能发布之前，通过真实用户测试性能特征是不可能的，所以在产品发布之前，开发环境测试以免性能降低是最好的方法。</p>
<h2 id="真实环境"><a href="#真实环境" class="headerlink" title="真实环境"></a>真实环境</h2><p>另一方面，虽然在开发环境下测试是测试性能的一种合理替代，但是这也并不一定反映了所有用户在你的网站上的体验。</p>
<p>用户设备的不同和用户网络质量好的好坏都会使得不同用户对应的网页性能差距很大。当然这还基于用户是否与页面交互或者如何与页面进行交互。</p>
<p>此外，加载的网页不一定是确定的。比如，一些加载个性化内容或者广告的网站的性能可能会因人而异。而开发环境并不能捕捉到这些不同。</p>
<h2 id="指标类型"><a href="#指标类型" class="headerlink" title="指标类型"></a>指标类型</h2><p>还有一些其他类型的指标和用户看待性能有关</p>
<ul>
<li><strong>感知加载速度：</strong> 页面加载并渲染所有可见元素到屏幕上的速度</li>
<li><strong>加载响应度：</strong> 页面加载和执行<code>JavaScript</code>代码生成用来交互的组件的速度</li>
<li><strong>运行时响应度：</strong> 页面加载完毕后，页面可以响应网页交互的速度</li>
<li><strong>视觉稳定性：</strong> 网页元素是否不如用户期待那样移动了并且还潜在的干扰了用户的交互</li>
</ul>
<p>鉴于以上所有类型的性能指标，我们可以清楚地意识到：没有一个单独的指标可以非常有效的捕捉到一个页面的所有性能特征。</p>
<h2 id="重要的指标"><a href="#重要的指标" class="headerlink" title="重要的指标"></a>重要的指标</h2><ul>
<li><a href="https://web.dev/fcp/">First Contentful Paint(FCP)</a>：页面丛开始加载到任一元素渲染到屏幕上的时间。</li>
<li><a href="https://web.dev/lcp/">Largest Contentful Paint(LCP)</a>：页面丛开始加载到最多的元素渲染到屏幕上的时间。</li>
<li><a href="https://web.dev/fid/">First Input Delay(FID)</a>：用户首次与页面交互(比如当点击链接或者一个按钮或者使用一个自定义的<code>JavaScript</code>驱动)到浏览器实际响应的时间。</li>
<li><a href="https://web.dev/tti/">Time to Interactive(TTI)</a>：页面从加载到进行视觉渲染并可能可靠响应用户输入的页面的时间。</li>
<li><a href="https://web.dev/tbt/">Total Blocking Time(TBT)</a>：页面丛开始加载到任一元素渲染到屏幕上的时间。</li>
</ul>
<h2 id="自定义指标"><a href="#自定义指标" class="headerlink" title="自定义指标"></a>自定义指标</h2>]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>Web性能</tag>
        <tag>性能指标</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化----网络篇</title>
    <url>/bloger/2021/04/01/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96----%E7%BD%91%E7%BB%9C%E7%AF%87/</url>
    <content><![CDATA[<h1 id="前端性能优化—-网络篇"><a href="#前端性能优化—-网络篇" class="headerlink" title="前端性能优化—-网络篇"></a>前端性能优化—-网络篇</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS 过程：浏览器(cache) ==&gt; 操作系统(hosts) ==&gt; ISP</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><code>SYN</code>： 同步信号， <code>ACK</code>： 知道， <code>FIN</code>: 说完了</p>
<p>Round1: <code>A</code>发送<code>SYN(x)</code>给<code>B</code></p>
<p>Round2: <code>B</code>发送<code>ACK(x+1)</code>和<code>SYN(Y)</code>给<code>A</code></p>
<p>Round3: <code>A</code>发送<code>ACK(y+1)</code>给<code>B</code></p>
<p>第三次握手的必要性：前两次结束说明<code>A</code>能发，<code>B</code>能收，<code>B</code>能发，需要最后<code>A</code>发送<code>ACK(y+1)</code>这样<code>B</code>才能知道<code>A</code>能收</p>
<p>三次握手成功之后就可以发送<code>HTTP</code>内容了</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>也可能<code>B</code>先发<code>FIN(x)</code>给<code>A</code></p>
<p>Round1: <code>A</code>发送<code>FIN(x)</code>给<code>B</code></p>
<p>Round2: <code>B</code>发送<code>ACK(x+1)</code>给<code>A</code></p>
<p>这两次挥手结束<code>B</code>就知道了<code>A</code>说完了</p>
<p><code>Round3</code>之前<code>B</code>还有可能会继续说话，因为<code>B</code>知道<code>A</code>说完了，但是<code>B</code>可能还没有说完</p>
<p>Round3: <code>B</code>发送<code>FIN(y)</code>给<code>A</code></p>
<p>Round4: <code>A</code>发送<code>ACK(y+1)</code>给<code>B</code></p>
<p><code>Round4</code>之后<code>A</code>也知道<code>B</code>说完了</p>
<p>为什么四次挥手中间两次不能合并？ 因为<code>Round2</code>和<code>Round3</code>之间<code>B</code>还可能有话要说</p>
<h3 id="HTTP-请求和响应"><a href="#HTTP-请求和响应" class="headerlink" title="HTTP 请求和响应"></a>HTTP 请求和响应</h3><p>可以使用<code>WireShark</code>抓包查看请求</p>
<h3 id="浏览器基本原理"><a href="#浏览器基本原理" class="headerlink" title="浏览器基本原理"></a>浏览器基本原理</h3><ol>
<li><code>JS</code>的下载和执行会阻塞<code>HTML</code>的解析</li>
</ol>
<ul>
<li><p><code>JS</code>的下载会阻塞<code>HTML</code>的解析， 因为<code>JS</code>是一行一行解析的，解析到<code>&lt;script&gt;</code>标签就必须等到<code>JS</code>下载完毕</p>
</li>
<li><p><code>JS</code>的执行会阻塞<code>HTML</code>的解析， 因为<code>JS</code>可能会改变<code>DOM</code>的结构（使用诸如 <code>document.write(&lt;p&gt;你好&lt;/p&gt;)</code>等<code>API</code>）</p>
</li>
</ul>
<ol start="2">
<li><code>async</code>和<code>defer</code>的区别</li>
</ol>
<ul>
<li><p><code>defer</code>下载<code>JS</code>不会影响<code>HTML</code>解析，并且保证<code>JS</code>执行在<code>HTML</code>解析之后，<code>DOM ready</code>之前</p>
</li>
<li><p>多个<code>defer</code>执行顺序按照代码书写顺序来</p>
</li>
<li><p><code>async</code>下载<code>JS</code>完全和<code>HTML</code>解析没关系，执行顺序在<code>DOM ready</code>之前还是之后是不确定的</p>
</li>
<li><p>多个<code>async</code>执行顺序也是不确定的</p>
</li>
</ul>
<ol start="3">
<li><code>CSS</code>的解析会阻塞<code>JS</code>的执行</li>
</ol>
<ul>
<li><p><code>CSS</code>的解析会不影响<code>JS</code>的下载</p>
</li>
<li><p><code>JS</code>的执行需要读取<code>CSS</code>解析结果，所以得等到<code>CSS</code>的解析完毕才能执行<code>JS</code></p>
</li>
<li><p><code>JS</code>执行前要确保<code>CSS</code>的下载和解析都完毕</p>
</li>
</ul>
<ol start="4">
<li>布局、绘制、合成(Layout, Paint, Composite)</li>
</ol>
<ul>
<li><p>布局解决大小尺寸等问题(位置)</p>
</li>
<li><p>绘制解决颜色阴影问题(外观)</p>
</li>
<li><p>合成解决层次问题(图层)</p>
</li>
<li><p>更新阶段：Layout ==&gt; reflow Paint ==&gt; repaint</p>
</li>
<li><p>那些属性操作会触发<code>reflow</code>和<code>repaint</code> 可以查看<a href="https://csstriggers.com/">CSS Triggers</a></p>
</li>
</ul>
<h3 id="Chrome-浏览器工具"><a href="#Chrome-浏览器工具" class="headerlink" title="Chrome 浏览器工具"></a>Chrome 浏览器工具</h3><ul>
<li><p><code>Network</code>面板：查看页面时间线</p>
</li>
<li><p><code>Performance</code>面板：查看<code>JS</code>性能</p>
</li>
<li><p><code>Rendering</code>面板：查看页面渲染</p>
</li>
<li><p><code>Coverage</code>面板：查看代码使用率</p>
</li>
<li><p><code>Lighthouse</code>面板：查看优化建议</p>
</li>
</ul>
<p><code>Network</code>面板单个请求<code>Waterfall</code>的<code>Waiting(TTFB)</code>时间很长就和浏览器没什么关系，要么是服务器太慢，要么是用户带宽不够</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul>
<li><code>Web</code><br>性能指标，<a href="https://matthrews.github.io/bloger/2021/05/04/%E4%BB%A5%E7%94%A8%E6%88%B7%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/">参考</a></li>
</ul>
<h3 id="连接的复用与并行化"><a href="#连接的复用与并行化" class="headerlink" title="连接的复用与并行化"></a>连接的复用与并行化</h3><ul>
<li><code>DNS prefetch</code></li>
</ul>
<p>假设<code>index.html</code>的部分代码为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://a.com/1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://b.com/2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述情况，浏览器会按顺序做如下事情:</p>
<ol>
<li><p><code>DNS</code>解析<code>a.com</code></p>
</li>
<li><p>下载并执行<code>1.js</code></p>
</li>
<li><p><code>DNS</code>解析<code>b.com</code></p>
</li>
<li><p>下载并执行<code>2.js</code></p>
</li>
</ol>
<p>使用<code>prefetch</code>可以将<code>步骤1和步骤2</code>合并</p>
<p>使用<code>prefetch</code>修改如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在index.html的head里写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://a.com/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://b.com/&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在index.html的响应头里写 --&gt;</span></span><br><span class="line"></span><br><span class="line">Link:</span><br><span class="line">&lt;http://a.com/&gt;; rel=dns-prefetch Link:</span><br><span class="line">&lt;http://b.com/&gt;; rel=dns-prefetch</span><br></pre></td></tr></table></figure>

<ul>
<li><code>TCP</code>连接复用</li>
</ul>
<p><code>HTTP</code>请求头加<code>Connection: keep-alive</code>，响应头会返回相同字段内容</p>
<p><code>HTTP</code>请求头加<code>KeepAlive: timeout=5, max=100</code> 表示如果你<code>5s</code>还不发起请求我就关闭<code>TCP</code>连接，并且最多服用<code>100</code>次，再来我就关闭<code>TCP</code>连接，重新<code>TCP</code><br>流程，，响应头可能会返回不同字段内容，此时要以服务器返回为准</p>
<p><code>HTTP/1.1</code>不需要自动有的</p>
<ul>
<li>并行化连接</li>
</ul>
<p>和<code>TCP</code>连接复用类似，<code>TCP</code>连接复用是串行的，而并行化连接是并行的</p>
<p>并行连接个数会受到浏览器限制，不同浏览器上线不同,<code>Chrome</code>最新浏览器允许同时并行<code>6</code>个请求</p>
<p>此时还可以通过将<code>12</code>个资源分别放在两个域名下同时请求，将会一次请求得到<code>12</code>个结果，浏览器并没有限制不同域名的个数</p>
<p>复用和并行是不冲突的</p>
<ul>
<li><code>HTTP</code>管道化</li>
</ul>
<h3 id="HTTP-2的多路复用与ServerPush"><a href="#HTTP-2的多路复用与ServerPush" class="headerlink" title="HTTP/2的多路复用与ServerPush"></a><code>HTTP/2</code>的多路复用与<code>ServerPush</code></h3><ul>
<li><p><code>HTTP/1.1</code>是基于字符串的，<code>HTPP/2</code>是基于帧<code>Frame(二进制)</code>的</p>
</li>
<li><p>帧<code>Frame</code>由<code>9</code>个固定字节(Lenght+Type+Flags+StreamID)加上最大<code>16M</code>字节的<code>数据payload</code>构成的</p>
</li>
<li><p>请求头和响应头会被发送方进行压缩，分成几个连续的帧传输</p>
</li>
<li><p><code>HTTP/2</code>的多路复用中的路实际是流的概念，通过流承载的是帧</p>
</li>
<li><p><code>HTTP/2</code>的多路复用中的每条路上只能有一次请求和响应，每条路互不影响，响应和请求通过<code>StreamID</code>一一对应</p>
</li>
<li><p>流也是可以复用的，但是多路是更广阔的范畴，相当于以前在一条路上进行并行或者复用，现在直接多了很多条路</p>
</li>
<li><p>案例分析 <a href="https://www.qq.com/">https://www.qq.com/</a></p>
</li>
</ul>
<h3 id="服务端推送ServerPush"><a href="#服务端推送ServerPush" class="headerlink" title="服务端推送ServerPush"></a>服务端推送<code>ServerPush</code></h3><p>需要<code>后端</code>配置，比如<code>nginx</code>配置的<code>location</code>配置<code>http2_push</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root /usr/share/nginx/html</span><br><span class="line">    index index.html index.html</span><br><span class="line">    http2_push /style.css</span><br><span class="line">    http2_push /logo.png</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">location / &#123;</span><br><span class="line">    root /usr/share/nginx/html</span><br><span class="line">    index index.html index.html</span><br><span class="line">    http2_push_preload on</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然会在index.html文件的响应头加</span></span><br><span class="line">Link: &lt;/style.css&gt;; rel=preload; as=style</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Cookie-Free-amp-CDN"><a href="#Cookie-Free-amp-CDN" class="headerlink" title="Cookie Free &amp; CDN"></a>Cookie Free &amp; CDN</h3><ul>
<li><p>资源合并：CSS Sprites、Icon Font、SVG Symbols</p>
<p><code>Webpack</code>提供有<code>CSS Sprites</code>工具</p>
</li>
<li><p>资源内联：Inline Resource</p>
<p>小图片通过<code>data URL</code>内联</p>
<p>小<code>CSS</code>文件嵌入<code>&lt;style&gt;</code>标签</p>
<p>小<code>JS</code>文件<code>&lt;script&gt;</code>标签</p>
<p><code>Webpack</code>提供有<code>url-loader</code>, <code>html-webpack-plugin</code>等工具</p>
</li>
<li><p>资源压缩：<code>gzip、nginx</code></p>
<p>Nginx, Apache, NodeJS</p>
<p><a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html">Nginx</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip            on;</span><br><span class="line">gzip_min_length 1000;</span><br><span class="line">gzip_proxied    expired no-cache no-store private auth;</span><br><span class="line">gzip_types      text/plain application/xml;</span><br></pre></td></tr></table></figure>

<p><a href="https://ubiq.co/tech-blog/enable-gzip-compression-apache/">Apache</a></p>
<p><a href="https://nodejs.org/api/zlib.html">NodeJS</a></p>
</li>
<li><p>代码精简</p>
<p>HTML ==&gt; 删空格,删闭合</p>
<p>CSS ==&gt; 删未用</p>
<p>JSS ==&gt; 改名，tree shaking</p>
<p>SVG ==&gt; 删无用标签属性</p>
<p>Image ==&gt; 减小体积(有损/无损)</p>
<p>使用<code>Webpack</code>相关插件都可以实现</p>
</li>
<li><p>减小<code>Cookie</code>体积</p>
<p><code>Cookie</code>体积上限：4Kb</p>
<p>如何实现<code>cookie-free</code>? 尽量不要用<code>cookie</code>, 启用新域名</p>
</li>
<li><p>CDN 的原理和实施</p>
<p><code>CDN</code>: 内容分发网络，从物理意义上缩短距离，加快速度</p>
<p><code>DNS</code>负载均衡: <code>DNS</code>解析域名的时候会返回不同的<code>IP</code></p>
<p>如何将文件发送到<code>CDN</code>? 使用命令行将文件上传到<code>CDN</code>服务器</p>
<p>优点：</p>
<ul>
<li><p>cookie-free</p>
</li>
<li><p>并行请求/多路复用</p>
</li>
<li><p>下载速度快(只处理静态文件)</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>付费</p>
</li>
<li><p>部署复杂</p>
</li>
<li><p>可控性差</p>
</li>
<li><p>跨域 CORS</p>
</li>
</ul>
</li>
</ul>
<p>CDN 会出现什么样的跨域问题？</p>
<ul>
<li><p><code>Canvas</code>虽然可以加载跨域图片，但是在调用 <code>getImageData()</code>, <code>toBlob()</code>, <code>toDataURL()</code>时会产生报错，解决办法是启<code>CORS</code>头，并给图片添加<code>crossorigin=anonymous</code><br>属性。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/CORS_enabled_image">详见 MDN</a></p>
</li>
<li><p><code>window.addEventListener(&#39;error&#39;, ...)</code>无法捕获跨域<code>JS</code>的错误详情。解决办法有两个，一个是启用<code>CORS</code>头并给<code>script</code>标签添加<code>crossorigin=anonymous</code><br>属性，另一个比较开脑洞，是重写<code>addEventListener</code>，<a href="https://juejin.cn/post/6844903727820718094">详见《解决 “Script Error” 的另类思路》</a></p>
</li>
</ul>
<p><code>gzip</code>和<code>gzip_static</code>有什么区别？</p>
<ul>
<li><p><code>Nginx</code>实际上提供了两种 <code>gzip</code> 模式<code>gzip on;</code>和<code>gzip_static on;</code></p>
</li>
<li><p>前者会在每次请求时压缩文件，有一点浪费 <code>CPU</code><br>而后者会在遇到<code>/path/to/file</code>请求时，主动寻找<code>/path/to/file.gz</code>作为压缩版本，找不到就直接返回未压缩的版本</p>
</li>
</ul>
<h3 id="缓存和内容协商"><a href="#缓存和内容协商" class="headerlink" title="缓存和内容协商"></a>缓存和内容协商</h3><ul>
<li><p>Cache-Control</p>
<p><code>HTTP</code>响应可以要求浏览器将文件缓存一段时间，具体写法为：<code>Cache-Control: public, max-age=3600, must-revalidate</code></p>
<p>其中<code>max-age: 3600</code>表示最长缓存时间为<code>3600</code>秒，<code>public</code>表示网络中的中间设备（如代理）也可以缓存此内容，<code>must-revalidate</code>表示缓存过期后不能再使用，必须重新校验(重新校验过程也叫内容协商)。<br>在未来的<code>3600</code>秒内，浏览器对于相同<code>URL</code>的请求，一律不发出，且直接使用缓存作为其响应</p>
</li>
<li><p>内容协商</p>
<p>主要是协商过期之后能重用吗？</p>
<p>内容协商过程如下：</p>
<ol>
<li>浏览器第一次访问资源时，服务器除了添加缓存之外，还会计算出资源的哈希值，附加在响应头里，写法为<code>ETag: W/&quot;7f9239ce726764aa22093884902e018d&quot;</code>(<code>ETag</code>是实体标签)</li>
<li>在有效期内，浏览器不会再对相同的URL发出请求</li>
<li>等待有效期结束后，浏览器再次请求同一资源，但是会在请求头附上: <code>If-None-Match: W/&quot;7f9239ce726764aa22093884902e018d&quot;</code></li>
<li>服务器收到请求后，发现同一资源的哈希值和浏览器附带的哈希值一样，说明资源没变，就会返回<code>304(Not Modified)</code></li>
<li>如果发现资源哈希值不同，说明文件发生了变化，就会返回<code>200</code>，并将最新文件内容返回</li>
</ol>
</li>
<li><p>新旧两套方案</p>
<table>
<thead>
<tr>
<th>http版本</th>
<th>缓存</th>
<th>内容协商</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP 1.1</td>
<td>Cache-Control:  public, max-age=3600, must-revalidate <br />   ETag: W/“7f9239ce726764aa22093884902e018d”</td>
<td>请求头：If-None-Match: W/“7f9239ce726764aa22093884902e018d”  <br /> 响应： 304+空/200+新内容</td>
</tr>
<tr>
<td>HTTP 1.0</td>
<td>Expire: 用户PC时间点A <br /> Last-Modified: 服务器文件修改时间点B</td>
<td>请求头：If-Modified-Since: 服务器文件修改时间点B  <br /> 响应： 304+空/200+新内容</td>
</tr>
</tbody></table>
<p><code>HTTP 1.0</code>的<code>Expire</code>是用户<code>PC</code>时间，有可能是错的，<code>Last-Modified</code>是服务器文件修改时间点，精确到秒，所以如果<code>1s</code>之内文件被修改N次，服务器是识别不出来变化的</p>
</li>
<li><p>服务器禁用缓存</p>
<p>不加<code>Cache-Control</code>，浏览器也出缓存静态资源，比如<code>GET</code>请求，或者你的状态码为<code>200, 203, 206, 300, 301, 400等</code><br>手动禁用缓存：<code>Cache-Control: max-age=0, must-revalidate</code> 或者 <code>Cache-Control: no-cache</code><br><code>Cache-Control: no-cache</code>意思时不缓存可以协商，<code>Cache-Control: no-store</code>意思是不缓存不协商</p>
</li>
<li><p>浏览器禁用缓存</p>
<p>请求地址上加随机数<br>请求头加<code>Cache-Control: no-cache, no-store, max-age=0</code></p>
</li>
<li><p><code>Pragma</code> 是什么</p>
<p>它用来向后兼容只支持 <code>HTTP/1.0</code> 协议的缓存服务器，那时候 <code>HTTP/1.1</code> 协议中的 <code>Cache-Control</code> 还没有出来<br>请求头为：<code>Pragma: no-cache</code>, 其行为与 <code>Cache-Control: no-cache</code> 一致</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>优化工具</p>
<p>Network, Performance, Rendering, FPS, Coverage</p>
</li>
<li><p>DNS</p>
<p>Prefetch</p>
</li>
<li><p>TCP</p>
<p>连接复用，并行，管道，多路复用，服务端推送</p>
</li>
<li><p>HTTP</p>
<p>合并，内联，压缩，精简(Tree Shaking)，Cookie Free, CDN, 缓存，内容协商</p>
</li>
<li><p>代码优化</p>
<p>CSS在先，JS在后，代码拆分，动态导入，懒加载，预加载，CSS优化，JS优化</p>
</li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>Web性能</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化----雅虎35条军规</title>
    <url>/bloger/2021/02/05/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96----%E9%9B%85%E8%99%8E35%E6%9D%A1%E5%86%9B%E8%A7%84/</url>
    <content><![CDATA[<h4 id="前端性能优化—-雅虎-35-条军规"><a href="#前端性能优化—-雅虎-35-条军规" class="headerlink" title="前端性能优化—-雅虎 35 条军规"></a>前端性能优化—-雅虎 35 条军规</h4><ol>
<li><p>减少 HTTP 请求</p>
<p>80%的终端响应时间主要花费在前端，而这部分时间主要在下载网页中的图片，样式文件，脚本文件，flash 等资源。减少这些资源的数量就相应地减少了用于渲染页面的 HTT 请求数量。以下是一些具体的方法</p>
</li>
</ol>
<ul>
<li><p>简化设计</p>
</li>
<li><p>打包文件，将多个 JS 文件打包成一个 JS 文件，同样地，将多个 CSS 文件打包成一个 CSS 文件</p>
</li>
<li><p>使用 CSS Sprites，将页面中用到的背景小图标并合成一张图片，再使用 CSS 中的<code>bakground-image</code>和<code>background-position</code>来显示所需图像部分</p>
</li>
<li><p>图像映射，html 标签<map>，可以创建可点击的图像区域，具体参考<code>w3school</code>或者 W3C 文档</p>
</li>
<li><p>内嵌图片，通过<code>data:URL scheme</code>内嵌</p>
</li>
</ul>
<ol start="2">
<li><p>使用 CDN</p>
<p>在现有的网络中增加一层新的网络架构，将网站的内容发布到最接近用户的 Cache 服务器内，通过 DNS 负责均衡技术，判断用户来源就近访问 Cache 服务器上所需的内容。如此便可以减少数据在网络上传输的时间，提高速度</p>
</li>
<li><p>设置头文件过期时间或者缓存策略</p>
<ul>
<li>静态内容：将 Expires 响应头设置为将来很远的时间，实现「永不过期」策略；</li>
<li>动态内容：设置合适的 Cache-Control 响应头，让浏览器有条件地发起请求。</li>
</ul>
</li>
<li><p><code>Gzip</code>压缩</p>
<ul>
<li><p><code>Gzip</code>压缩通常可以减少 70%的响应大小，对某些文件更可能高达 90%，比<code>Deflate</code>更高效</p>
</li>
<li><p>主流 Web 服务器都有相应模块，而且绝大多数浏览器支持<code>gzip</code>解码</p>
</li>
<li><p>图片和 PDF 文件不要使用 <code>gzip</code>，它们本身已经压缩过，再使用<code>gzip</code> 压缩不仅浪费 CPU 资源，而且还可能增加文件体积</p>
</li>
<li><p>从 HTTP/1.1 开始，web 客户端就有了支持压缩的 Accept-Encoding HTTP 请求头</p>
</li>
</ul>
</li>
<li><p>把 CSS 文件放在顶部</p>
<p>把样式表放在<code>&lt;head&gt;</code>中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉。</p>
</li>
<li><p>把 JS 文件放在底部</p>
<ul>
<li><p>浏览器下载脚本时，会阻塞其他资源并行下载，即使是来自不同域名的资源。因此，最好将脚本放在底部，以提高页面加载速度。</p>
</li>
<li><p>一些特殊场景无法将脚本放到页面底部的，可以考虑<code>&lt;script&gt;</code>的以下属性：</p>
</li>
<li><p>defer 属性；</p>
</li>
<li><p>HTML5 新增的<code>async</code>属性。</p>
</li>
</ul>
</li>
<li><p>避免 CSS 表达式</p>
<p>CSS 表达式可以在 CSS 里执行 JavaScript，仅 IE5-IE7 支持，IE8 标准模式已经废弃。 CSS 表达式超出预期的频繁执行，页面滚动、鼠标移动时都会不断执行，带来很大的性能损耗。</p>
</li>
<li><p>将 JS 和 CSS 外链</p>
<p>外部 JavaScript 和 CSS 文件可以被浏览器缓存，在不同页面间重用，也能降低页面大小。</p>
</li>
<li><p>减少 DNS 查询</p>
<ul>
<li>用户输入 URL 以后，浏览器首先要查询域名（hostname）对应服务器的 IP 地址，一般需要耗费 20-120 毫秒时间。DNS 查询完成之前，浏览器无法从服务器下载任何数据。</li>
<li>基于性能考虑，ISP、局域网、操作系统、浏览器都会有相应的 DNS 缓存机制。 IE 缓存 30 分钟，可以通过注册表中 DnsCacheTimeout 项设置；<br>Firefox 缓存 1 分钟，通过 network.dnsCacheExpiration 配置；</li>
</ul>
</li>
<li><p>减小 JSS 和 CSS 体积</p>
<ul>
<li><p>压缩代码可以移除非功能性的字符（注释、空格、空行等），减少文件大小，提高载入速度</p>
</li>
<li><p>开源社区有很多前端优化工具，比如：<a href="https://cssnano.co/">cssnano</a> , <a href="https://www.crockford.com/jsmin.html">JSMin</a><br>, <a href="https://skalman.github.io/UglifyJS-online/">UglifyJS</a></p>
</li>
<li><p><a href="https://gulpjs.com/">Gulp</a>, <a href="https://webpack.js.org/">Webpack</a>等流行构建工具都有相应的支持</p>
</li>
</ul>
</li>
<li><p>避免重定向</p>
<ul>
<li>客户端收到服务器的重定向响应后，会根据响应头中 Location 的地址再次发送请求。重定向会影响用户体验，尤其是多次重定向时，用户在一段时间内看不到任何内容，只看到浏览器进度条一直在刷新。</li>
<li>最浪费的重定向经常发生、而且很容易被忽略：URL 末尾应该添加<code>/</code><br>但未添加。比如，访问<code>http://astrology.yahoo.com/astrology</code>将被<code>301</code>重定向到 <code>http://astrology.yahoo.com/astrology/</code>（注意末尾的 /）。如果使用<br>Apache，可以通过<code>Alias</code>或<code>mod_rewrite</code>或<code>DirectorySlash</code>解决这个问题。</li>
<li>网站域名变更：<code>CNAME</code>结合<code>Alias</code>或<code>mod_rewrite</code>或者其他服务器类似功能实现跳转。</li>
</ul>
</li>
<li><p>移除重复脚本</p>
<p>重复的脚本不仅产生不必要的 HTTP 请求，而且重复解析执行浪费时间和计算资源。</p>
</li>
<li><p>配置<code>ETags</code></p>
<p><code>ETags</code>通过文件版本标识，方便服务器判断请求的内容是否有更新，如果没有就响应 304，避免重新下载</p>
</li>
<li><p>缓存 Ajax</p>
<p>有尚未过期的 Expires 或者 Cache-Control HTTP 头，那么之前的资源就可以从缓存中读出。必须通知浏览器，应该继续使用之前缓存的资源响应，还是去请求一个新的。可以通过给资源的 Ajax<br>URL 里添加一个表明用户资源最后修改时间的时间戳来实现。如果资源从上一次下载之后再没有被修改过，时间戳不变，资源就将从浏览器缓存中直接读出，从而避免一次额外的 HTTP 往返消耗。具体参考[3. 设置头文件过期时间或者缓存策略](#3.<br>设置头文件过期时间或者缓存策略)</p>
</li>
<li><p>尽早释放缓冲</p>
<p>用户请求页面时，服务器通常需要花费 200 ~ 500 毫秒来组合 HTML 页面。在此期间，浏览器处于空闲、等待数据状态。使用 PHP 中的 flush()函数，可以发送部分已经准备好的<br>HTML 到浏览器，以便服务器还在忙于处理剩余页面时，浏览器可以提前开始获取资源。</p>
</li>
<li><p>用 GET 方式进行 Ajax 请求</p>
<p>浏览器执行 POST 请求时分成两步，先发送 Http Header，再发送 data。而 GET 只使用一个 TCP 数据包（Http Header 与 data）发送数据，所以首选 GET 方法。</p>
<p>根据 HTTP 规范，GET 用于获取数据，POST 则用于向服务器发送数据，所以 Ajax 请求数据时使用 GET 更符合规范。</p>
</li>
<li><p>预加载组件</p>
<p>预先加载利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应</p>
</li>
<li><p>延迟加载组件</p>
<p>页面初始加载时哪些内容是绝对必需的？不在答案之列的资源都可以延迟加载。比如：</p>
<ul>
<li>非首屏使用的数据、样式、脚本、图片等</li>
<li>用户交互时才会显示的内容</li>
</ul>
</li>
<li><p>减少 DOM 元素数量</p>
<p>从以下几个角度考虑移除不必要的标记：</p>
<ul>
<li>是否还在使用表格布局？</li>
<li>塞进去更多的<div>仅为了处理布局问题？也许有更好、更语义化的标记。</li>
<li>能通过伪元素实现的功能，就没必要添加额外元素，如清除浮动。 浏览器控制台中输入以下代码可以计算出页面中有多少 DOM 元素：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;*&quot;</span>).length;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么不使用表格布局？<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+ 更多的标签，增加文件大小；</span><br><span class="line">+ 不易维护，无法适应响应式设计；</span><br><span class="line">+ 性能考量，默认的表格布局算法会产生大量重绘</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>跨域分离组件</p>
<p>浏览器一般会限制每个域的并行线程（一般为 6 个，甚至更少），使用不同的域名可以最大化下载线程，但注意保持在 2-4 个域名内，以避免 DNS 查询损耗。</p>
</li>
<li><p>减少<code>iframe</code>数量</p>
<ul>
<li>用<code>iframe</code>可以把一个 HTML 文档插入到父文档里，重要的是明白<code>iframe</code>是如何工作的并高效地使用它。</li>
<li><code>iframe</code>的优点：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+ 可以用来加载速度较慢的第三方资源，如广告、徽章；</span><br><span class="line">+ 可用作安全沙箱；</span><br><span class="line">+ 可以并行下载脚本。</span><br></pre></td></tr></table></figure></li>
<li><code>iframe</code>的缺点：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+ 加载代价昂贵，即使是空的页面；</span><br><span class="line">+ 阻塞页面 load 事件触发；</span><br><span class="line">+ <span class="string">`iframe`</span> 完全加载以后，父页面才会触发 load 事件。 Safari、Chrome 中通过 JavaScript 动态设置 iframe src 可以避免这个问题。</span><br><span class="line">+ 缺乏语义。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>不要出现 404 页面</p>
<p>HTTP 请求很昂贵，返回无效的响应（如 404 未找到）完全没必要，降低用户体验而且毫无益处</p>
</li>
<li><p>减小 Cookie</p>
<p>Cookie 被用于身份认证、个性化设置等诸多用途。Cookie 通过 HTTP 头在服务器和浏览器间来回传送，减少 Cookie 大小可以降低其对响应速度的影响。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">- 去除不必要的 Cookie；</span><br><span class="line">- 尽量压缩 Cookie 大小；</span><br><span class="line">- 注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；</span><br><span class="line">- 设置合适的过期时间。</span><br></pre></td></tr></table></figure></li>
<li><p>对静态资源使用无 Cookie 的域名</p>
<p>静态资源一般无需使用 Cookie，可以把它们放在使用二级域名或者专门域名的无 Cookie 服务器上，降低 Cookie 传送的造成的流量浪费，提高响应速度。</p>
</li>
<li><p>较少 DOM 访问次数</p>
<ul>
<li><p>JavaScript 操作操作 DOM 很慢，尤其是 DOM 节点很多时。</p>
</li>
<li><p>使用时应该注意：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">- 缓存已经访问过的元素；</span><br><span class="line">- 使用DocumentFragment暂存DOM，整理好以后再插入DOM树；</span><br><span class="line">- 操作className，而不是多次读写style；</span><br><span class="line">- 避免使用JavaScript修复布局。</span><br></pre></td></tr></table></figure></li>
<li><p>开发高效的事件处理句柄</p>
<ul>
<li>减少绑定事件监听的节点，如通过事件委托；</li>
<li>尽早处理事件，在 DOMContentLoaded 即可进行，不用等到 load 以后。</li>
</ul>
</li>
<li><p>使用<code>&lt;link&gt;</code>而非@import</p>
</li>
<li><p>避免使用过滤器</p>
<p>避免使用 AlphaImageLoader，可以使用 PNG8 替代</p>
</li>
<li><p>优化图片</p>
<ul>
<li><a href="https://github.com/imagemin/imagemin">imagemin</a></li>
<li><a href="https://imageoptim.com/mac">imageoptim</a></li>
<li><a href="https://www.queness.com/post/2507/most-effective-method-to-reduce-and-optimize-png-images">PNG 优化 1</a></li>
<li><a href="https://www.smashingmagazine.com/2009/07/clever-png-optimization-techniques/">PNG 优化 2</a></li>
<li><a href="https://blog.csdn.net/whh181/article/details/94449493">Webp 相关内容</a></li>
<li><a href="https://segmentfault.com/a/1190000038521158">SVG 相关内容</a></li>
<li><a href="https://pmt.sourceforge.io/pngcrush/">Pngcrush</a></li>
</ul>
</li>
<li><p>优化 CSS Sprites</p>
</li>
</ol>
<ul>
<li>水平排列<code>Sprite</code>中的图片，垂直排列会增加图片大小；</li>
<li><code>Sprite</code>中把颜色较近的组合在一起可以降低颜色数，理想状况是低于 256 色以适用 PNG8 格式；</li>
<li>不要在<code>Sprite</code>的图像中间留有较大空隙。减少空隙虽然不太影响文件大小，但可以降低用户代理把图片解压为像素图的内存消耗，对移动设备更友好。</li>
</ul>
<ol start="31">
<li><p>不要再 HTML 中伸缩图片</p>
<p>不要使用<img>的 width、height 缩放图片，如果用到小图片，就使用相应大小的图片</p>
</li>
<li><p>缩小<code>favicon.ico</code>的大小并使用缓存</p>
<p>Favicon.ico 一般存放在网站根目录下，无论是否在页面中设置，浏览器都会尝试请求这个文件。所以确保这个图标：</p>
<ul>
<li>存在（避免 404）；</li>
<li>尽量小，最好小于 1K；</li>
<li>设置较长的过期时间。</li>
<li>对于较新的浏览器，可以使用 PNG 格式的 favicon。</li>
</ul>
</li>
<li><p>保证组件在 25K 以下</p>
<p>这个限制是因为 iPhone 不能缓存大于 25K(压缩前)的组件</p>
</li>
<li><p>将组件打包进一个多部分的文档中</p>
</li>
</ol>
<p>把各个组件打包成一个像有附件的电子邮件一样的复合文档里，可以用一个 HTTP 请求获取多个组件（记住一点：HTTP 请求是代价高昂的）。用这种方式的时候，要先检查用户代理是否支持（iPhone 就不支持）</p>
<ol start="35">
<li><p>避免空的图像<code>src</code>属性</p>
<ul>
<li>虽然 src 属性为空字符串，但浏览器仍然会向服务器发起一个 HTTP 请求</li>
<li>空的 href 属性也存在类似问题</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>Web性能</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能监控</title>
    <url>/bloger/2021/06/05/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<h1 id="前端性能监控"><a href="#前端性能监控" class="headerlink" title="前端性能监控"></a>前端性能监控</h1><h2 id="1-为什么要做前端性能监控？"><a href="#1-为什么要做前端性能监控？" class="headerlink" title="1. 为什么要做前端性能监控？"></a>1. 为什么要做前端性能监控？</h2><ul>
<li>更快发现问题和解决问题</li>
<li>做产品的决策依据</li>
<li>提升前端工程师的技术广度和打造简历亮点</li>
<li>为业务扩展提供更多可能性</li>
</ul>
<h2 id="2-前端监控目标"><a href="#2-前端监控目标" class="headerlink" title="2. 前端监控目标"></a>2. 前端监控目标</h2><h3 id="2-1-稳定性"><a href="#2-1-稳定性" class="headerlink" title="2.1 稳定性"></a>2.1 稳定性</h3><ul>
<li>JS 错误 JS 执行错误或 Promise 异常</li>
<li>资源异常 script, link 等资源加载异常</li>
<li>接口错误 网络请求异常</li>
<li>白屏 页面空白</li>
</ul>
<h3 id="2-2-用户体验"><a href="#2-2-用户体验" class="headerlink" title="2.2 用户体验"></a>2.2 用户体验</h3><ul>
<li>加载时间 各阶段加载时间</li>
<li>TTFB</li>
<li>FP</li>
<li>FCP</li>
<li>FMP</li>
<li>FID</li>
<li>卡顿 超过 50ms 的长任务</li>
</ul>
<h3 id="2-3-业务"><a href="#2-3-业务" class="headerlink" title="2.3 业务"></a>2.3 业务</h3><ul>
<li>PV</li>
<li>UV</li>
<li>TP</li>
</ul>
<h2 id="3-前端监控流程"><a href="#3-前端监控流程" class="headerlink" title="3. 前端监控流程"></a>3. 前端监控流程</h2><p>埋点 ==&gt; 数据采集 ==&gt; 数据建模存储 ==&gt; 数据传输（实时/批量） ==&gt; 数据统计（分析/挖掘）==&gt; 数据可视化或者预警</p>
<h3 id="3-1-常见埋点方案"><a href="#3-1-常见埋点方案" class="headerlink" title="3.1 常见埋点方案"></a>3.1 常见埋点方案</h3><h4 id="3-1-1-代码埋点"><a href="#3-1-1-代码埋点" class="headerlink" title="3.1.1 代码埋点"></a>3.1.1 代码埋点</h4><ul>
<li>嵌入代码的形式进行代码埋点，比如点击事件时保存用户行为发送至服务端</li>
<li>优点是可以任意时刻精准发送或保存数据</li>
<li>缺点是工作量较大</li>
</ul>
<h4 id="3-1-2-可视化埋点"><a href="#3-1-2-可视化埋点" class="headerlink" title="3.1.2 可视化埋点"></a>3.1.2 可视化埋点</h4><ul>
<li>不需要开发人员参与，一般是通过三方实现，实质时使用系统代替人工代码埋点</li>
</ul>
<h4 id="3-1-3-无痕埋点"><a href="#3-1-3-无痕埋点" class="headerlink" title="3.1.3 无痕埋点"></a>3.1.3 无痕埋点</h4><ul>
<li>前端任意一个事件都被绑定一个标识，所有的事件都记录下来</li>
<li>通过定期上传文件，配合文件解析，解析出我们想要的数据，并生成可视化报告</li>
<li>优点是采集全面，不会出现漏埋和误埋现象</li>
<li>缺点是给数据传输和服务器增加压力，也无法灵活定制数据结构</li>
</ul>
<h2 id="4-脚本编写"><a href="#4-脚本编写" class="headerlink" title="4. 脚本编写"></a>4. 脚本编写</h2><h3 id="4-1-开通日志服务"><a href="#4-1-开通日志服务" class="headerlink" title="4.1 开通日志服务"></a>4.1 开通日志服务</h3><p>参考<a href="https://help.aliyun.com/document_detail/31752.htm?spm=a2c4g.11186623.2.24.19542e93WSQKIL#t13028.html">Web Tracking 文档</a></p>
<h3 id="4-2-监控错误"><a href="#4-2-监控错误" class="headerlink" title="4.2 监控错误"></a>4.2 监控错误</h3><ul>
<li>jsError</li>
<li>promiseError</li>
<li>resourceError</li>
</ul>
<h3 id="4-3-接口异常采集脚本"><a href="#4-3-接口异常采集脚本" class="headerlink" title="4.3 接口异常采集脚本"></a>4.3 接口异常采集脚本</h3><h3 id="4-4-白屏"><a href="#4-4-白屏" class="headerlink" title="4.4 白屏"></a>4.4 白屏</h3><h3 id="4-5-加载时间"><a href="#4-5-加载时间" class="headerlink" title="4.5 加载时间"></a>4.5 加载时间</h3><h3 id="4-6-性能指标"><a href="#4-6-性能指标" class="headerlink" title="4.6 性能指标"></a>4.6 性能指标</h3><blockquote>
<p>参考：<a href="https://cloud.tencent.com/developer/article/1650831">https://cloud.tencent.com/developer/article/1650831</a></p>
</blockquote>
<blockquote>
<p>源码参考：<a href="https://github.com/Matthrews/web-monitor">https://github.com/Matthrews/web-monitor</a></p>
</blockquote>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><ul>
<li><a href="https://www.fundebug.com/">一行代码搞定 BUG 监控！</a></li>
</ul>
]]></content>
      <categories>
        <category>前端性能监控</category>
      </categories>
      <tags>
        <tag>前端性能监控</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 相关基础题目</title>
    <url>/bloger/1970/01/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/ES6%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="ES6-相关基础题目"><a href="#ES6-相关基础题目" class="headerlink" title="ES6 相关基础题目"></a>ES6 相关基础题目</h1><ol>
<li><p>考察 let, const, var</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = d = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(e);  <span class="comment">// Uncaught ReferenceError: Cannot access &#x27;e&#x27; before initialization</span></span><br><span class="line">    <span class="keyword">let</span> e = <span class="number">5</span>;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="built_in">console</span>.log(c);  <span class="comment">// 报错 not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(d);  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(e);  <span class="comment">// 报错 not defined</span></span><br></pre></td></tr></table></figure>

<p>解析：<code>var</code> 声明会被提升到块级作用域顶部，<code>let</code> 和 <code>const</code> 会产生块级作用域，初始化之前访问会进入 <code>TDZ</code> 报错。<br><code>var c = d = 3;</code>等效于<code>d = 3; var c = d;</code>，所以let和var在函数销毁时不复存在，而<code>d=3</code>是存在的</p>
</li>
<li><p>考察运算符优先级</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.x = a = &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.n, b.n);  <span class="comment">//  2 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a.x, b.x);  <span class="comment">//  undefined &#123; n: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<p>解析：<code>var b = a;</code>，此时a和b指向同一对象， .访问符优先级比=符号优先级高，此时<code>b = &#123; n: 1, x: undefined &#125;</code>， 在计算=，赋值从右向左，所以此时<code>a = &#123; n: 2 &#125;, b = &#123; n: 2, x: &#123; n: 2 &#125;&#125;</code></p>
</li>
<li><p>变量提升优先级</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="built_in">console</span>.log(func);</span><br><span class="line">   <span class="keyword">var</span> func;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">   	<span class="built_in">console</span>.log(a);</span><br><span class="line">   	<span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">   	<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   func(<span class="number">2</span>);</span><br><span class="line">   <span class="comment">// 打印结果如下：</span></span><br><span class="line"><span class="comment">// function c(a) &#123;</span></span><br><span class="line">   <span class="comment">//     console.log(a);</span></span><br><span class="line">   <span class="comment">//     var a = 3;</span></span><br><span class="line">   <span class="comment">//     function a() &#123;</span></span><br><span class="line">   <span class="comment">//     &#125;</span></span><br><span class="line">   <span class="comment">// &#125;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// function a() &#123; &#125;</span></span><br></pre></td></tr></table></figure>

<p>解析：变量提升优先级：函数声明》arguments》变量声明</p>
</li>
<li><p>变量提升</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(c);</span><br><span class="line">	<span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c);  <span class="comment">// 1</span></span><br><span class="line">c(<span class="number">2</span>);  <span class="comment">// Uncaught TypeError: c is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述代码等效于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(c);</span><br><span class="line">	<span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line">c = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br><span class="line">c(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>解析：函数声明优先提升，当console.log(c); 执行的时候c已经被赋值为1，再执行c(2)就会抛出TypeError，因为c已经不是函数了</p>
</li>
<li><p>变量提升</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> name = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">		<span class="built_in">console</span>.log(name);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br><span class="line"><span class="comment">// 输出 B A</span></span><br><span class="line"><span class="comment">// 如果将`var name = &#x27;B&#x27;;`改为`name = &#x27;B&#x27;;`, 则输出 name函数 和 A</span></span><br></pre></td></tr></table></figure></li>
<li><p>变量提升</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(a);  <span class="comment">// 100</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.a);  <span class="comment">// 10</span></span><br><span class="line">	<span class="keyword">var</span> a;</span><br><span class="line">	<span class="built_in">console</span>.log(a);  <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br><span class="line">test(); </span><br></pre></td></tr></table></figure></li>
<li><p>块级作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo();  <span class="comment">// foo is not a function</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">	<span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>); &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();  <span class="comment">// bar is not defined</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (b) &#123;</span><br><span class="line">	bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>); &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">far();  <span class="comment">// far is not a function</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (c) &#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">far</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>); &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">far</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>this 指向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var v &#x3D; 1;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">	v: 2,</span><br><span class="line">	del: function () &#123;</span><br><span class="line">		console.log(this);</span><br><span class="line">		this.v *&#x3D; 2;</span><br><span class="line">		console.log(this.v);</span><br><span class="line">		console.log(v);</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.del();  &#x2F;&#x2F; obj  4  1 </span><br><span class="line"></span><br><span class="line">var name &#x3D; &#39;A&#39;;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">	name: &#39;B&#39;,</span><br><span class="line">	getNameFuc: function () &#123;</span><br><span class="line">		&#x2F;&#x2F; console.log(this);  &#x2F;&#x2F; obj</span><br><span class="line">		return function () &#123;</span><br><span class="line">			return this.name;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.getNameFuc()());  &#x2F;&#x2F; 相当于闭包  this指向window，所以输出A</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如何输出B？</span><br><span class="line">var name &#x3D; &#39;A&#39;;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">	name: &#39;B&#39;,</span><br><span class="line">	getNameFuc: function () &#123;</span><br><span class="line">		var that &#x3D; this;</span><br><span class="line">		return function () &#123;</span><br><span class="line">			return that.name;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.getNameFuc()());  &#x2F;&#x2F; 输出B,备份了this</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如何输出B？</span><br><span class="line">console.log(obj.getNameFuc().call(obj));</span><br><span class="line">console.log(obj.getNameFuc().call(obj)); </span><br><span class="line">console.log(obj.getNameFuc().bind(obj)());</span><br></pre></td></tr></table></figure></li>
<li><p>其他</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = b = <span class="number">5</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	c = <span class="number">666</span>;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c);  <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(c);  <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(c);  <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;undefined&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a);  <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b);  <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> c);  <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> d);  <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> e);  <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="comment">// typeof一个未定义的变量时,不会抛出错误,会返回&#x27;undefined&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="function">() =&gt;</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">var</span> p = [<span class="string">&#x27;undefined&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> q = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> r = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> s = <span class="literal">NaN</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o);  <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> p);  <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> q);  <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> e);  <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s);  <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="comment">// typeof无法区分Array/Date/ReExp和Object</span></span><br><span class="line"><span class="comment">// typeof null === &quot;object&quot;</span></span><br><span class="line"><span class="comment">// typeof NaN === &quot;number&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; &#125;) &#123;</span><br><span class="line">    x += <span class="keyword">typeof</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);  <span class="comment">// &#x27;1function&#x27;  ❌</span></span><br><span class="line"><span class="comment">// 正确答案：&#x27;1undefined&#x27;</span></span><br><span class="line"><span class="comment">// function f()&#123;&#125;当做if条件判断,其隐式转换后为true</span></span><br><span class="line"><span class="comment">// 但是在()中的函数不会声明提升,因此f函数在外部是不存在的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">bar</span>: <span class="string">&#x27;hello&#x27;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &#123; <span class="attr">bar</span>: <span class="string">&#x27;hello&#x27;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo1());  <span class="comment">// &#123; bar: &quot;hello&quot; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo2());  <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// foo2与foo1的区别在于foo2函数的return后面换行了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>(<span class="number">3</span>));  <span class="comment">//  [empty × 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// [2, 3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span>.toString());  <span class="comment">// &#x27;false&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].toString()); <span class="comment">// &#x27;1, 2, 3&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1.</span>toString());  <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class="line"><span class="comment">// 执行时变为(1.)toString()，少了一个点</span></span><br><span class="line"><span class="comment">// 正确的应该是: 1..toString();1 .toString();(1).toString();</span></span><br></pre></td></tr></table></figure>

<p>解析：<code>var a = b = 5;</code>等同<code>var a = b; b = 5</code>，JS执行代码是单线程的，同步任务优先执行</p>
</li>
<li><p>闭包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">6</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		a++;  <span class="comment">// 闭包，因此此处a访问的是func下的a</span></span><br><span class="line">		<span class="built_in">console</span>.log(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> func2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = func();</span><br><span class="line">f();  <span class="comment">// 7</span></span><br><span class="line">f(); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure></li>
<li><p>函数作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br><span class="line">show(fn) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>解析：JavaScript采用的是词法作用域,它规定了函数。访问变量时,查找变量是从函数声明的位置向外层作用域中查找,而不是从调用函数的位置开始向上查找。<br>因此fn函数内部访问的x是全局作用域中的x,而不是show函数作用域中的x</p>
</li>
<li><p>数据类型转换</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">666</span>;</span><br><span class="line"><span class="built_in">console</span>.log(++a);  <span class="comment">// 667</span></span><br><span class="line">consoNle.log(a++);  <span class="comment">// 667</span></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// 668</span></span><br><span class="line"><span class="comment">// 使用这类运算符时要注意:</span></span><br><span class="line"><span class="comment">// 1）这里的++、–-不能用作于常量。比如 1++; // 抛出错误</span></span><br><span class="line"><span class="comment">// 2）如果a不是数字类型, 会首先通过Number(a), 将a转换为数字。再执行++等运算</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">30</span>;</span><br><span class="line">++a;  <span class="comment">// a = 11</span></span><br><span class="line">a++;  <span class="comment">// a = 11</span></span><br><span class="line">e = ++a + (++b) + (c++) + a++;  <span class="comment">// a = 13</span></span><br><span class="line"><span class="built_in">console</span>.log(e);  <span class="comment">// 13 + 21 + 30 + 13</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;123abc&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str++);  <span class="comment">// number</span></span><br><span class="line"><span class="comment">// 如果变量不是数字类型,会首先用Number()转换为数字。因此typeof str++相当于typeof Number(str)++</span></span><br><span class="line"><span class="comment">// 由于后置的++是先取值后计算,因此相当于typeof Number(&#x27;123abc&#x27;)。即typeof NaN,所以输出&#x27;number。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + <span class="string">&quot;2&quot;</span> + <span class="string">&quot;2&quot;</span>);  <span class="comment">// &#x27;122&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + +<span class="string">&quot;2&quot;</span> + <span class="string">&quot;2&quot;</span>); <span class="comment">// &#x27;32&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + -<span class="string">&quot;1&quot;</span> + <span class="string">&quot;2&quot;</span>); <span class="comment">// &#x27;02&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">&quot;1&quot;</span> + <span class="string">&quot;1&quot;</span> + <span class="string">&quot;2&quot;</span>);  <span class="comment">// &#x27;112&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;A&quot;</span> - <span class="string">&quot;B&quot;</span> + <span class="string">&quot;2&quot;</span>); <span class="comment">// &#x27;NaN2&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;A&quot;</span> - <span class="string">&quot;B&quot;</span> + <span class="number">2</span>);  <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// 1. +a, 会把a转换为数字。-a会把a转换成数字的负值(如果能转换为数字的话, 否则为NaN)</span></span><br><span class="line"><span class="comment">// 2. 字符串与任何值相加都是字符串拼接。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">false</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&#x27;0&#x27;</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&#x27;&#x27;</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">NaN</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 1. undefined, null, false, &quot;&quot;, +0, -0, NaN 前述7个值会转为false;</span></span><br><span class="line"><span class="comment">// 2. 除此之外所有对象都将转为true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  money: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    alert(<span class="string">`hint: <span class="subst">$&#123;hint&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> hint == <span class="string">&quot;string&quot;</span> ? <span class="string">`&#123;name: &quot;<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>&quot;&#125;`</span> : <span class="built_in">this</span>.money;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换演示：</span></span><br><span class="line">alert(user); <span class="comment">// hint: string -&gt; &#123;name: &quot;John&quot;&#125;</span></span><br><span class="line">alert(+user); <span class="comment">// hint: number -&gt; 1000</span></span><br><span class="line">alert(user + <span class="number">500</span>); <span class="comment">// hint: default -&gt; 1500</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  money: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于 hint=&quot;string&quot;</span></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&#123;name: &quot;<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>&quot;&#125;`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于 hint=&quot;number&quot; 或 &quot;default&quot;</span></span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.money;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(user); <span class="comment">// toString -&gt; &#123;name: &quot;John&quot;&#125;</span></span><br><span class="line">alert(+user); <span class="comment">// valueOf -&gt; 1000</span></span><br><span class="line">alert(user + <span class="number">500</span>); <span class="comment">// valueOf -&gt; 1500</span></span><br><span class="line"><span class="comment">// 转换算法是：</span></span><br><span class="line"><span class="comment">//    调用 obj[Symbol.toPrimitive](hint) 如果这个方法存在，</span></span><br><span class="line"><span class="comment">//    否则，如果 hint 是 &quot;string&quot;</span></span><br><span class="line"><span class="comment">//    尝试 obj.toString() 和 obj.valueOf()，无论哪个存在。</span></span><br><span class="line"><span class="comment">//    否则，如果 hint 是 &quot;number&quot; 或者 &quot;default&quot;</span></span><br><span class="line"><span class="comment">//    尝试 obj.valueOf() 和 obj.toString()，无论哪个存在。</span></span><br><span class="line"><span class="comment">// 参考：https://zh.javascript.info/object-toprimitive</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下情况hint为string</span></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">alert(obj);</span><br><span class="line"><span class="comment">// 将对象作为属性键</span></span><br><span class="line">anotherObj[obj] = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下情况hint为number</span></span><br><span class="line"><span class="comment">// 显式转换</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="built_in">Number</span>(obj);</span><br><span class="line"><span class="comment">// 数学运算（除了二元加法）</span></span><br><span class="line"><span class="keyword">let</span> n = +obj; <span class="comment">// 一元加法</span></span><br><span class="line"><span class="keyword">let</span> delta = date1 - date2;</span><br><span class="line"><span class="comment">// 小于/大于的比较</span></span><br><span class="line"><span class="keyword">let</span> greater = user1 &gt; user2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下情况hint为default</span></span><br><span class="line"><span class="comment">// 二元加法使用默认 hint</span></span><br><span class="line"><span class="keyword">let</span> total = obj1 + obj2;</span><br><span class="line"><span class="comment">// obj == number 使用默认 hint</span></span><br><span class="line"><span class="keyword">if</span> (user == <span class="number">1</span>) &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> c = [];</span><br><span class="line"><span class="built_in">console</span>.log(a - b - c);   <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li>
<li><p>集合枚举</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.bar = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123; <span class="attr">moo</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> foo) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i);  <span class="comment">// &#x27;moo&#x27;  &#x27;bar&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<ol>
<li><p>for/in循环：遍历可枚举的自有属性和继承属性</p>
</li>
<li><p>Object.keys(): 返回对象可枚举自有属性数组</p>
</li>
</ol>
<p>​    3. Object.getOwnPropertyNames():返回对象所有自有属性数组</p>
<p>​    4. Object对象的propertyIsEnumerable()方法可以判断此对象是否包含某个属性，并且这个属性是否可枚举。</p>
<ol start="5">
<li>集合属性枚举影响以下三个函数的结果：for/in, Object.keys(), JSON.stringify</li>
</ol>
</li>
<li><p>值传递</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	b = [];</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>, b);</span><br><span class="line">	a.n = <span class="number">2</span>;</span><br><span class="line">	a = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line">func(obj, arr); <span class="comment">// [] &#123; b: 1 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; n: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeAgeAndReference</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    person.age = <span class="number">25</span>;</span><br><span class="line">    person = &#123;</span><br><span class="line">        name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">        age: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> personObj1 = &#123;</span><br><span class="line">    name: <span class="string">&quot;Alex&quot;</span>,</span><br><span class="line">    age: <span class="number">30</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> personObj2 = changeAgeAndReference(personObj1);</span><br><span class="line"><span class="built_in">console</span>.log(personObj1); <span class="comment">// -&gt; &#123;name: &#x27;Alex&#x27;, age: 25&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(personObj2); <span class="comment">// -&gt; &#123;name: &#x27;John&#x27;, age: 50&#125;</span></span><br></pre></td></tr></table></figure>

<p>解析：函数传递参数时,如果是基本类型为值传递,如果是引用类型,为引用地址的值传递。其实都是值传递</p>
</li>
<li><p>原型相关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Object instanceof Function);  &#x2F;&#x2F; true</span><br><span class="line">console.log(Function instanceof Object);  &#x2F;&#x2F; true</span><br><span class="line">console.log(Function instanceof Function);  &#x2F;&#x2F; true</span><br><span class="line">console.log(Number instanceof Number);  &#x2F;&#x2F; false</span><br><span class="line">console.log(String instanceof String);  &#x2F;&#x2F; false|</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">    return f;  &#x2F;&#x2F; 注意此处返回f本身</span><br><span class="line">&#125;</span><br><span class="line">console.log(new f() instanceof f);  &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function A() &#123; &#125;</span><br><span class="line">A.prototype.n &#x3D; 1;</span><br><span class="line">var b &#x3D; new A();</span><br><span class="line">A.prototype &#x3D; &#123;</span><br><span class="line">	n: 2,</span><br><span class="line">	m: 3</span><br><span class="line">&#125;</span><br><span class="line">var c &#x3D; new A();</span><br><span class="line">console.log(b.n, b.m);  &#x2F;&#x2F; 1 undefined</span><br><span class="line">console.log(c.n, c.m);  &#x2F;&#x2F; 2 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var F &#x3D; function () &#123;&#125;;</span><br><span class="line">var O &#x3D; &#123;&#125;;</span><br><span class="line">Object.prototype.a &#x3D; function() &#123;</span><br><span class="line">	console.log(&#39;a&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function.prototype.b &#x3D; function() &#123;</span><br><span class="line">	console.log(&#39;b&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f &#x3D; new F();</span><br><span class="line">F.a();  &#x2F;&#x2F; a</span><br><span class="line">F.b();  &#x2F;&#x2F; b</span><br><span class="line">O.a();  &#x2F;&#x2F; a</span><br><span class="line">O.b();  &#x2F;&#x2F; Uncaught TypeError: O.b is not a function</span><br><span class="line">&#x2F;&#x2F; F的原型链：F &#x3D;&gt; F.__proto__ &#x3D;&gt; Function.prototype &#x3D;&gt; Function.prototype.__proto__ &#x3D;&gt; Object.prototype &#x3D;&gt; null</span><br><span class="line">&#x2F;&#x2F; O的原型链：O &#x3D;&gt; O.__proto__  &#x3D;&gt; Object.prototype &#x3D;&gt; null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Person() &#123;  &#x2F;&#x2F; 1</span><br><span class="line">    getAge &#x3D; function () &#123;</span><br><span class="line">        console.log(10);</span><br><span class="line">    &#125;</span><br><span class="line">	return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.getAge &#x3D; function () &#123;  &#x2F;&#x2F; 2</span><br><span class="line">	console.log(20);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getAge &#x3D; function () &#123;  &#x2F;&#x2F; 3</span><br><span class="line">	console.log(30);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var getAge &#x3D; function () &#123;  &#x2F;&#x2F; 4</span><br><span class="line">	console.log(40);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getAge() &#123;  &#x2F;&#x2F; 5</span><br><span class="line">	console.log(50);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.getAge();  &#x2F;&#x2F; 20 执行Person函数上的getAge方法</span><br><span class="line">getAge();  &#x2F;&#x2F; 40 执行全局中的getAge方法</span><br><span class="line">Person().getAge();  &#x2F;&#x2F; 10 由于Person()单独执行所以,作用域中的this绑定为window, 相当于window.getAge()</span><br><span class="line">&#x2F;&#x2F; 但是Person执行时,内部修改了全局的getAge方法</span><br><span class="line">new Person.getAge(); &#x2F;&#x2F; 20 此时相当于实例化Person.getAge这个函数</span><br><span class="line">getAge();  &#x2F;&#x2F; 10 由于在Person().getAge()执行时把全局getAge改变了</span><br><span class="line">new Person().getAge();  &#x2F;&#x2F; 30  new Person().getAge();此时调用的是Person原型上的getAge方法</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>SUMMARY</title>
    <url>/bloger/2021/05/08/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96/SUMMARY/</url>
    <content><![CDATA[<h1 id="SUMMARY"><a href="#SUMMARY" class="headerlink" title="SUMMARY"></a>SUMMARY</h1><ul>
<li><p>[] <a href="%E5%8C%BA%E5%9D%97%E9%93%BE.md">区块链</a></p>
</li>
<li><p>[] <a href="%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6.md">智能合约</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>去中心化</category>
      </categories>
  </entry>
  <entry>
    <title>区块链</title>
    <url>/bloger/2021/08/02/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96/%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    <content><![CDATA[<h1 id="敬请期待"><a href="#敬请期待" class="headerlink" title="敬请期待!!!"></a>敬请期待!!!</h1>]]></content>
      <tags>
        <tag>无服务应用</tag>
      </tags>
  </entry>
  <entry>
    <title>智能合约</title>
    <url>/bloger/2021/08/02/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/</url>
    <content><![CDATA[<h1 id="敬请期待"><a href="#敬请期待" class="headerlink" title="敬请期待!!!"></a>敬请期待!!!</h1>]]></content>
      <tags>
        <tag>无服务应用</tag>
      </tags>
  </entry>
  <entry>
    <title>SUMMARY</title>
    <url>/bloger/2021/05/08/%E5%9B%BE%E8%A7%A3Google%20V8/SUMMARY/</url>
    <content><![CDATA[<h1 id="SUMMARY"><a href="#SUMMARY" class="headerlink" title="SUMMARY"></a>SUMMARY</h1><h2 id="JavaScript-设计思想"><a href="#JavaScript-设计思想" class="headerlink" title="JavaScript 设计思想"></a>JavaScript 设计思想</h2><ul>
<li><p><a href="%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E6%98%AF%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%EF%BC%9F.md">为什么函数是一等公民？</a></p>
</li>
<li><p>[] <a href="DNS%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84.md">dns 是如何实现负载均衡的</a></p>
</li>
<li><p>[] <a href="Nginx%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.md">nginx 如何实现负载均衡和反向代理</a></p>
</li>
</ul>
<h2 id="V8-编译流水线"><a href="#V8-编译流水线" class="headerlink" title="V8 编译流水线"></a>V8 编译流水线</h2><h2 id="事件循环和垃圾回收"><a href="#事件循环和垃圾回收" class="headerlink" title="事件循环和垃圾回收"></a>事件循环和垃圾回收</h2>]]></content>
      <categories>
        <category>V8</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/bloger/2021/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/SUMMARY/</url>
    <content><![CDATA[<h1 id="SUMMARY"><a href="#SUMMARY" class="headerlink" title="SUMMARY"></a>SUMMARY</h1><p><a href="https://matthrew.gitbook.io/oliver/">GitBook</a></p>
<!-- - [] [区块链](区块链.md)

- [] [智能合约](智能合约.md) -->

<!-- <a class="jsbin-embed" href="//jsbin.com/zegawep/embed">JS Bin on jsbin.com</a><script src="//static.jsbin.com/js/embed.min.js?4.1.8"></script> -->
<!-- <script src="https://gist.github.com/Matthrews/994e0100cc1107ee2775f1e700c81e94.js"></script> -->
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>DNS是如何实现负载均衡的</title>
    <url>/bloger/2021/08/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/DNS%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84/</url>
    <content><![CDATA[<h1 id="敬请期待"><a href="#敬请期待" class="headerlink" title="敬请期待!!!"></a>敬请期待!!!</h1>]]></content>
      <tags>
        <tag>无服务应用</tag>
      </tags>
  </entry>
  <entry>
    <title>你必须要知道的30个 Linux 命令</title>
    <url>/bloger/2021/04/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/%E4%BD%A0%E5%BF%85%E9%A1%BB%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%8430%E4%B8%AA%20Linux%20%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="你必须要知道的-30-个-Linux-命令"><a href="#你必须要知道的-30-个-Linux-命令" class="headerlink" title="你必须要知道的 30 个 Linux 命令"></a>你必须要知道的 30 个 Linux 命令</h2><ol>
<li>pwd</li>
</ol>
<blockquote>
<p>列出当前所在目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/mnt/c/Users/Matthew/Desktop</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="2">
<li>cd</li>
</ol>
<blockquote>
<p>文件夹切换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew$ <span class="built_in">cd</span> Downloads/</span><br><span class="line">root@matthew:/mnt/c/Users/Matthew/Downloads$</span><br></pre></td></tr></table></figure>

<p>快捷方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..   <span class="comment"># 返回上一层</span></span><br><span class="line"><span class="built_in">cd</span>      <span class="comment"># 直接到home目录</span></span><br><span class="line"><span class="built_in">cd</span> -    <span class="comment"># 退回到上一次目录</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="3">
<li>ls</li>
</ol>
<blockquote>
<p>列出当前文件夹内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Videos$ ls</span><br><span class="line">Captures  desktop.ini</span><br></pre></td></tr></table></figure>

<p>快捷方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -R  <span class="comment"># 列出当前文件夹以及当前文件夹子文件夹内容</span></span><br><span class="line">ls -a  <span class="comment"># 列出隐藏文件</span></span><br><span class="line">ls -al <span class="comment"># 列出当前文件夹内容以及详情，包括文件权限，大小，拥有者等等</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="4">
<li>cat</li>
</ol>
<blockquote>
<p>通过标准输出查看文件内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ cat 1.txt</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>如何使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &gt;4.txt   				<span class="comment"># 创建新文件4.txt</span></span><br><span class="line">cat 1.txt 2.txt&gt;3.txt 	<span class="comment"># 把1.txt和2.txt文件内容拼接起来输出到新文件3.txt</span></span><br><span class="line">cat 1.txt | tr a-z A-Z &gt;3.txt <span class="comment"># 将1.txt文件内容小写转大写，然后输出到3.txt</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="5">
<li>cp</li>
</ol>
<blockquote>
<p>把当前文件夹下文件复制到其他文件夹下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ cp 2.txt .. <span class="comment"># 把当前文件夹下2.txt复制到上一层目录下</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="6">
<li>mv</li>
</ol>
<blockquote>
<p>主要用于移动文件，也可以用来重命名文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ mv 2.txt .. <span class="comment"># 把当前文件夹下2.txt移动到上一层目录下</span></span><br><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ mv 1.txt out.txt <span class="comment"># 将当前文件夹下1.txt文件名改为out.txt</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="7">
<li>mkdir</li>
</ol>
<blockquote>
<p>创建文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ mkdir dir1</span><br></pre></td></tr></table></figure>

<p>快捷方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir p1/p2  <span class="comment"># 创建文件夹p1的子文件夹p2</span></span><br><span class="line">mkdir -p p1/parentDir/p2 <span class="comment"># 在已经创建的文件夹p1和p2之间创建新文件夹parentDir, p2成为parentDir的子文件夹</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="8">
<li>rmdir</li>
</ol>
<blockquote>
<p>删除文件夹，但是只允许你删除空文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ rmdir dir1</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="9">
<li>rm</li>
</ol>
<blockquote>
<p>删除文件夹以及文件夹内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ rm 2.txt</span><br></pre></td></tr></table></figure>

<p>常用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -r dir2  <span class="comment">## 删除文件夹dir2以及内容</span></span><br><span class="line">rm -rf dir2 <span class="comment">## 强制删除文件夹dir2以及内容</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="10">
<li>touch</li>
</ol>
<blockquote>
<p>创建新文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ touch index.js</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="11">
<li>locate</li>
</ol>
<blockquote>
<p>搜索文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ locate -i <span class="keyword">in</span>*x.html</span><br><span class="line">/usr/lib/python3/dist-packages/twisted/python/_pydoctortemplates/index.html</span><br><span class="line">/usr/share/doc/adduser/examples/adduser.local.conf.examples/skel.other/index.html /usr/share/doc/gdisk/index.html</span><br><span class="line">/usr/share/doc/python3/python-policy.html/index.html</span><br><span class="line">/usr/share/doc/shared-mime-info/shared-mime-info-spec.html/index.html</span><br></pre></td></tr></table></figure>

<p>注意<br>locate 与 find 不同: find 是去硬盘找，locate 只在 /var/lib/slocate 资料库中找<br>locate 的速度比 find 快，它并不是真的查找，而是查数据库</p>
</blockquote>
<ol start="11">
<li>find</li>
</ol>
<blockquote>
<p>在给定的文件夹内搜索文件或文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ find . -name 3.txt</span><br><span class="line">./3.txt</span><br></pre></td></tr></table></figure>

<p>常用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -name tran.txt     <span class="comment"># 在当前文件夹下寻找tran.txt文件</span></span><br><span class="line">find . -iname tran.txt     <span class="comment"># 在当前文件夹下寻找tran.txt文件，并且不区分大小写</span></span><br><span class="line">find . -<span class="built_in">type</span> d -name dir  <span class="comment"># 在当前文件夹下找dir文件夹</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="12">
<li>grep</li>
</ol>
<blockquote>
<p>文件内容搜索</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ grep 123 index.js 123 123 123</span><br></pre></td></tr></table></figure>

<p>常用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -i -w <span class="string">&#x27;hello&#x27;</span> index.js        <span class="comment"># index.js文件里搜索hello，区分大小写</span></span><br><span class="line">grep -E -i -w <span class="string">&#x27;123|hello&#x27;</span> index.js <span class="comment"># index.js文件里搜索123或者hello，区分大小写，并且使用正则匹配</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="13">
<li>sudo</li>
</ol>
<blockquote>
<p>以管理员权限运行</p>
</blockquote>
<ol start="14">
<li>df</li>
</ol>
<blockquote>
<p>查看系统磁盘使用情况，展示单位为%或者 KB，使用<code>df -m</code>以 MB 展示磁盘使用情况</p>
</blockquote>
<ol start="15">
<li>du</li>
</ol>
<blockquote>
<p>查看文件夹和文件的磁盘占用情况<br>注意：磁盘占用情况不等于文件大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop$ du jquery-ui-table</span><br><span class="line">16      jquery-ui-table/.git/hooks</span><br><span class="line">0       jquery-ui-table/.git/inf</span><br><span class="line">108     jquery-ui-table/.git/objects/pack</span><br><span class="line">108     jquery-ui-table/.git/objects</span><br><span class="line">124     jquery-ui-table/.git</span><br><span class="line">40      jquery-ui-table/src</span><br><span class="line">40      jquery-ui-table/<span class="built_in">test</span></span><br><span class="line">204     jquery-ui-table</span><br></pre></td></tr></table></figure>

<p>常用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">du -sh babel  <span class="comment"># 统计babel文件夹磁盘占用情况，并以合适的单位显示</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="16">
<li>head</li>
</ol>
<blockquote>
<p>展示文件前几行内容，默认前 10 行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ head index.js</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>常用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">head -n 5 index.js        <span class="comment"># 查看index.js文件前5行内容</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="17">
<li>tail</li>
</ol>
<blockquote>
<p>和 head 类似，展示后面几行</p>
</blockquote>
<ol start="18">
<li>diff</li>
</ol>
<blockquote>
<p>文件内容逐行对比</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ diff 2.txt 3.txt</span><br><span class="line">5d4</span><br><span class="line">&lt; world</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="19">
<li>chmod</li>
</ol>
<blockquote>
<p>修改文件的读写可执行权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x deploy.sh  <span class="comment"># 让deploy.sh脚本有可执行权限</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="20">
<li>chown</li>
</ol>
<blockquote>
<p>修改文件的所有权</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown anotheruser deploy.sh  <span class="comment"># 将deploy.sh文件所有权赋予非anotheruser</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="21">
<li>kill</li>
</ol>
<blockquote>
<p>终止进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -KILL 123456 <span class="comment"># 杀死进程号PID为123456的进程</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="22">
<li>ping</li>
</ol>
<blockquote>
<p>测试与服务器连接状况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew$ ping baidu.com</span><br><span class="line">PING baidu.com (39.156.69.79) 56(84) bytes of data. 64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=1 ttl=52</span><br><span class="line">time=28.0ms 64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=2 ttl=52 time=30.9ms 64 bytes from 39.156.69.79 (</span><br><span class="line">39.156.69.79): icmp_seq=3 ttl=52 time=123 ms ... --- baidu.com ping statistics --- 34 packets transmitted, 34 received,</span><br><span class="line">0% packet loss, time 33235ms rtt min/avg/max/mdev = 27.417/39.384/123.661/22.443 ms</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="23">
<li>wget</li>
</ol>
<blockquote>
<p>下载文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew$ wget https://baidu.com.cn</span><br><span class="line">--2021-04-16 18:27:05--  https://baidu.com.cn/</span><br><span class="line">Resolving baidu.com.cn (baidu.com.cn)... 39.156.69.79, 220.181.38.148</span><br><span class="line">Connecting to baidu.com.cn (baidu.com.cn)|39.156.69.79|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 302 Moved Temporarily</span><br><span class="line">Location: http://www.baidu.com/ [following]</span><br><span class="line">--2021-04-16 18:27:06--  http://www.baidu.com/</span><br><span class="line">Resolving www.baidu.com (www.baidu.com)... 36.152.44.95, 36.152.44.96</span><br><span class="line">Connecting to www.baidu.com (www.baidu.com)|36.152.44.95|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 2381 (2.3K) [text/html]</span><br><span class="line">Saving to: ‘index.html’</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="24">
<li>uname</li>
</ol>
<blockquote>
<p>打印 Unix 系统名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew$ uname</span><br><span class="line">Linux</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="25">
<li>top</li>
</ol>
<blockquote>
<p>持续监听进程运行状态</p>
</blockquote>
<ol start="26">
<li>history</li>
</ol>
<blockquote>
<p>查询输入记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew$ <span class="built_in">history</span> | grep baidu <span class="comment"># 查询输入baidu相关历史命令</span></span><br><span class="line">268 ping baidu.com 269 wget htts://baidu.com.cn 270 wget https://baidu.com.cn</span><br><span class="line">279 <span class="built_in">history</span> | grep baidu</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="27">
<li>man</li>
</ol>
<blockquote>
<p>查看 Linux 中的指令帮助、配置文件帮助和编程帮助等信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man vim <span class="comment"># 查询vim使用说明</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="28">
<li>echo</li>
</ol>
<blockquote>
<p>输出指定的字符串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello</span><br></pre></td></tr></table></figure>

<p>常用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ <span class="built_in">echo</span> Hello, my name is John &gt;&gt; name.txt <span class="comment"># 将给定字符串写入name.txt文件</span></span><br><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ cat name.txt</span><br><span class="line">Hello, my name is John</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="29">
<li>zip, unzip</li>
</ol>
<blockquote>
<p>压缩，解压文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将当前目录下所有文件和文件夹打包为当前目录下的out.zip，加-q表示不显示过程</span></span><br><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ zip  -r out.zip .</span><br><span class="line">adding: 2.txt (deflated 4%)</span><br><span class="line">adding: 3.txt (deflated 6%)</span><br><span class="line">adding: dir/ (stored 0%)</span><br><span class="line">adding: dir/index.html (stored 0%)</span><br><span class="line">adding: dir/index.js (deflated 41%)</span><br><span class="line">adding: dir/name.txt (stored 0%)</span><br><span class="line">adding: dir/ss.tex (stored 0%)</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="30">
<li>hostname</li>
</ol>
<blockquote>
<p>查看主机名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@matthew:/mnt/c/Users/Matthew/Desktop/<span class="built_in">test</span>$ hostname</span><br><span class="line">matthew</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <tags>
        <tag>linux command</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx如何实现负载均衡和反向代理</title>
    <url>/bloger/2021/08/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/Nginx%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="敬请期待"><a href="#敬请期待" class="headerlink" title="敬请期待!!!"></a>敬请期待!!!</h1>]]></content>
      <tags>
        <tag>无服务应用</tag>
      </tags>
  </entry>
  <entry>
    <title>SUMMARY</title>
    <url>/bloger/2021/05/08/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/SUMMARY/</url>
    <content><![CDATA[<h1 id="SUMMARY"><a href="#SUMMARY" class="headerlink" title="SUMMARY"></a>SUMMARY</h1><ul>
<li><p><a href="%E5%8E%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8C%96%E6%8E%A2%E7%B4%A2.md">去服务器化探索</a></p>
</li>
<li><p>[] <a href="DNS%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84.md">dns 是如何实现负载均衡的</a></p>
</li>
<li><p>[] <a href="Nginx%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.md">nginx 如何实现负载均衡和反向代理</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>服务器相关</category>
      </categories>
  </entry>
  <entry>
    <title>去服务化探索</title>
    <url>/bloger/2021/08/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/%E5%8E%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8C%96%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><ul>
<li><p><a href="https://blog.csdn.net/cunjie3951/article/details/106906118">如何使用 React 和 AWS Amplify 构建无服务器 Web 应用程序</a></p>
</li>
<li><p><a href="https://docs.amplify.aws/start/q/integration/react">Amplify Docs</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>无服务应用</tag>
      </tags>
  </entry>
  <entry>
    <title>Babel教程</title>
    <url>/bloger/1970/01/01/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Babel%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Babel教程"><a href="#Babel教程" class="headerlink" title="Babel教程"></a>Babel教程</h1><h2 id="Babel-入门教程"><a href="#Babel-入门教程" class="headerlink" title="Babel 入门教程"></a>Babel 入门教程</h2><p><a href="https://www.ruanyifeng.com/blog/2016/01/babel.html">https://www.ruanyifeng.com/blog/2016/01/babel.html</a></p>
<p><a href="https://blog.csdn.net/weixin_34214500/article/details/88704642">babel7学习笔记_weixin_34214500的博客-CSDN博客</a></p>
<p><a href="http://xaber.co/2019/09/07/babel-7-%E5%85%A8%E5%A5%97/">babel 7 全套 | Xaber’s Blog</a></p>
<h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><p><a href="https://babel.docschina.org/docs/en/babel-preset-env/">https://babel.docschina.org/docs/en/babel-preset-env/</a></p>
]]></content>
      <tags>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title>WebAssembly</title>
    <url>/bloger/1970/01/01/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/WebAssembly/</url>
    <content><![CDATA[<h2 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h2><p><a href="http://xaber.co/2019/09/10/JavaScript-WebAssembly-%E8%A7%A3%E9%87%8A%E3%80%81%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/">JavaScript &amp; WebAssembly 解释、编译相关 | Xaber’s Blog</a></p>
]]></content>
      <tags>
        <tag>WebAssembly</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 异步加载模块原理</title>
    <url>/bloger/1970/01/01/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Webpack%20%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="Webpack-异步加载模块原理"><a href="#Webpack-异步加载模块原理" class="headerlink" title="Webpack 异步加载模块原理"></a>Webpack 异步加载模块原理</h2><blockquote>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/88332125">webpack模块化原理-异步加载模块 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h2 id="你可能不知道的9条Webpack优化策略"><a href="#你可能不知道的9条Webpack优化策略" class="headerlink" title="你可能不知道的9条Webpack优化策略"></a><a href="https://segmentfault.com/a/1190000038376591">你可能不知道的9条Webpack优化策略</a></h2><p><a href="https://segmentfault.com/a/1190000012113011">webpack externals 深入理解 - SegmentFault 思否</a></p>
<p><a href="https://www.zhihu.com/answer/1814301201">https://www.zhihu.com/answer/1814301201</a></p>
<p>webpack 入口文件最大：244KiB 超过会报警</p>
<h2 id="webpack持久化缓存优化策略"><a href="#webpack持久化缓存优化策略" class="headerlink" title="webpack持久化缓存优化策略"></a>webpack持久化缓存优化策略</h2><p><a href="https://zhuanlan.zhihu.com/p/28208003">https://zhuanlan.zhihu.com/p/28208003</a></p>
]]></content>
      <tags>
        <tag>Webpack，异步加载</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack5新特性</title>
    <url>/bloger/2021/04/05/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Webpack5%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="Webpack5-新特性"><a href="#Webpack5-新特性" class="headerlink" title="Webpack5 新特性"></a>Webpack5 新特性</h2><h3 id="整体方向"><a href="#整体方向" class="headerlink" title="整体方向"></a>整体方向</h3><ul>
<li>尝试使用持久性缓存来提高构建性能</li>
<li>尝试使用更好的算法和默认值来改进长期缓存</li>
<li>尝试使用更好的 Tree Shaking 和代码生成来改善包大小</li>
<li>尝试改善与网络平台的兼容性</li>
<li>尝试在不引入任何破坏性变化的情况下，改善 v4 的内部结构</li>
<li>尝试引入一些突破性变化为未来做准备</li>
</ul>
<h3 id="不再为-Node-js-模块自动引用-Polyfills"><a href="#不再为-Node-js-模块自动引用-Polyfills" class="headerlink" title="不再为 Node.js 模块自动引用 Polyfills"></a>不再为 Node.js 模块自动引用 <code>Polyfills</code></h3><ol>
<li><code>webpack4</code>浏览器下<code>node:crypto</code>可用,是因为<code>webpack4</code>使用了官方<code>polyfill: crypto-browserify</code>，但是打包下来<code>bundle.js</code>文件<code>2.2MB</code><br>（未压缩），不包含<code>node:crypto</code>打包下来<code>bundle.js</code>也就<code>1020KiB</code></li>
<li><code>webpack5</code>浏览器下<code>node:crypto</code>不可用<br><img src="https://raw.githubusercontent.com/Matthrews/rfzhu_blogs/main/%E5%9B%BE%E7%89%87/webpack5-nopolyfill.png?token=AHD3VNX677UO5DF4B6SAD4LAQAVEO" alt="webpack5"></li>
<li>建议</li>
</ol>
<ul>
<li>尽量使用前端兼容模块，比如使用<code>crypto-js</code>代替<code>crypto</code></li>
<li>手动添加 <code>polyfill</code>，参考上图提示</li>
<li>在<code> package.json</code> 中添加 <code>browser</code> 字段，使<code>package</code> 与前端兼容</li>
</ul>
<ol start="4">
<li><a href="https://github.com/Matthrews/webpack5.vs.webpack4/tree/main/demo2">源码</a></li>
</ol>
<h3 id="长期缓存"><a href="#长期缓存" class="headerlink" title="长期缓存"></a>长期缓存</h3><ol>
<li>确定的 Chunk、模块 ID 和导出名称 新增长期缓存算法，生产环境默认启用<br><code>chunkIds: &quot;deterministic&quot; moduleIds: &quot;deterministic&quot; mangleExports: &quot;deterministic&quot;</code></li>
<li>真正的内容哈希 当使用<code>[contenthash]</code>时，Webpack 5 将使用真正的文件内容哈希值。之前它 “只” 使用内部结构的哈希值。 当只有注释被修改或变量被重命名时，这对长期缓存会有积极影响。这些变化在压缩后是不可见的</li>
</ol>
<h3 id="开发支持"><a href="#开发支持" class="headerlink" title="开发支持"></a>开发支持</h3><ol>
<li><p>命名代码块 ID 默认启用代码块 ID 算法，开发模式下生成的模块名称可读，便于调试，就不需要<code>import(/* webpackChunkName: &quot;name&quot; */ &quot;module&quot;)</code>来调试了<br>此外，可以在生产环境中使用<code>chunkIds: &quot;named&quot;</code></p>
</li>
<li><p>模块联邦 Webpack 可以通过 DLL 或者 Externals 可以在同一个应用里做代码共享 Common Chunk，而模块联邦可以使得跨应用间真正做到模块共享</p>
</li>
</ol>
<h3 id="支持崭新的-Web-平台特性"><a href="#支持崭新的-Web-平台特性" class="headerlink" title="支持崭新的 Web 平台特性"></a>支持崭新的 Web 平台特性</h3><ol>
<li>支持崭新的 Web 平台特性 内置资源模块支持，支持<code>import</code>和<code>URL</code>方式，后者是新方式，举个例子</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// old</span></span><br><span class="line"><span class="keyword">import</span> url <span class="keyword">from</span> <span class="string">&quot;./image.png&quot;</span>;</span><br><span class="line"><span class="comment">// new opts</span></span><br><span class="line"><span class="keyword">new</span> URL(<span class="string">&quot;./image.png&quot;</span>, <span class="keyword">import</span>.meta.url);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>原生 Worker 支持<br><code>new Worker(new URL(&quot;./worker.js&quot;, import.meta.url))</code></p>
</li>
<li><p>URI Webpack 5 支持在请求中处理协议</p>
</li>
</ol>
<ul>
<li>支持<code>data</code></li>
<li>支持<code>file</code>：需要通过<code>new webpack.experiments.s schemesHttp(s)UriPlugin()</code>选择加入</li>
<li>支持<code>https</code></li>
</ul>
<ol start="4">
<li><p>异步模块 支持异步模块——基于异步和 Promise 的模块，比如<code>import(&quot;lodash&quot;)</code></p>
</li>
<li><p>外部资源 增加了一些外部资源类型，比如 promise、import、module 和 script</p>
</li>
</ol>
<h3 id="支持全新的-Node-js-生态特性"><a href="#支持全新的-Node-js-生态特性" class="headerlink" title="支持全新的 Node.js 生态特性"></a>支持全新的 Node.js 生态特性</h3><ol>
<li><p>现在支持 package.json 中的 exports 和 imports 字段</p>
</li>
<li><p>原生支持 Yarn PnP</p>
</li>
</ol>
<h3 id="开发体验"><a href="#开发体验" class="headerlink" title="开发体验"></a>开发体验</h3><ol>
<li><p>经过优化的构建目标 Webpack 5 允许传递一个目标列表，并且支持目标的版本。为 webpack 提供它需要确定的所有信息：代码加载机制以及支持的语法</p>
</li>
<li><p>Stats 改进了统计测试格式的可读性和冗余性</p>
</li>
<li><p>进度 对 ProgressPlugin 做了一些改进，它被 CLI 在参数 –progress 开启时使用，但也可以作为插件手动使用</p>
</li>
<li><p>自动添加唯一命名 在 webpack 4 中，多个 webpack 运行时可能会在同一个 HTML 页面上发生冲突，因为它们使用同一个全局变量进行代码块加载。为了解决这个问题，需要为 output.jsonpFunction<br>配置提供一个自定义的名称</p>
</li>
<li><p>自动添加公共路径 Webpack 5 会在可能的情况下自动确定 output.publicPath。</p>
</li>
<li><p>Typescript 类型 Webpack 5 从源码中生成 typescript 类型，并通过 npm 包暴露它们</p>
</li>
</ol>
<h3 id="构建优化"><a href="#构建优化" class="headerlink" title="构建优化"></a>构建优化</h3><ol>
<li><p>嵌套的 tree-shaking webpack 现在能够跟踪对导出的嵌套属性的访问。这可以改善重新导出命名空间对象时的 Tree Shaking</p>
</li>
<li><p>内部模块 tree-shaking webpack 5 有一个新的选项 optimization.innerGraph，在生产模式下是默认启用的，它可以对模块中的标志进行分析，找出导出和引用之间的依赖关系。</p>
</li>
<li><p>CommonJs Tree Shaking 对 CommonJs 导出和 require() 调用时的导出使用分析</p>
</li>
<li><p>副作用分析 在 package.json 中的 “sideEffects” 标志允许手动将模块标记为无副作用，这就允许在不使用时放弃它们。</p>
</li>
</ol>
<p>webpack 5 也可以根据对源代码的静态分析，自动将模块标记为无副作用</p>
<ol start="5">
<li><p>模块合并 模块合并也可以在每个运行时工作，允许每个运行时进行不同的合并</p>
</li>
<li><p>改进代码生成</p>
</li>
<li><p>改进 target 配置</p>
</li>
<li><p>代码块拆分与模块大小</p>
</li>
</ol>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ol>
<li>持久缓存 支持文件系统缓存。它是可选的，可以通过以下配置启用：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  cache: &#123;</span><br><span class="line">    <span class="comment">// 1. 将缓存类型设置为文件系统</span></span><br><span class="line">    type: <span class="string">&quot;filesystem&quot;</span>,</span><br><span class="line"></span><br><span class="line">    buildDependencies: &#123;</span><br><span class="line">      <span class="comment">// 2. 将你的 config 添加为 buildDependency，以便在改变 config 时获得缓存无效</span></span><br><span class="line">      config: [__filename],</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 如果你有其他的东西被构建依赖，你可以在这里添加它们</span></span><br><span class="line">      <span class="comment">// 注意，webpack、加载器和所有从你的配置中引用的模块都会被自动添加</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编译器闲置和关闭 编译器现在需要在使用后关闭。编译器现在会进入和离开空闲状态，并且有这些状态的钩子。插件可能会使用这些钩子来做不重要的工作</li>
</ol>
<p>在使用 Node.js API 时，一定要在完成工作后调用 Compiler.close。</p>
<ol start="3">
<li>文件生成 所以 webpack 现在会检查输出目录中现有的文件，并将其内容与内存中的输出文件进行比较。只有当文件被改变时，它才会写入文件。 这只在第一次构建时进行。任何增量构建都会在运行中的 webpack<br>进程中生成新的资产时写入文件</li>
</ol>
<h3 id="长期未解决的问题"><a href="#长期未解决的问题" class="headerlink" title="长期未解决的问题"></a>长期未解决的问题</h3><ol>
<li>单一文件目标的代码分割 只允许启动单个文件的目标（如 node、WebWorker、electron main）现在支持运行时自动加载引导所需的依赖代码片段</li>
</ol>
<p>这允许对这些目标使用 <code>chunks: &quot;all&quot;</code> 和 <code>optimization.runtimeChunk</code></p>
<ol start="2">
<li>解析器更新</li>
</ol>
<h3 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h3><ol>
<li>实验特性</li>
</ol>
<ul>
<li>异步 WebAssembly</li>
<li>顶层的 Await</li>
</ul>
<ol start="2">
<li>最小 Node.js 版本 最低支持的 Node.js 版本从 6 增加到 10.13.0(LTS)</li>
</ol>
<h3 id="配置变更"><a href="#配置变更" class="headerlink" title="配置变更"></a>配置变更</h3><h3 id="重大内部变更"><a href="#重大内部变更" class="headerlink" title="重大内部变更"></a>重大内部变更</h3><ol>
<li><p>缓存插件更新 增加了一个带有插件接口的 Cache 类。该类可用于写入和读取缓存。根据配置的不同，不同的插件可以为缓存添加功能。MemoryCachePlugin 增加了内存缓存功能。FileCachePlugin<br>增加了持久性（文件系统）缓存</p>
</li>
<li><p>从数组到集合(Set)</p>
</li>
<li><p>模块热替换</p>
</li>
<li><p>全新的监听 它之前使用的是 chokidar 和原生依赖 fsevents（仅在 macOS 上）。现在它在只基于原生的 Node.js 中的 fs</p>
</li>
</ol>
<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ul>
<li>缓存</li>
<li>Tree Shaking</li>
<li>拥抱 Node.js</li>
</ul>
]]></content>
      <categories>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack源码浅析</title>
    <url>/bloger/2020/12/20/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Webpack%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Webpack-源码浅析"><a href="#Webpack-源码浅析" class="headerlink" title="Webpack 源码浅析"></a>Webpack 源码浅析</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://segmentfault.com/a/1190000021585435">https://segmentfault.com/a/1190000021585435</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6844903987129352206">https://juejin.cn/post/6844903987129352206</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>Webpack 源码浅析</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出 Webpack 阅读笔记</title>
    <url>/bloger/2021/02/01/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/%5B%E5%90%B4%E6%B5%A9%E9%BA%9F%5D%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Webpack/</url>
    <content><![CDATA[<h2 id="深入浅出-Webpack"><a href="#深入浅出-Webpack" class="headerlink" title="深入浅出 Webpack"></a>深入浅出 Webpack</h2><p>[TOC]</p>
<h3 id="入门系列"><a href="#入门系列" class="headerlink" title="入门系列"></a>入门系列</h3><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><ul>
<li><p>什么是模块化？ 复杂的系统分解到多个模块以方便编码</p>
</li>
<li><p>为什么要使用模块化思想组织代码？ 以前使用的是命名控件方式组织代码，比如 jQuery 库把它的 API 都放在了 window.$，这样会带来命名空间冲突、无法合理的管理项目的依赖和版本和无法有效控制依赖加载顺序等问题</p>
</li>
<li><p>两种模块化规范：CmmonJS(CJS),AMD 和 ESM</p>
</li>
<li><p>CommonJS 的优点： 代码可复用于 Node.js 环境下并运行，例如做同构应用； 通过 NPM 发布的很多第三方模块都采用了 CommonJS 规范。</p>
</li>
<li><p>CommonJS 的缺点: 代码无法直接运行在浏览器环境下，必须通过工具转换成标准的 ES5</p>
</li>
<li><p>AMD 的优点在于： 可在不转换代码的情况下直接在浏览器中运行； 可异步加载依赖； 可并行加载多个依赖； 代码可运行在浏览器环境和 Node.js 环境下。</p>
</li>
<li><p>AMD 的缺点: JavaScript 运行环境没有原生支持 AMD，需要先导入实现了 AMD 的库后才能正常使用。</p>
</li>
<li><p>ES6 模块化 ES6 模块化是欧洲计算机制造联合会 ECMA 提出的 JavaScript 模块化规范，它在语言的层面上实现了模块化</p>
<p>浏览器厂商和 Node.js 都宣布要原生支持该规范。它将逐渐取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</p>
<p>缺点在于目前无法直接运行在大部分 JavaScript 运行环境下，必须通过工具转换成标准的 ES5 后才能正常运行<br><a href="https://www.ruanyifeng.com/blog/2020/08/how-nodejs-use-es6-module.html">Node.js 如何处理 ES6 模块</a></p>
</li>
</ul>
<h4 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h4><ul>
<li>构建过程做了什么？</li>
</ul>
<ol>
<li>把源代码转换成发布到线上的可执行 JavaScrip、CSS、HTML 代码，包括如下内容。<ul>
<li>代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。</li>
<li>文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。</li>
<li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li>
<li>模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</li>
<li>自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</li>
<li>代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</li>
<li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</li>
</ul>
</li>
</ol>
<p>构建其实是工程化、自动化思想在前端开发中的体现，把一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。</p>
<ul>
<li>常见构建工具</li>
</ul>
<ol>
<li><p>npm</p>
<ul>
<li>内置但是功能过于简单</li>
</ul>
</li>
<li><p>Grunt</p>
<ul>
<li>进化版 npm ，可以灵活定义执行任务，但是集成度不高，无法做到开箱即用</li>
</ul>
</li>
<li><p>Gulp</p>
<ul>
<li>基于流的自动化构建工具</li>
<li>最大特点是引入了流的概念，同时提供了一系列常用的插件去处理流，流可以在插件之间传递</li>
<li>简单，通过以下 5 个方法几乎可以覆盖所有日常</li>
</ul>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">通过 gulp.task 注册任务 通过 gulp.run 执行任务 通过 gulp.watch 监听文件变化 通过 gulp.src 读文件 通过 gulp.dest 写文件</span><br></pre></td></tr></table></figure>

<pre><code>- Grunt 的加强版。相对于 Grunt，Gulp增加了监听文件、读写文件、流式处理的功能。但仍然集成度不高，无法做到开箱即用
</code></pre>
<ol start="4">
<li><p>Fis3</p>
<ul>
<li>百度创造</li>
<li>相对于 Grunt、Gulp 这些只提供基本功能的工具，Fis3 集成了 Web 开发中的常用构建功能，开始有点集成的意思</li>
<li>常见构建功能如下</li>
</ul>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">读写文件：通过 fis.match 读文件，release 配置文件输出路径。 资源定位：解析文件之间的依赖关系和文件位置。 文件指纹：通过 useHash 配置输出文件时给文件 URL 加上 md5 戳来优化浏览器缓存。</span><br><span class="line">文件编译：通过 parser 配置文件解析器做文件转换，例如把 ES6 编译成 ES5。 压缩资源：通过 optimizer 配置代码压缩方法。 图片合并：通过 spriter 配置合并 CSS 里导入的图片到一个文件来减少 HTTP</span><br><span class="line">请求数。</span><br></pre></td></tr></table></figure>

<pre><code>- 优点：集成了各种 Web 开发所需的构建功能，配置简单开箱即用
- 缺点：目前官方不再更新和维护，不支持最新版本的 Node.js
</code></pre>
<ol start="5">
<li><p>Webpack</p>
<ul>
<li>打包模块化 JavaScript 的工具，在 Webpack 里一切文件皆模块，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件</li>
<li>优点</li>
</ul>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">专注模块化打包，开箱即用一步到位 通过 Plugin 扩展，完整好用又不失灵活 使用场景不仅限于 Web 开发 社区活跃 开发体验较好</span><br></pre></td></tr></table></figure>

<pre><code>- 缺点：只能用于采用模块化开发的项目
</code></pre>
<ol start="6">
<li><p>Rollup</p>
<ul>
<li>和 Webpack 差不多，但是打包出来的代码更小更快</li>
<li>出现在 Webpack 之后</li>
<li>生态链不太完善</li>
<li>功能不太完善</li>
<li>不支持代码分割</li>
</ul>
</li>
</ol>
<ul>
<li>webpack-dev-server 可以做什么</li>
</ul>
<ol>
<li>提供 HTTP 服务</li>
<li>监听文件的变化并自动刷新网页，做到实时预览；</li>
<li>支持 Source Map，以方便调试。</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Webpack 原生支持上述第 2、3 点内容，再结合官方提供的开发工具 DevServer 也可以很方便地做到第 1 点。 DevServer 会启动一个 HTTP 服务器用于服务网页请求，同时会帮助启动 Webpack ，并接收</span><br><span class="line">Webpack 发出的文件更变信号，通过 WebSocket 协议自动刷新网页做到实时预览。 模块热替换:不重新加载整个网页的情况下，通过将被更新过的模块替换老的模块，再重新执行一次来实现实时预览</span><br></pre></td></tr></table></figure>

<ul>
<li>核心术语<ol>
<li>Entry： 输入</li>
<li>Module： 模块</li>
<li>Chunk：代码块</li>
<li>Loader：模块转换器</li>
<li>Plugin：扩展插件</li>
<li>Output：输出</li>
</ol>
</li>
</ul>
<h3 id="配置系列"><a href="#配置系列" class="headerlink" title="配置系列"></a>配置系列</h3><ul>
<li>Entry</li>
</ul>
<ol>
<li>entry 必填</li>
<li>类型：string | array | object</li>
</ol>
<ul>
<li>Output</li>
</ul>
<ol>
<li><p>filename</p>
<p>配置输出文件的名称，比如<code>static/js/[name].[contenthash:8].js</code><br>其中[name]为内置函数，除此之外还有</p>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">id Chunk 的唯一标识，从 0 开始 name Chunk 的名称 hash Chunk 的唯一标识的 Hash 值 chunkhash Chunk 内容的 Hash 值</span><br></pre></td></tr></table></figure>

<pre><code>其中 hash 和 chunkhash 的长度是可指定的，[hash:8] 代表取8位 Hash 值，默认是20位
</code></pre>
<ol start="2">
<li><p>publicPath</p>
<p>output.path 和 output.publicPath 都支持字符串模版，内置变量只有一个：hash 常用于 CDN 场景</p>
</li>
</ol>
<ul>
<li>Module 配置如何处理模块</li>
</ul>
<ol>
<li><p>rules</p>
<p>有三种方式配置 rules</p>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">条件匹配：test、include 、exclude、loader、options 应用规则：use 重置顺序：enforce: string &#x27;pre&#x27;|&#x27;post&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>总结 配置文件支持多种类型，可以导出一个 Function，导出一个返回 Promise 的函数，也可以导出数组，数组中有多份配置 更多配置可以参考<br><a href="https://github.com/Matthrews/webpack-demos">我的 Github</a><br><a href="https://webpack.js.org/concepts/">Webpack 官网</a></li>
</ul>
<h3 id="实战系列"><a href="#实战系列" class="headerlink" title="实战系列"></a>实战系列</h3><p>按照不同场景划分成以下几类：</p>
<h4 id="使用新语言来开发项目："><a href="#使用新语言来开发项目：" class="headerlink" title="使用新语言来开发项目："></a>使用新语言来开发项目：</h4><ol>
<li><p>使用 ES6 语言</p>
<p>配置 Babel 完成 ES6 转 ES5 和 polyfill 两件事 在 Webpack 中通过 Loader 去接入 Babel，同时也可以在根目录通过 <code>.babelrc</code>文件配置，这两者可以同时做作用</p>
</li>
<li><p>使用 TypeScript 语言</p>
<p>配置<code>tsconfig.json</code>文件 集成 Webpack 需要解决两个问题：</p>
<ul>
<li>通过 Loader 把 TypeScript 转换成 JavaScript —–推荐 awesome-typescript-loader</li>
<li>Webpack 在寻找模块对应的文件时需要尝试 ts 后缀 —-修改默认的 resolve.extensions 配置项</li>
</ul>
</li>
<li><p>使用 Flow 检查器</p>
<p>集成 Webpack 需要安装 babel-preset-flow，然后修改 <code>.babelrc</code> 配置文件，加入<code>flow</code>配置项</p>
</li>
<li><p>使用 SCSS 语言</p>
<p>使用<code>sass-loader</code>，相关配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 增加对 SCSS 文件的支持</span></span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        <span class="comment">// SCSS 文件的处理顺序为先 sass-loader 再 css-loader 再style-loader</span></span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;sass-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">工作原理如下：</span></span><br><span class="line"><span class="string">1. sass-loader把SCSS代码转成CSS后交给css-loader</span></span><br><span class="line"><span class="string">2. css-loader会找出CSS代码中的 @import 和 url() 这样的导入语句，告诉 Webpack 依赖这些资源。同时还支持 CSS Modules、压缩 CSS 等功能。处理完后再把结果交给 style-loader 去处理。</span></span><br><span class="line"><span class="string">3. style-loader 会把 CSS 代码转换成字符串后，注入到 JavaScript 代码中去，通过 JavaScript 去给 DOM 增加样式</span></span><br><span class="line"><span class="string">4. 如果你想把 CSS 代码提取到一个单独的文件而不是和 JavaScript 混在一起，可以使用ExtractTextPlugin</span></span><br><span class="line"><span class="string">5. 需要安装sass-loader css-loader style-loader node-sass(sass-loader依赖项)</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure></li>
<li><p>使用 PostCSS</p>
<p>需要安装 postcss-loader css-loader style-loader postcss-cssnext(postcss 插件)</p>
</li>
</ol>
<h5 id="使用新框架来开发项目："><a href="#使用新框架来开发项目：" class="headerlink" title="使用新框架来开发项目："></a>使用新框架来开发项目：</h5><ol start="6">
<li><p>使用 React 框架</p>
<p>安装 babel-preset-react 转换 JSX 和 Class 等 React 语法 修改 <code>.babelrc</code> 配置文件加入 <code>react</code> Presets</p>
</li>
<li><p>使用 Vue 框架</p>
</li>
<li><p>使用 Angular2 框架</p>
</li>
</ol>
<h5 id="用-Webpack-构建单页应用："><a href="#用-Webpack-构建单页应用：" class="headerlink" title="用 Webpack 构建单页应用："></a>用 Webpack 构建单页应用：</h5><ol start="9">
<li>为单页应用生成 HTML</li>
<li>管理多个单页应用</li>
</ol>
<h5 id="用-Webpack-构建不同运行环境的项目："><a href="#用-Webpack-构建不同运行环境的项目：" class="headerlink" title="用 Webpack 构建不同运行环境的项目："></a>用 Webpack 构建不同运行环境的项目：</h5><ol start="11">
<li>构建同构应用</li>
<li>构建 Electron 应用 13 . 构建 Npm 模块</li>
<li>构建离线应用</li>
</ol>
<h5 id="Webpack-结合其它工具搭配使用，各取所长："><a href="#Webpack-结合其它工具搭配使用，各取所长：" class="headerlink" title="Webpack 结合其它工具搭配使用，各取所长："></a>Webpack 结合其它工具搭配使用，各取所长：</h5><ol start="15">
<li>搭配 Npm Script</li>
<li>检查代码</li>
<li>通过 Node.js API 启动 Webpack</li>
<li>使用 Webpack Dev Middleware</li>
</ol>
<h5 id="用-Webpack-加载特殊类型的资源："><a href="#用-Webpack-加载特殊类型的资源：" class="headerlink" title="用 Webpack 加载特殊类型的资源："></a>用 Webpack 加载特殊类型的资源：</h5><ol start="19">
<li>加载图片</li>
<li>加载 SVG</li>
<li>加载 Source Map</li>
<li>实战总结</li>
</ol>
<h3 id="优化系列"><a href="#优化系列" class="headerlink" title="优化系列"></a>优化系列</h3><h3 id="原理系列"><a href="#原理系列" class="headerlink" title="原理系列"></a>原理系列</h3>]]></content>
      <categories>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>解析 webpack 核心——Loader 原理</title>
    <url>/bloger/2020/12/08/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/%E8%A7%A3%E6%9E%90%20webpack%20%E6%A0%B8%E5%BF%83%E2%80%94%E2%80%94Loader%20%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="解析-webpack-核心——Loader-原理"><a href="#解析-webpack-核心——Loader-原理" class="headerlink" title="解析 webpack 核心——Loader 原理"></a>解析 webpack 核心——Loader 原理</h1><blockquote>
<p>我们再上一次的分享中已经做出了一个简易的打包器，但是我们只能加载 JS 不能加载 CSS<br>本次分享我们给出 css 加载思路并对 css-loader 和 style-loader 进行解析</p>
</blockquote>
<h2 id="如何加载-CSS"><a href="#如何加载-CSS" class="headerlink" title="如何加载 CSS"></a>如何加载 CSS</h2><ul>
<li>思路：目前<code>bundler_1.ts</code>只能加载 JS，想要加载 CSS，就需要将 CSS 转化为 JS</li>
<li>代码：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果文件路径以.css结尾，就把CSS改为JS，并自动加载到head里</span></span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/\.css$/</span>.test(filepath)) &#123;</span><br><span class="line">  code = <span class="string">`</span></span><br><span class="line"><span class="string">         const str = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(code)&#125;</span></span></span><br><span class="line"><span class="string">         if (document) &#123;</span></span><br><span class="line"><span class="string">           const style = document.createElement(&#x27;style&#x27;)</span></span><br><span class="line"><span class="string">           style.innerHTML = str</span></span><br><span class="line"><span class="string">           style.type = &#x27;text/css&#x27;</span></span><br><span class="line"><span class="string">           document.head.appendChild(style)</span></span><br><span class="line"><span class="string">         &#125;</span></span><br><span class="line"><span class="string">         export default str</span></span><br><span class="line"><span class="string">       `</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建一个-CSS-loader"><a href="#创建一个-CSS-loader" class="headerlink" title="创建一个 CSS loader"></a>创建一个 CSS loader</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bundler_1.ts</span></span><br><span class="line"><span class="comment">// 请确保你的 Node 版本大于等于 14</span></span><br><span class="line"><span class="comment">// 请先运行 yarn 或 npm i 来安装依赖</span></span><br><span class="line"><span class="comment">// 然后使用 node -r ts-node/register 文件路径 来运行，</span></span><br><span class="line"><span class="comment">// 如果需要调试，可以加一个选项 --inspect-brk，再打开 Chrome 开发者工具，点击 Node 图标即可调试</span></span><br><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">&quot;@babel/parser&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">&quot;@babel/traverse&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; writeFileSync, readFileSync &#125; <span class="keyword">from</span> <span class="string">&quot;fs&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; resolve, relative, dirname, join &#125; <span class="keyword">from</span> <span class="string">&quot;path&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babel <span class="keyword">from</span> <span class="string">&quot;@babel/core&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; mkdir &#125; <span class="keyword">from</span> <span class="string">&quot;shelljs&quot;</span>;</span><br><span class="line"><span class="comment">// 项目名称</span></span><br><span class="line"><span class="keyword">const</span> projectName = <span class="string">&quot;project_css&quot;</span>;</span><br><span class="line"><span class="comment">// 设置根目录</span></span><br><span class="line"><span class="keyword">const</span> projectRoot = resolve(__dirname, projectName);</span><br><span class="line"><span class="comment">// 类型声明</span></span><br><span class="line">type DepRelation = &#123; <span class="attr">key</span>: string, <span class="attr">deps</span>: string[], <span class="attr">code</span>: string &#125;[];</span><br><span class="line"><span class="comment">// 初始化一个空的 depRelation，用于收集依赖</span></span><br><span class="line"><span class="keyword">const</span> depRelation: DepRelation = []; <span class="comment">// 数组！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将入口文件的绝对路径传入函数，如 D:\demo\fixture_1\index.js</span></span><br><span class="line">collectCodeAndDeps(resolve(projectRoot, <span class="string">&quot;index.js&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note：这是本次新增的代码</span></span><br><span class="line"><span class="comment">// 创建dist目录</span></span><br><span class="line"><span class="keyword">const</span> dir = <span class="string">`./<span class="subst">$&#123;projectName&#125;</span>/dist`</span>;</span><br><span class="line">mkdir(<span class="string">&quot;-p&quot;</span>, dir);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note：这是本次新增的代码</span></span><br><span class="line"><span class="comment">// 再创建bundle文件</span></span><br><span class="line">writeFileSync(join(dir, <span class="string">&quot;bundle.js&quot;</span>), generateCode());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;done&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateCode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> code = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  code +=</span><br><span class="line">    <span class="string">&quot;var depRelation = [&quot;</span> +</span><br><span class="line">    depRelation</span><br><span class="line">      .map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; key, deps, code &#125; = item;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`&#123;</span></span><br><span class="line"><span class="string">      key: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(key)&#125;</span>,</span></span><br><span class="line"><span class="string">      deps: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(deps)&#125;</span>,</span></span><br><span class="line"><span class="string">      code: function(require, module, exports)&#123;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;code&#125;</span></span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;`</span>;</span><br><span class="line">      &#125;)</span><br><span class="line">      .join(<span class="string">&quot;,&quot;</span>) +</span><br><span class="line">    <span class="string">&quot;];\n&quot;</span>;</span><br><span class="line">  code += <span class="string">&quot;var modules = &#123;&#125;;\n&quot;</span>;</span><br><span class="line">  code += <span class="string">`execute(depRelation[0].key)\n`</span>;</span><br><span class="line">  code += <span class="string">`</span></span><br><span class="line"><span class="string">  function execute(key) &#123;</span></span><br><span class="line"><span class="string">    if (modules[key]) &#123; return modules[key] &#125;</span></span><br><span class="line"><span class="string">    var item = depRelation.find(i =&gt; i.key === key)</span></span><br><span class="line"><span class="string">    if (!item) &#123; throw new Error(\`\$&#123;item&#125; is not found\`) &#125;</span></span><br><span class="line"><span class="string">    var pathToKey = (path) =&gt; &#123;</span></span><br><span class="line"><span class="string">      var dirname = key.substring(0, key.lastIndexOf(&#x27;/&#x27;) + 1)</span></span><br><span class="line"><span class="string">      var projectPath = (dirname + path).replace(\/\\.\\\/\/g, &#x27;&#x27;).replace(\/\\\/\\\/\/, &#x27;/&#x27;)</span></span><br><span class="line"><span class="string">      return projectPath</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    var require = (path) =&gt; &#123;</span></span><br><span class="line"><span class="string">      return execute(pathToKey(path))</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    modules[key] = &#123; __esModule: true &#125;</span></span><br><span class="line"><span class="string">    var module = &#123; exports: modules[key] &#125;</span></span><br><span class="line"><span class="string">    item.code(require, module, module.exports)</span></span><br><span class="line"><span class="string">    return modules[key]</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">  <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectCodeAndDeps</span>(<span class="params">filepath: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> key = getProjectPath(filepath); <span class="comment">// 文件的项目路径，如 index.js</span></span><br><span class="line">  <span class="keyword">if</span> (depRelation.find(<span class="function">(<span class="params">i</span>) =&gt;</span> i.key === key)) &#123;</span><br><span class="line">    <span class="comment">// 注意，重复依赖不一定是循环依赖</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取文件内容，将内容放至 depRelation</span></span><br><span class="line">  <span class="keyword">let</span> code = readFileSync(filepath).toString();</span><br><span class="line">  <span class="comment">// Note：这是本次新增的代码</span></span><br><span class="line">  <span class="comment">// 如果文件路径以.css结尾，就把CSS改为JS，并自动加载到head里</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/\.css$/</span>.test(filepath)) &#123;</span><br><span class="line">    code = <span class="string">`</span></span><br><span class="line"><span class="string">      const str = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(code)&#125;</span></span></span><br><span class="line"><span class="string">      if (document) &#123;</span></span><br><span class="line"><span class="string">        const style = document.createElement(&#x27;style&#x27;)</span></span><br><span class="line"><span class="string">        style.innerHTML = str</span></span><br><span class="line"><span class="string">        style.type = &#x27;text/css&#x27;</span></span><br><span class="line"><span class="string">        document.head.appendChild(style)</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      export default str</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">code</span>: es5Code &#125; = babel.transform(code, &#123;</span><br><span class="line">    presets: [<span class="string">&quot;@babel/preset-env&quot;</span>],</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 初始化 depRelation[key]</span></span><br><span class="line">  <span class="keyword">const</span> item = &#123; key, <span class="attr">deps</span>: [], <span class="attr">code</span>: es5Code &#125;;</span><br><span class="line">  depRelation.push(item);</span><br><span class="line">  <span class="comment">// 将代码转为 AST</span></span><br><span class="line">  <span class="keyword">const</span> ast = parse(code, &#123; <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span> &#125;);</span><br><span class="line">  <span class="comment">// 分析文件依赖，将内容放至 depRelation</span></span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    enter: <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (path.node.type === <span class="string">&quot;ImportDeclaration&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// path.node.source.value 往往是一个相对路径，如 ./a.js，需要先把它转为一个绝对路径</span></span><br><span class="line">        <span class="keyword">const</span> depAbsolutePath = resolve(</span><br><span class="line">          dirname(filepath),</span><br><span class="line">          path.node.source.value</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 然后转为项目路径</span></span><br><span class="line">        <span class="keyword">const</span> depProjectPath = getProjectPath(depAbsolutePath);</span><br><span class="line">        <span class="comment">// 把依赖写进 depRelation</span></span><br><span class="line">        item.deps.push(depProjectPath);</span><br><span class="line">        collectCodeAndDeps(depAbsolutePath);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件相对于根目录的相对路径</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProjectPath</span>(<span class="params">path: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> relative(projectRoot, path).replace(<span class="regexp">/\\/g</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// project_css/index.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&#x27;./b.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./style.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.getB())</span><br><span class="line"><span class="built_in">console</span>.log(b.getA())</span><br><span class="line"></span><br><span class="line"><span class="comment">// project_css/a.js</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&#x27;./b.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  value: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  getB: <span class="function">() =&gt;</span> b.value + <span class="string">&#x27; from a.js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment">// project_css/b.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  value: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  getA: <span class="function">() =&gt;</span> a.value + <span class="string">&#x27; from b.js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">// project_css/style.css</span></span><br><span class="line">body &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行<code>node -r ts-node/register bundler_1.ts</code>打包成功后<code>project_css</code>目录下会新增文件<code>bundle.js</code></p>
<p>我们可以看到<code>CSS</code>部分代码成功打包进去了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// project_css/dist/bundle.js  部分代码</span></span><br><span class="line"><span class="built_in">exports</span>[<span class="string">&quot;default&quot;</span>] = _default;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      key: <span class="string">&quot;style.css&quot;</span>,</span><br><span class="line">      deps: [],</span><br><span class="line">      code: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">module</span>, <span class="built_in">exports</span></span>)</span>&#123;</span><br><span class="line"><span class="meta">        &quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123;</span><br><span class="line">  value: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">exports</span>[<span class="string">&quot;default&quot;</span>] = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;body &#123;\r\n    color: red;\r\n&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">&#x27;style&#x27;</span>);</span><br><span class="line">  style.innerHTML = str;</span><br><span class="line">  style.type = <span class="string">&#x27;text/css&#x27;</span>;</span><br><span class="line">  <span class="built_in">document</span>.head.appendChild(style);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _default = str;</span><br><span class="line"><span class="built_in">exports</span>[<span class="string">&quot;default&quot;</span>] = _default;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>

<p>我们可以再<code>dist</code>目录下创建一个<code>index.html</code>引入打包后文件<code>bundle.js</code>浏览器运行看看效果<br><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/webpack-4.png" alt="index.html"></p>
<h2 id="Loader-长什么样"><a href="#Loader-长什么样" class="headerlink" title="Loader 长什么样"></a>Loader 长什么样</h2><blockquote>
<p>参考：<a href="https://www.webpackjs.com/contribute/writing-a-loader/">如何编写一个 loader</a></p>
</blockquote>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/102729238">如何编写一个 loader</a></p>
</blockquote>
<ul>
<li><p>loader 本质上是导出为函数的 JavaScript 模块</p>
</li>
<li><p>loader runner 会调用此函数，然后将上一个 loader 产生的结果或者资源文件传入进去</p>
</li>
<li><p>函数中的 this 作为上下文会被 webpack 填充，并且 loader runner 中包含一些实用的方法，比如可以使 loader 调用方式变为异步，或者获取 query 参数</p>
</li>
<li><p>同步 Loaders</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sync-loader.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content, map, meta</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someSyncOperation(content);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sync-loader-with-multiple-results.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content, map, meta</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.callback(<span class="literal">null</span>, someSyncOperation(content), map, meta);</span><br><span class="line">  <span class="keyword">return</span>; <span class="comment">// 当调用 callback() 函数时，总是返回 undefined</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>异步 Loaders</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// async-loader.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content, map, meta</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> callback = <span class="built_in">this</span>.async();</span><br><span class="line">  someAsyncOperation(content, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">    callback(<span class="literal">null</span>, result, map, meta);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async-loader-with-multiple-results.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content, map, meta</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> callback = <span class="built_in">this</span>.async();</span><br><span class="line">  someAsyncOperation(content, <span class="function"><span class="keyword">function</span> (<span class="params">err, result, sourceMaps, meta</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">    callback(<span class="literal">null</span>, result, sourceMaps, meta);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回 Buffer 的 Loaders</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// raw-loader.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>&#123;</span><br><span class="line">  assert(content <span class="keyword">instanceof</span> Buffer);</span><br><span class="line">  <span class="keyword">return</span> someSyncOperation(content);</span><br><span class="line">  <span class="comment">// 返回值也可以是一个 `Buffer`</span></span><br><span class="line">  <span class="comment">// 即使不是 &quot;raw&quot;，loader 也没问题</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.raw = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>提前结束的 Pitch Loaders</li>
</ul>
<p>对于以下 use 配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        use: [<span class="string">&quot;a-loader&quot;</span>, <span class="string">&quot;b-loader&quot;</span>, <span class="string">&quot;c-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将会发生这些步骤：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">|- a-loader `pitch`</span><br><span class="line">  |- b-loader `pitch`</span><br><span class="line">    |- c-loader `pitch`</span><br><span class="line">      |- requested module is picked up as a dependency</span><br><span class="line">    |- c-loader normal execution</span><br><span class="line">  |- b-loader normal execution</span><br><span class="line">|- a-loader normal execution</span><br></pre></td></tr></table></figure>

<p>简单来说，pitch 钩子函数同步 data 数据和共享前面信息, 如果某个 loader 在 pitch 方法中给出一个结果，那么这个过程会回过身来，并跳过剩下的 loader</p>
<p>如果 b-loader 的 pitch 方法返回了一些东西：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someSyncOperation(content);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.pitch = <span class="function"><span class="keyword">function</span> (<span class="params">remainingRequest, precedingRequest, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (someCondition()) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="string">&quot;module.exports = require(&quot;</span> +</span><br><span class="line">      <span class="built_in">JSON</span>.stringify(<span class="string">&quot;-!&quot;</span> + remainingRequest) +</span><br><span class="line">      <span class="string">&quot;);&quot;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的步骤将被缩短为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">|- a-loader `pitch`</span><br><span class="line">  |- b-loader `pitch` returns a module</span><br><span class="line">|- a-loader normal execution</span><br></pre></td></tr></table></figure>

<h2 id="目前-Loader-存在的问题"><a href="#目前-Loader-存在的问题" class="headerlink" title="目前 Loader 存在的问题"></a>目前 Loader 存在的问题</h2><ul>
<li>不符合单一职责原则</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优化后打包核心代码如下</span></span><br><span class="line"><span class="comment">// bundler_css_loader.ts</span></span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/\.css$/</span>.test(filepath)) &#123;</span><br><span class="line">  code = <span class="built_in">require</span>(<span class="string">&quot;./loaders/css-loader&quot;</span>)(code);</span><br><span class="line">  code = <span class="built_in">require</span>(<span class="string">&quot;./loaders/style-loader&quot;</span>)(code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// loaders/css-loader.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将CSS代码变换成JS代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>code CSS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;string&#125;</span>  <span class="variable">JS</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> transform = <span class="function">(<span class="params">code</span>) =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">  const str = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(code)&#125;</span></span></span><br><span class="line"><span class="string">  export default str</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = transform;</span><br><span class="line"></span><br><span class="line"><span class="comment">// loaders/style-loader.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将JS代码插入style标签</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>code JS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;string&#125;</span>  <span class="variable">JS</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> transform = <span class="function">(<span class="params">code</span>) =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">  if (document) &#123;</span></span><br><span class="line"><span class="string">    const style = document.createElement(&#x27;style&#x27;)</span></span><br><span class="line"><span class="string">    style.innerHTML = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(code)&#125;</span></span></span><br><span class="line"><span class="string">    style.type = &#x27;text/css&#x27;</span></span><br><span class="line"><span class="string">    document.head.appendChild(style)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  export default str</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = transform;</span><br></pre></td></tr></table></figure>

<h2 id="阅读源码前必读"><a href="#阅读源码前必读" class="headerlink" title="阅读源码前必读"></a>阅读源码前必读</h2><p><a href="https://matthrews.github.io/bloger/2020/12/08/%E7%9C%8B%E6%BA%90%E7%A0%81%E7%9A%84%E4%B8%80%E7%82%B9%E6%96%B9%E6%B3%95%E8%AE%BA/">看源码的一点方法论</a></p>
<h2 id="raw-loader-和-file-loader-源码阅读"><a href="#raw-loader-和-file-loader-源码阅读" class="headerlink" title="raw-loader 和 file-loader 源码阅读"></a>raw-loader 和 file-loader 源码阅读</h2><blockquote>
<p><a href="mailto:&#x72;&#x61;&#x77;&#x2d;&#108;&#111;&#97;&#100;&#x65;&#114;&#x40;&#48;&#x2e;&#x31;&#x2e;&#53;">&#x72;&#x61;&#x77;&#x2d;&#108;&#111;&#97;&#100;&#x65;&#114;&#x40;&#48;&#x2e;&#x31;&#x2e;&#53;</a></p>
</blockquote>
<blockquote>
<p><a href="mailto:&#x66;&#105;&#x6c;&#x65;&#45;&#108;&#111;&#x61;&#100;&#x65;&#x72;&#64;&#48;&#x2e;&#56;&#x2e;&#x32;">&#x66;&#105;&#x6c;&#x65;&#45;&#108;&#111;&#x61;&#100;&#x65;&#x72;&#64;&#48;&#x2e;&#56;&#x2e;&#x32;</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// raw-loader</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  args = args.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="built_in">this</span>.values = [args];</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;module.exports = &quot;</span> + <span class="built_in">JSON</span>.stringify(args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file-loader</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.cacheable &amp;&amp; <span class="built_in">this</span>.cacheable();</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.emitFile)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;emitFile is required from module system&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> query = loaderUtils.parseQuery(<span class="built_in">this</span>.query);</span><br><span class="line">  <span class="keyword">var</span> url = loaderUtils.interpolateName(<span class="built_in">this</span>, query.name || <span class="string">&quot;[hash].[ext]&quot;</span>, &#123;</span><br><span class="line">    context: query.context || <span class="built_in">this</span>.options.context,</span><br><span class="line">    content: content,</span><br><span class="line">    regExp: query.regExp,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">this</span>.emitFile(url, content);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;module.exports = __webpack_public_path__ + &quot;</span> + <span class="built_in">JSON</span>.stringify(url);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.raw = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h2 id="css-loader-和-style-loader-源码阅读"><a href="#css-loader-和-style-loader-源码阅读" class="headerlink" title="css-loader 和 style-loader 源码阅读"></a>css-loader 和 style-loader 源码阅读</h2><blockquote>
<p><a href="mailto:&#x73;&#x74;&#121;&#108;&#x65;&#x2d;&#108;&#111;&#97;&#100;&#101;&#x72;&#x40;&#48;&#x2e;&#x31;&#51;&#46;&#48;">&#x73;&#x74;&#121;&#108;&#x65;&#x2d;&#108;&#111;&#97;&#100;&#101;&#x72;&#x40;&#48;&#x2e;&#x31;&#51;&#46;&#48;</a></p>
</blockquote>
<blockquote>
<p><a href="mailto:&#99;&#115;&#x73;&#45;&#x6c;&#111;&#97;&#x64;&#x65;&#114;&#x40;&#48;&#x2e;&#50;&#56;&#46;&#52;">&#99;&#115;&#x73;&#45;&#x6c;&#111;&#97;&#x64;&#x65;&#114;&#x40;&#48;&#x2e;&#50;&#56;&#46;&#52;</a></p>
</blockquote>
<ul>
<li>css-loader 和 style-loader 都做了什么，怎么做的？</li>
</ul>
<p>下载 style-loader 源码切换到就一点的版本，进入源码找到入口文件<code>index.js</code>，代码折叠后</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略不重要代码</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这是一个空函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.pitch = <span class="function"><span class="keyword">function</span> (<span class="params">remainingRequest</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>就简单两个函数，导出了一个空函数，并且在空函数对象上挂了一个 <code>pitch</code> 函数, 在 <code>pitch</code> 阶段完成<code>&lt;style&gt;</code>标签挂载 DOM，关于<code>pitch</code> 可以看看上文</p>
</blockquote>
<p><code>pitch</code> 函数核心代码如下, 源码注释也很清楚</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略不重要代码</span></span><br><span class="line"><span class="keyword">var</span> query = loaderUtils.parseQuery(<span class="built_in">this</span>.query);</span><br><span class="line"><span class="keyword">return</span> [</span><br><span class="line">  <span class="string">&quot;// style-loader: Adds some css to the DOM by adding a &lt;style&gt; tag&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;// load the styles&quot;</span>,</span><br><span class="line">  <span class="string">&quot;var content = require(&quot;</span> +</span><br><span class="line">    loaderUtils.stringifyRequest(<span class="built_in">this</span>, <span class="string">&quot;!!&quot;</span> + remainingRequest) +</span><br><span class="line">    <span class="string">&quot;);&quot;</span>,</span><br><span class="line">  <span class="string">&quot;if(typeof content === &#x27;string&#x27;) content = [[module.id, content, &#x27;&#x27;]];&quot;</span>,</span><br><span class="line">  <span class="string">&quot;// add the styles to the DOM&quot;</span>,</span><br><span class="line">  <span class="string">&quot;var update = require(&quot;</span> +</span><br><span class="line">    loaderUtils.stringifyRequest(</span><br><span class="line">      <span class="built_in">this</span>,</span><br><span class="line">      <span class="string">&quot;!&quot;</span> + path.join(__dirname, <span class="string">&quot;addStyles.js&quot;</span>)</span><br><span class="line">    ) +</span><br><span class="line">    <span class="string">&quot;)(content, &quot;</span> +</span><br><span class="line">    <span class="built_in">JSON</span>.stringify(query) +</span><br><span class="line">    <span class="string">&quot;);&quot;</span>,</span><br><span class="line">].join(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原理式通过 JS 将<code>&lt;style&gt;</code>标签插到 DOM 里，首先加载 style 内容，然后插入 DOM， 插入 DOM 核心实现是<code>addStyles.js</code>,其核心代码如下：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略不重要代码</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">list, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> styles = listToStyles(list);</span><br><span class="line">  addStylesToDom(styles, options);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">newList</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// update 逻辑</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，核心就是<code>addStylesToDom</code>函数，再进入就是<code>addStyle</code>函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStyleElement</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> styleElement = <span class="built_in">document</span>.createElement(<span class="string">&quot;style&quot;</span>);</span><br><span class="line">  styleElement.type = <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line">  insertStyleElement(options, styleElement);</span><br><span class="line">  <span class="keyword">return</span> styleElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addStyle</span>(<span class="params">obj, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> styleElement, update, remove;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.singleton) &#123;</span><br><span class="line">    <span class="keyword">var</span> styleIndex = singletonCounter++;</span><br><span class="line">    styleElement =</span><br><span class="line">      singletonElement || (singletonElement = createStyleElement(options));</span><br><span class="line">    update = applyToSingletonTag.bind(<span class="literal">null</span>, styleElement, styleIndex, <span class="literal">false</span>);</span><br><span class="line">    remove = applyToSingletonTag.bind(<span class="literal">null</span>, styleElement, styleIndex, <span class="literal">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    obj.sourceMap &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> URL === <span class="string">&quot;function&quot;</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> URL.createObjectURL === <span class="string">&quot;function&quot;</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> URL.revokeObjectURL === <span class="string">&quot;function&quot;</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> Blob === <span class="string">&quot;function&quot;</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> btoa === <span class="string">&quot;function&quot;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    styleElement = createLinkElement(options);</span><br><span class="line">    update = updateLink.bind(<span class="literal">null</span>, styleElement);</span><br><span class="line">    remove = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      removeStyleElement(styleElement);</span><br><span class="line">      <span class="keyword">if</span> (styleElement.href) URL.revokeObjectURL(styleElement.href);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 看到这里就够了，然后再看到createStyleElement就和我们预期的一样了</span></span><br><span class="line">    styleElement = createStyleElement(options);</span><br><span class="line">    update = applyToTag.bind(<span class="literal">null</span>, styleElement);</span><br><span class="line">    remove = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      removeStyleElement(styleElement);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update(obj);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">updateStyle</span>(<span class="params">newObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newObj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        newObj.css === obj.css &amp;&amp;</span><br><span class="line">        newObj.media === obj.media &amp;&amp;</span><br><span class="line">        newObj.sourceMap === obj.sourceMap</span><br><span class="line">      )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      update((obj = newObj));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>看到<code>createStyleElement</code>我们就清楚了 style 是如何被插入 DOM 的</p>
</blockquote>
<p>我们可以新建一个 demo 调试一下源码，进一步验证</p>
<h2 id="loader-面试题"><a href="#loader-面试题" class="headerlink" title="loader 面试题"></a>loader 面试题</h2><ul>
<li>Webpack 的 loader 是什么？<ol>
<li>webpack 自带的打包器只能支持 JS 文件</li>
<li>当我们想要加载 <code>css/less/scss/stylus/ts/md</code> 文件时，就需要用 loader</li>
<li>loader 的原理就是把文件内容包装成能运行的 JS<br>比如: 加载 css 需要用到 <code>style-loader</code> 和 <code>css-loader</code><br><code>css-loader</code> 把代码从 CSS 代码变成 export default str 形式的 JS 代码<br><code>style-loader</code> 把代码挂载到 head 里的 style 标签里</li>
<li>实力允许的话可以深入讲一下 <code>style-loader</code> 用到了 <code>pitch</code> 钩子和 <code>request</code> 对象</li>
<li>loader 和 plugin 的区别，执行顺序等</li>
<li>写过 loader 可以讲一下思路</li>
</ol>
</li>
</ul>
<blockquote>
<p>源码参考：<a href="https://github.com/Matthrews/webpack-core">https://github.com/Matthrews/webpack-core</a></p>
</blockquote>
]]></content>
      <categories>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>Webpack loader</tag>
      </tags>
  </entry>
  <entry>
    <title>解析 webpack 核心——Plugin 原理</title>
    <url>/bloger/2020/12/08/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/%E8%A7%A3%E6%9E%90%20webpack%20%E6%A0%B8%E5%BF%83%E2%80%94%E2%80%94Plugin%20%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="解析-webpack-核心——Plugin-原理"><a href="#解析-webpack-核心——Plugin-原理" class="headerlink" title="解析 webpack 核心——Plugin 原理"></a>解析 webpack 核心——Plugin 原理</h1>]]></content>
      <categories>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>Webpack plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>解析 webpack 核心——Webpack 原理</title>
    <url>/bloger/2020/12/08/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/%E8%A7%A3%E6%9E%90%20webpack%20%E6%A0%B8%E5%BF%83%E2%80%94%E2%80%94Webpack%20%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="解析-webpack-核心——Webpack-原理"><a href="#解析-webpack-核心——Webpack-原理" class="headerlink" title="解析 webpack 核心——Webpack 原理"></a>解析 webpack 核心——Webpack 原理</h1><h2 id="Webpack-要解决的两个问题"><a href="#Webpack-要解决的两个问题" class="headerlink" title="Webpack 要解决的两个问题"></a>Webpack 要解决的两个问题</h2><ul>
<li><p>编译 import 和 export 关键字</p>
</li>
<li><p>将多个文件打包成一个</p>
</li>
</ul>
<h3 id="如何编译-import-和-export-关键字"><a href="#如何编译-import-和-export-关键字" class="headerlink" title="如何编译 import 和 export 关键字"></a>如何编译 import 和 export 关键字</h3><ol>
<li>不同浏览器功能不同</li>
</ol>
<ul>
<li>现代浏览器可以通过<code>&lt;script type=&quot;module&quot;&gt;来支持 import/export</code></li>
<li><code>IE 8~15</code>不支持 <code>import/export</code></li>
</ul>
<ol start="2">
<li>兼容策略</li>
</ol>
<ul>
<li><p>激进兼容策略 把代码全部放到<code>&lt;script type=&quot;module&quot;&gt;</code>里面</p>
</li>
<li><p>缺点 不被<code>IE 8~15</code>支持；而且会导致文件请求过多</p>
</li>
<li><p>平稳兼容策略 把关键字转译为普通代码(通过转译函数完成)，并把所有文件打包成一个文件</p>
</li>
<li><p>缺点 需要写复杂代码来完成这件事情</p>
</li>
</ul>
<ol start="3">
<li>那么怎么写这个转译函数？</li>
</ol>
<ul>
<li><p><code>@babel/core</code>已经帮我们做了</p>
</li>
<li><p>示例</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// project_1/index.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&#x27;./b.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.getB())</span><br><span class="line"><span class="built_in">console</span>.log(b.getA())</span><br><span class="line"></span><br><span class="line"><span class="comment">// project_1/a.js</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&#x27;./b.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  value: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  getB: <span class="function">() =&gt;</span> b.value + <span class="string">&#x27; from a.js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment">// project_1/b.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  value: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  getA: <span class="function">() =&gt;</span> a.value + <span class="string">&#x27; from b.js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> b</span><br></pre></td></tr></table></figure>

<p>执行<code>node -r ts-node/register bundler_1.ts</code>结果如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">duplicated dependency: a.js</span><br><span class="line">duplicated dependency: b.js</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&#x27;index.js&#x27;</span>: &#123;</span><br><span class="line">    deps: [ <span class="string">&#x27;a.js&#x27;</span>, <span class="string">&#x27;b.js&#x27;</span> ],</span><br><span class="line">    code: <span class="string">&#x27;&quot;use strict&quot;;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;var _a = _interopRequireDefault(require(&quot;./a.js&quot;));\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;var _b = _interopRequireDefault(require(&quot;./b.js&quot;));\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; &quot;default&quot;: obj &#125;; &#125;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;console.log(_a[&quot;default&quot;].getB());\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;console.log(_b[&quot;default&quot;].getA());&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;a.js&#x27;</span>: &#123;</span><br><span class="line">    deps: [ <span class="string">&#x27;b.js&#x27;</span> ],</span><br><span class="line">    code: <span class="string">&#x27;&quot;use strict&quot;;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;Object.defineProperty(exports, &quot;__esModule&quot;, &#123;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;  value: true\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;&#125;);\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;exports[&quot;default&quot;] = void 0;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;var _b = _interopRequireDefault(require(&quot;./b.js&quot;));\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; &quot;default&quot;: obj &#125;; &#125;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;var a = &#123;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&quot;  value: &#x27;a&#x27;,\n&quot;</span> +</span><br><span class="line">      <span class="string">&#x27;  getB: function getB() &#123;\n&#x27;</span> +</span><br><span class="line">      <span class="string">`    return _b[&quot;default&quot;].value + &#x27; from a.js&#x27;;\n`</span> +</span><br><span class="line">      <span class="string">&#x27;  &#125;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;&#125;;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;var _default = a;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;exports[&quot;default&quot;] = _default;&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;b.js&#x27;</span>: &#123;</span><br><span class="line">    deps: [ <span class="string">&#x27;a.js&#x27;</span> ],</span><br><span class="line">    code: <span class="string">&#x27;&quot;use strict&quot;;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;Object.defineProperty(exports, &quot;__esModule&quot;, &#123;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;  value: true\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;&#125;);\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;exports[&quot;default&quot;] = void 0;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;var _a = _interopRequireDefault(require(&quot;./a.js&quot;));\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; &quot;default&quot;: obj &#125;; &#125;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;var b = &#123;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&quot;  value: &#x27;b&#x27;,\n&quot;</span> +</span><br><span class="line">      <span class="string">&#x27;  getA: function getA() &#123;\n&#x27;</span> +</span><br><span class="line">      <span class="string">`    return _a[&quot;default&quot;].value + &#x27; from b.js&#x27;;\n`</span> +</span><br><span class="line">      <span class="string">&#x27;  &#125;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;&#125;;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;var _default = b;\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;exports[&quot;default&quot;] = _default;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>核心代码如下</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;); <span class="comment">// 疑惑1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>[<span class="string">&quot;default&quot;</span>] = <span class="keyword">void</span> <span class="number">0</span>; <span class="comment">// 疑惑2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _b = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">&quot;./b.js&quot;</span>)); <span class="comment">// 细节1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 细节1</span></span><br><span class="line">  <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;; <span class="comment">// 细节1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  value: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">  getB: <span class="function"><span class="keyword">function</span> <span class="title">getB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _b[<span class="string">&quot;default&quot;</span>].value + <span class="string">&quot; from a.js&quot;</span>; <span class="comment">// 细节1</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _default = a; <span class="comment">// 细节2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>[<span class="string">&quot;default&quot;</span>] = _default; <span class="comment">// 细节2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 疑惑1</span></span><br><span class="line"><span class="comment">// Object.defineProperty(exports, &quot;__esModule&quot;, &#123; value: true &#125;)等同于exports.__esModule = true</span></span><br><span class="line"><span class="comment">// ESM与CJS区分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 疑惑2</span></span><br><span class="line"><span class="comment">// exports[&quot;default&quot;] = void 0;等同于exports[&quot;default&quot;] = undefined</span></span><br><span class="line"><span class="comment">// 清空exports[&quot;default&quot;]的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 细节1</span></span><br><span class="line"><span class="comment">// import b from &#x27;./b.js&#x27; 变成了</span></span><br><span class="line"><span class="comment">// var _b = _interopRequireDefault(require(&quot;./b.js&quot;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.value 变成了</span></span><br><span class="line"><span class="comment">// _b[&#x27;default&#x27;].value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释 _interopRequireDefault(module)</span></span><br><span class="line"><span class="comment">// _ 下划线前缀是为了避免与其他变量重名</span></span><br><span class="line"><span class="comment">// 该函数的意图是给模块添加 &#x27;default&#x27;</span></span><br><span class="line"><span class="comment">// 为什么要加 default：CommonJS 模块没有默认导出，加上方便兼容</span></span><br><span class="line"><span class="comment">// 内部实现：return m &amp;&amp; m.__esModule ? m : &#123; &quot;default&quot;: m &#125;</span></span><br><span class="line"><span class="comment">// 其他 _interop 开头的函数大多都是为了兼容旧代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 细节2</span></span><br><span class="line"><span class="comment">// var _default = a; exports[&quot;default&quot;] = _default;</span></span><br><span class="line"><span class="comment">// 相当于exports[&quot;default&quot;] = a</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>总结</li>
</ol>
<ul>
<li><p>import 关键字会变成 require 函数</p>
</li>
<li><p>export 关键字会变成 exports 对象</p>
</li>
<li><p>本质：ESModule 语法变成了 CommonJS 规则</p>
</li>
<li><p>但是目前我们不知道 require 函数怎么写，先不管，假设 require 已经写好了</p>
</li>
</ul>
<h3 id="如何将多个文件打包成一个"><a href="#如何将多个文件打包成一个" class="headerlink" title="如何将多个文件打包成一个"></a>如何将多个文件打包成一个</h3><ol>
<li>打包后的文件会是什么样子的？</li>
</ol>
<ul>
<li><p>肯定包含所有模块，并且能执行所有模块</p>
</li>
<li><p>预想如下</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> depRelation = [</span><br><span class="line">  &#123;<span class="attr">key</span>: <span class="string">&#x27;index.js&#x27;</span>, <span class="attr">deps</span>: [<span class="string">&#x27;a.js&#x27;</span>, <span class="string">&#x27;b.js&#x27;</span>], <span class="attr">code</span>: <span class="keyword">function</span>... &#125;,</span><br><span class="line">  &#123;<span class="attr">key</span>: <span class="string">&#x27;a.js&#x27;</span>, <span class="attr">deps</span>: [<span class="string">&#x27;b.js&#x27;</span>], <span class="attr">code</span>: <span class="keyword">function</span>... &#125;,</span><br><span class="line">  &#123;<span class="attr">key</span>: <span class="string">&#x27;b.js&#x27;</span>, <span class="attr">deps</span>: [<span class="string">&#x27;a.js&#x27;</span>], <span class="attr">code</span>: <span class="keyword">function</span>... &#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 为什么把 depRelation 从对象改为数组？</span></span><br><span class="line"><span class="comment">// 因为数组的第一项就是入口，而对象没有第一项的概念</span></span><br><span class="line">execute(depRelation[<span class="number">0</span>].key) <span class="comment">// 执行入口文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> item = depRelation.find(<span class="function"><span class="params">i</span> =&gt;</span> i.key === key)</span><br><span class="line">  item.code(???) <span class="comment">// 执行 item 的代码，因此 code 最好是个函数，方便执行</span></span><br><span class="line">  <span class="comment">// 但是目前还不知道要传什么参数给 code</span></span><br><span class="line">  <span class="comment">// 代码待完善......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>现在有三个问题待解决</p>
<ul>
<li><p>depRelation 是对象，需要变成一个数组</p>
</li>
<li><p>code 是字符串，需要变成一个函数, 函数遵循 CJS2 规范</p>
</li>
<li><p>execute 函数待完善</p>
</li>
</ul>
</li>
<li><p>解决上述第一个问题</p>
<p>将</p>
<p><code>depRelation[key] = &#123; deps: [], code: es5Code &#125;</code></p>
<p>改为了</p>
<p><code>const item = &#123; key, deps: [], code: es5Code &#125; depRelation.push(item)</code></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bundler_2.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请确保你的 Node 版本大于等于 14</span></span><br><span class="line"><span class="comment">// 请先运行 yarn 或 npm i 来安装依赖</span></span><br><span class="line"><span class="comment">// 然后使用 node -r ts-node/register 文件路径 来运行，</span></span><br><span class="line"><span class="comment">// 如果需要调试，可以加一个选项 --inspect-brk，再打开 Chrome 开发者工具，点击 Node 图标即可调试</span></span><br><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">&quot;@babel/parser&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">&quot;@babel/traverse&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; readFileSync &#125; <span class="keyword">from</span> <span class="string">&quot;fs&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; resolve, relative, dirname &#125; <span class="keyword">from</span> <span class="string">&quot;path&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babel <span class="keyword">from</span> <span class="string">&quot;@babel/core&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置根目录</span></span><br><span class="line"><span class="keyword">const</span> projectRoot = resolve(__dirname, <span class="string">&quot;project_1&quot;</span>);</span><br><span class="line"><span class="comment">// 类型声明</span></span><br><span class="line">type DepRelation = &#123; <span class="attr">key</span>: string, <span class="attr">deps</span>: string[], <span class="attr">code</span>: string &#125;[];</span><br><span class="line"><span class="comment">// 初始化一个空的 depRelation，用于收集依赖</span></span><br><span class="line"><span class="keyword">const</span> depRelation: DepRelation = []; <span class="comment">// 数组！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将入口文件的绝对路径传入函数，如 D:\demo\fixture_1\index.js</span></span><br><span class="line">collectCodeAndDeps(resolve(projectRoot, <span class="string">&quot;index.js&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(depRelation);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;done&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectCodeAndDeps</span>(<span class="params">filepath: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> key = getProjectPath(filepath); <span class="comment">// 文件的项目路径，如 index.js</span></span><br><span class="line">  <span class="keyword">if</span> (depRelation.find(<span class="function">(<span class="params">i</span>) =&gt;</span> i.key === key)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">`duplicated dependency: <span class="subst">$&#123;key&#125;</span>`</span>); <span class="comment">// 注意，重复依赖不一定是循环依赖</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取文件内容，将内容放至 depRelation</span></span><br><span class="line">  <span class="keyword">const</span> code = readFileSync(filepath).toString();</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">code</span>: es5Code &#125; = babel.transform(code, &#123;</span><br><span class="line">    presets: [<span class="string">&quot;@babel/preset-env&quot;</span>],</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 初始化 depRelation[key]</span></span><br><span class="line">  <span class="keyword">const</span> item = &#123; key, <span class="attr">deps</span>: [], <span class="attr">code</span>: es5Code &#125;;</span><br><span class="line">  depRelation.push(item);</span><br><span class="line">  <span class="comment">// 将代码转为 AST</span></span><br><span class="line">  <span class="keyword">const</span> ast = parse(code, &#123; <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span> &#125;);</span><br><span class="line">  <span class="comment">// 分析文件依赖，将内容放至 depRelation</span></span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    enter: <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (path.node.type === <span class="string">&quot;ImportDeclaration&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// path.node.source.value 往往是一个相对路径，如 ./a.js，需要先把它转为一个绝对路径</span></span><br><span class="line">        <span class="keyword">const</span> depAbsolutePath = resolve(</span><br><span class="line">          dirname(filepath),</span><br><span class="line">          path.node.source.value</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 然后转为项目路径</span></span><br><span class="line">        <span class="keyword">const</span> depProjectPath = getProjectPath(depAbsolutePath);</span><br><span class="line">        <span class="comment">// 把依赖写进 depRelation</span></span><br><span class="line">        item.deps.push(depProjectPath);</span><br><span class="line">        collectCodeAndDeps(depAbsolutePath);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件相对于根目录的相对路径</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProjectPath</span>(<span class="params">path: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> relative(projectRoot, path).replace(<span class="regexp">/\\/g</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以执行<code>node -r ts-node/register bundler_2.ts</code>看看</p>
<ul>
<li><p>解决上述第二个问题</p>
<ul>
<li><p>把 code 字符串外面包一个 <code>function(require, module, exports)&#123;...&#125;</code></p>
</li>
<li><p>执行<code>node project_2/string_code_to_function.js</code>把<code>&#123;code: $&#123;code2&#125;&#125;</code>写到文件<code>project_2/result_fun.json</code>里</p>
</li>
<li><p>最终文件里面的 code 就是函数, 代码参见<code>project_2</code></p>
</li>
</ul>
</li>
<li><p>解决上述第三个问题</p>
<ul>
<li><p>代码参考<code>dist.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dist.js</span></span><br><span class="line"><span class="keyword">var</span> depRelation = [&#123;</span><br><span class="line">  key: <span class="string">&#x27;index.js&#x27;</span>,</span><br><span class="line">  deps: [<span class="string">&#x27;a.js&#x27;</span>, <span class="string">&#x27;b.js&#x27;</span>],</span><br><span class="line">  code: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">module</span>, <span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _a = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _b = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="string">&#x27;default&#x27;</span>: obj &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(_a[<span class="string">&#x27;default&#x27;</span>].getB())</span><br><span class="line">    <span class="built_in">console</span>.log(_b[<span class="string">&#x27;default&#x27;</span>].getA())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  key: <span class="string">&#x27;a.js&#x27;</span>,</span><br><span class="line">  deps: [<span class="string">&#x27;b.js&#x27;</span>],</span><br><span class="line">  code: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">module</span>, <span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&#x27;__esModule&#x27;</span>, &#123;</span><br><span class="line">      value: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">exports</span>[<span class="string">&#x27;default&#x27;</span>] = <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _b = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="string">&#x27;default&#x27;</span>: obj &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = &#123;</span><br><span class="line">      value: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">      getB: <span class="function"><span class="keyword">function</span> <span class="title">getB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _b[<span class="string">&#x27;default&#x27;</span>].value + <span class="string">&#x27; from a.js&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> _default = a</span><br><span class="line">    <span class="built_in">exports</span>[<span class="string">&#x27;default&#x27;</span>] = _default</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  key: <span class="string">&#x27;b.js&#x27;</span>,</span><br><span class="line">  deps: [<span class="string">&#x27;a.js&#x27;</span>],</span><br><span class="line">  code: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">module</span>, <span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&#x27;__esModule&#x27;</span>, &#123;</span><br><span class="line">      value: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">exports</span>[<span class="string">&#x27;default&#x27;</span>] = <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _a = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="string">&#x27;default&#x27;</span>: obj &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> b = &#123;</span><br><span class="line">      value: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">      getA: <span class="function"><span class="keyword">function</span> <span class="title">getA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _a[<span class="string">&#x27;default&#x27;</span>].value + <span class="string">&#x27; from b.js&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> _default = b</span><br><span class="line">    <span class="built_in">exports</span>[<span class="string">&#x27;default&#x27;</span>] = _default</span><br><span class="line">  &#125;</span><br><span class="line">&#125;]</span><br><span class="line"><span class="keyword">var</span> modules = &#123;&#125;</span><br><span class="line">execute(depRelation[<span class="number">0</span>].key)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果已经 require 过，就直接返回上次的结果</span></span><br><span class="line">  <span class="keyword">if</span> (modules[key]) &#123;</span><br><span class="line">    <span class="keyword">return</span> modules[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找到要执行的项目</span></span><br><span class="line">  <span class="keyword">var</span> item = depRelation.find(<span class="function"><span class="params">i</span> =&gt;</span> i.key === key)</span><br><span class="line">  <span class="comment">// 找不到就报错，中断执行</span></span><br><span class="line">  <span class="keyword">if</span> (!item) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;item&#125;</span> is not found`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把相对路径变成项目路径</span></span><br><span class="line">  <span class="keyword">var</span> pathToKey = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dirname = key.substring(<span class="number">0</span>, key.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> projectPath = (dirname + path).replace(<span class="regexp">/\.\//g</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="regexp">/\/\//</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> projectPath</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建 require 函数</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">require</span> = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> execute(pathToKey(path))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化当前模块</span></span><br><span class="line">  modules[key] = &#123; <span class="attr">__esModule</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  <span class="comment">// 初始化 module 方便 code 往 module.exports 上添加属性</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = &#123; <span class="attr">exports</span>: modules[key] &#125;</span><br><span class="line">  <span class="comment">// 调用 code 函数，往 module.exports 上添加导出属性</span></span><br><span class="line">  <span class="comment">// 第二个参数 module 大部分时候是无用的，主要用于兼容旧代码</span></span><br><span class="line">  item.code(<span class="built_in">require</span>, <span class="built_in">module</span>, <span class="built_in">module</span>.exports)</span><br><span class="line">  <span class="comment">// 返回当前模块</span></span><br><span class="line">  <span class="keyword">return</span> modules[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>执行<code>node dist.js</code>得到结果</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">b <span class="keyword">from</span> a.js</span><br><span class="line">a <span class="keyword">from</span> b.js</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><p>如何自动生成最终文件？</p>
<ul>
<li><p>模板拼接——<code>var dist = &quot;&quot;; dist += content; writeFileSync(&#39;dist.js&#39;, dist)</code></p>
</li>
<li><p>代码参考<code>bundler_3.ts</code>, 最终生成文件<code>dist_auto.js</code>和<code>dist.js</code>相差无几</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bundler_3.ts</span></span><br><span class="line"><span class="comment">// 请确保你的 Node 版本大于等于 14</span></span><br><span class="line"><span class="comment">// 请先运行 yarn 或 npm i 来安装依赖</span></span><br><span class="line"><span class="comment">// 然后使用 node -r ts-node/register 文件路径 来运行，</span></span><br><span class="line"><span class="comment">// 如果需要调试，可以加一个选项 --inspect-brk，再打开 Chrome 开发者工具，点击 Node 图标即可调试</span></span><br><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">&#x27;@babel/parser&#x27;</span></span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">&#x27;@babel/traverse&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; writeFileSync, readFileSync &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; resolve, relative, dirname &#125; <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babel <span class="keyword">from</span> <span class="string">&#x27;@babel/core&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置根目录</span></span><br><span class="line"><span class="keyword">const</span> projectRoot = resolve(__dirname, <span class="string">&#x27;project_1&#x27;</span>)</span><br><span class="line"><span class="comment">// 类型声明</span></span><br><span class="line">type DepRelation = &#123; <span class="attr">key</span>: string, <span class="attr">deps</span>: string[], <span class="attr">code</span>: string &#125;[]</span><br><span class="line"><span class="comment">// 初始化一个空的 depRelation，用于收集依赖</span></span><br><span class="line"><span class="keyword">const</span> depRelation: DepRelation = [] <span class="comment">// 数组！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将入口文件的绝对路径传入函数，如 D:\demo\fixture_1\index.js</span></span><br><span class="line">collectCodeAndDeps(resolve(projectRoot, <span class="string">&#x27;index.js&#x27;</span>))</span><br><span class="line"></span><br><span class="line">writeFileSync(<span class="string">&#x27;dist_auto.js&#x27;</span>, generateCode())</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;done&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateCode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> code = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  code += <span class="string">&#x27;var depRelation = [&#x27;</span> + depRelation.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; key, deps, code &#125; = item</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&#123;</span></span><br><span class="line"><span class="string">      key: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(key)&#125;</span>, </span></span><br><span class="line"><span class="string">      deps: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(deps)&#125;</span>,</span></span><br><span class="line"><span class="string">      code: function(require, module, exports)&#123;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;code&#125;</span></span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;`</span></span><br><span class="line">  &#125;).join(<span class="string">&#x27;,&#x27;</span>) + <span class="string">&#x27;];\n&#x27;</span></span><br><span class="line">  code += <span class="string">&#x27;var modules = &#123;&#125;;\n&#x27;</span></span><br><span class="line">  code += <span class="string">`execute(depRelation[0].key)\n`</span></span><br><span class="line">  code += <span class="string">`</span></span><br><span class="line"><span class="string">  function execute(key) &#123;</span></span><br><span class="line"><span class="string">    if (modules[key]) &#123; return modules[key] &#125;</span></span><br><span class="line"><span class="string">    var item = depRelation.find(i =&gt; i.key === key)</span></span><br><span class="line"><span class="string">    if (!item) &#123; throw new Error(\`\$&#123;item&#125; is not found\`) &#125;</span></span><br><span class="line"><span class="string">    var pathToKey = (path) =&gt; &#123;</span></span><br><span class="line"><span class="string">      var dirname = key.substring(0, key.lastIndexOf(&#x27;/&#x27;) + 1)</span></span><br><span class="line"><span class="string">      var projectPath = (dirname + path).replace(\/\\.\\\/\/g, &#x27;&#x27;).replace(\/\\\/\\\/\/, &#x27;/&#x27;)</span></span><br><span class="line"><span class="string">      return projectPath</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    var require = (path) =&gt; &#123;</span></span><br><span class="line"><span class="string">      return execute(pathToKey(path))</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    modules[key] = &#123; __esModule: true &#125;</span></span><br><span class="line"><span class="string">    var module = &#123; exports: modules[key] &#125;</span></span><br><span class="line"><span class="string">    item.code(require, module, module.exports)</span></span><br><span class="line"><span class="string">    return modules[key]</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">return</span> code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectCodeAndDeps</span>(<span class="params">filepath: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> key = getProjectPath(filepath) <span class="comment">// 文件的项目路径，如 index.js</span></span><br><span class="line">  <span class="keyword">if</span> (depRelation.find(<span class="function"><span class="params">i</span> =&gt;</span> i.key === key)) &#123;</span><br><span class="line">    <span class="comment">// 注意，重复依赖不一定是循环依赖</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取文件内容，将内容放至 depRelation</span></span><br><span class="line">  <span class="keyword">const</span> code = readFileSync(filepath).toString()</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">code</span>: es5Code &#125; = babel.transform(code, &#123;</span><br><span class="line">    presets: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 初始化 depRelation[key]</span></span><br><span class="line">  <span class="keyword">const</span> item = &#123; key, <span class="attr">deps</span>: [], <span class="attr">code</span>: es5Code &#125;</span><br><span class="line">  depRelation.push(item)</span><br><span class="line">  <span class="comment">// 将代码转为 AST</span></span><br><span class="line">  <span class="keyword">const</span> ast = parse(code, &#123; <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span> &#125;)</span><br><span class="line">  <span class="comment">// 分析文件依赖，将内容放至 depRelation</span></span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    enter: <span class="function"><span class="params">path</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (path.node.type === <span class="string">&#x27;ImportDeclaration&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// path.node.source.value 往往是一个相对路径，如 ./a.js，需要先把它转为一个绝对路径</span></span><br><span class="line">        <span class="keyword">const</span> depAbsolutePath = resolve(dirname(filepath), path.node.source.value)</span><br><span class="line">        <span class="comment">// 然后转为项目路径</span></span><br><span class="line">        <span class="keyword">const</span> depProjectPath = getProjectPath(depAbsolutePath)</span><br><span class="line">        <span class="comment">// 把依赖写进 depRelation</span></span><br><span class="line">        item.deps.push(depProjectPath)</span><br><span class="line">        collectCodeAndDeps(depAbsolutePath)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件相对于根目录的相对路径</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProjectPath</span>(<span class="params">path: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> relative(projectRoot, path).replace(<span class="regexp">/\\/g</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="简易打包器"><a href="#简易打包器" class="headerlink" title="简易打包器"></a>简易打包器</h3><p>至此，我们就实现了一个简易打包器，但是存在如下问题</p>
<ul>
<li><p>生成的代码中有多个重复的<code>_interopXXX</code>函数</p>
</li>
<li><p>只能引入和运行 JS 文件</p>
</li>
<li><p>只能理解 import，无法理解 require</p>
</li>
<li><p>不支持插件</p>
</li>
<li><p>不支持配置入口文件和 dist 文件名</p>
</li>
</ul>
<blockquote>
<p>源码参考：<a href="https://github.com/Matthrews/webpack-core">https://github.com/Matthrews/webpack-core</a></p>
</blockquote>
]]></content>
      <categories>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>Webpack 打包</tag>
      </tags>
  </entry>
  <entry>
    <title>看源码的一点方法论</title>
    <url>/bloger/2020/12/08/%E6%96%B9%E6%B3%95%E8%AE%BA/%E7%9C%8B%E6%BA%90%E7%A0%81%E7%9A%84%E4%B8%80%E7%82%B9%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="看-webpack-源码总结的一点方法论"><a href="#看-webpack-源码总结的一点方法论" class="headerlink" title="看 webpack 源码总结的一点方法论"></a>看 webpack 源码总结的一点方法论</h1><h2 id="用到的工具"><a href="#用到的工具" class="headerlink" title="用到的工具"></a>用到的工具</h2><ol>
<li>WebStorm</li>
</ol>
<ul>
<li>Collapse All 功能</li>
<li>Go To Declaration or Usages 功能</li>
<li>Back 功能</li>
<li>Forward 功能</li>
<li>按两下 Shift 搜索功能名</li>
<li>可获悉快捷键</li>
</ul>
<ol start="2">
<li>VSCode</li>
</ol>
<ul>
<li>Fold All 功能</li>
<li>Go To Definition 功能</li>
<li>Go Back 功能</li>
<li>Go Forward 功能</li>
<li>按 Ctrl+Shift+P 搜索功能名</li>
<li>可获悉快捷键</li>
</ul>
<h2 id="准备代码"><a href="#准备代码" class="headerlink" title="准备代码"></a>准备代码</h2><ol>
<li>使用 webpack</li>
</ol>
<ul>
<li>创建一个 demo 项目，用来调试 webpack 和 webpack-cli</li>
<li>运行 webpack-cli 将 src/index.js 打包为 dist/main.js</li>
</ul>
<ol start="2">
<li>下载 webpack</li>
</ol>
<ul>
<li>从 GitHub 下载 webpack 的源码，切换至 v5.10.1</li>
<li>从 GitHub 下载 webpack-cli 的源码，切换至 <a href="mailto:&#119;&#x65;&#98;&#x70;&#x61;&#99;&#107;&#x2d;&#x63;&#108;&#105;&#64;&#52;&#46;&#50;&#46;&#x30;">&#119;&#x65;&#98;&#x70;&#x61;&#99;&#107;&#x2d;&#x63;&#108;&#105;&#64;&#52;&#46;&#50;&#46;&#x30;</a></li>
<li>用 IDE 的 3 个窗口分别打开这 3 个项目</li>
</ul>
<h2 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h2><ol>
<li>思路</li>
</ol>
<ul>
<li>webpack-cli 默认会执行 node_modules 里的 JS 代码</li>
<li>我们可以篡改 node_modules 里的源码</li>
<li>我们也可以用 npm link 替换 node_modules 里的目录</li>
</ul>
<ol start="2">
<li>步骤</li>
</ol>
<ul>
<li>在 webpack 项目根目录里运行 npm link</li>
<li>在 webpack-cli 项目子目录里运行 npm link</li>
<li>在 demo 项目根目录里运行 npm link webpack webpack-cli</li>
</ul>
<h2 id="开始阅读源代码"><a href="#开始阅读源代码" class="headerlink" title="开始阅读源代码"></a>开始阅读源代码</h2><ul>
<li><p>一定要带着问题去看源码，不然你会跑偏最终放弃</p>
</li>
<li><p>中间过程遇到新的问题记录下来下此再来看</p>
</li>
<li><p>只看核心代码，比如<code>if</code>块，<code>require</code>块，声明块，直接<code>return</code>的代码都可以不看</p>
</li>
<li><p>流程代码比较冗长的可以把关键步骤记录下来，到后面就可以串起来</p>
</li>
</ul>
]]></content>
      <categories>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>webpack 源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>Fiddler抓包</title>
    <url>/bloger/2021/08/02/%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3/Fiddler%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<h1 id="敬请期待"><a href="#敬请期待" class="headerlink" title="敬请期待!!!"></a>敬请期待!!!</h1>]]></content>
  </entry>
  <entry>
    <title>Wireshark抓包</title>
    <url>/bloger/2021/08/02/%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3/Wireshark%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<h1 id="敬请期待"><a href="#敬请期待" class="headerlink" title="敬请期待!!!"></a>敬请期待!!!</h1>]]></content>
  </entry>
  <entry>
    <title>自动化测试</title>
    <url>/bloger/2020/12/08/%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95Cypress/</url>
    <content><![CDATA[<h4 id="为什么需要自动化测试"><a href="#为什么需要自动化测试" class="headerlink" title="为什么需要自动化测试"></a>为什么需要自动化测试</h4><h4 id="为什么选择-Cypress"><a href="#为什么选择-Cypress" class="headerlink" title="为什么选择 Cypress"></a>为什么选择 Cypress</h4><h5 id="Pupper"><a href="#Pupper" class="headerlink" title="Pupper"></a>Pupper</h5><h5 id="Seleniuum"><a href="#Seleniuum" class="headerlink" title="Seleniuum"></a>Seleniuum</h5><h5 id="Cypress-特点"><a href="#Cypress-特点" class="headerlink" title="Cypress 特点"></a>Cypress 特点</h5><ul>
<li>Pro：界面美观友好</li>
<li>Pro：支持模拟手机</li>
<li>Pro：每一步操作截图</li>
<li>Pro：全程录屏</li>
<li>Pro：支持 debug，随时暂停</li>
<li>Pro：自动等待 UI 更新，减少异步代码</li>
</ul>
<h4 id="Cypress-怎么做"><a href="#Cypress-怎么做" class="headerlink" title="Cypress 怎么做"></a>Cypress 怎么做</h4><ul>
<li>关键在快速安装 cypress</li>
<li>vscode<ul>
<li>打开 cypress 测试窗口：<code>node_modules\.bin\cypress open</code></li>
</ul>
</li>
<li>webstorm<ul>
<li>安装 cypress 插件，然后会识别测试文件，可以单个或者多个测试</li>
<li>安装 reporter：<code>npm install -D cypress-intellij-reporter</code></li>
<li>命令行打开浏览器窗口测试：<code>cypress run --no-exit --headed --spec &quot;**/*.spec.js&quot;</code></li>
<li>全局安装了的话直接：<code>cypress open</code></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>测试框架</tag>
        <tag>Cypress</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象语法树(AST)浅析</title>
    <url>/bloger/2021/07/26/%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91(AST)%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h1 id="抽象语法树-AST-浅析"><a href="#抽象语法树-AST-浅析" class="headerlink" title="抽象语法树(AST)浅析"></a>抽象语法树(AST)浅析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们熟知的 Babel, ESlint 和 Prettier 都是基于 AST 的，那么 AST 到底是什么呢？</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> answer = <span class="number">6</span> * <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p>转换为 AST 后是这样的<a href="https://esprima.org/demo/parse.html?code=var%20answer%20=%206%20*%207;">在线查看</a>:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Program&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;body&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;VariableDeclaration&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;declarations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;VariableDeclarator&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;id&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;answer&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;loc&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;start&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">&quot;column&quot;</span>: <span class="number">4</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">&quot;end&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">&quot;column&quot;</span>: <span class="number">10</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;init&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;BinaryExpression&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;operator&quot;</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;left&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Literal&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;value&quot;</span>: <span class="number">6</span>,</span><br><span class="line">              <span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;6&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;loc&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;start&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                  <span class="attr">&quot;column&quot;</span>: <span class="number">13</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;end&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                  <span class="attr">&quot;column&quot;</span>: <span class="number">14</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;right&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Literal&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;value&quot;</span>: <span class="number">7</span>,</span><br><span class="line">              <span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;7&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;loc&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;start&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                  <span class="attr">&quot;column&quot;</span>: <span class="number">17</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;end&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                  <span class="attr">&quot;column&quot;</span>: <span class="number">18</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;loc&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;start&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">&quot;column&quot;</span>: <span class="number">13</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">&quot;end&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">&quot;column&quot;</span>: <span class="number">18</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;loc&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;start&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="attr">&quot;column&quot;</span>: <span class="number">4</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;end&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="attr">&quot;column&quot;</span>: <span class="number">18</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;var&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;loc&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;start&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;column&quot;</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;end&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;column&quot;</span>: <span class="number">19</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;sourceType&quot;</span>: <span class="string">&quot;script&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;loc&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;column&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;end&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;column&quot;</span>: <span class="number">19</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看一个：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换为 AST 后是这样的<a href="https://esprima.org/demo/parse.html?code=function%20add(a,%20b)%20%7B%0A%20%20%20%20return%20a%20+%20b%0A%7D">在线查看</a>:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Program&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;body&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;FunctionDeclaration&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;add&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;loc&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;start&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;column&quot;</span>: <span class="number">9</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;end&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;column&quot;</span>: <span class="number">12</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;params&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;loc&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;start&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="attr">&quot;column&quot;</span>: <span class="number">13</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;end&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="attr">&quot;column&quot;</span>: <span class="number">14</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;b&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;loc&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;start&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="attr">&quot;column&quot;</span>: <span class="number">16</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;end&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="attr">&quot;column&quot;</span>: <span class="number">17</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;BlockStatement&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;body&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;ReturnStatement&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;argument&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;BinaryExpression&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;operator&quot;</span>: <span class="string">&quot;+&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;left&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;loc&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;start&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;line&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">&quot;column&quot;</span>: <span class="number">11</span></span><br><span class="line">                  &#125;,</span><br><span class="line">                  <span class="attr">&quot;end&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;line&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">&quot;column&quot;</span>: <span class="number">12</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">&quot;right&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;b&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;loc&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;start&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;line&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">&quot;column&quot;</span>: <span class="number">15</span></span><br><span class="line">                  &#125;,</span><br><span class="line">                  <span class="attr">&quot;end&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;line&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">&quot;column&quot;</span>: <span class="number">16</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">&quot;loc&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;start&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;line&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                  <span class="attr">&quot;column&quot;</span>: <span class="number">11</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;end&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;line&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                  <span class="attr">&quot;column&quot;</span>: <span class="number">16</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;loc&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;start&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;line&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="attr">&quot;column&quot;</span>: <span class="number">4</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">&quot;end&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;line&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="attr">&quot;column&quot;</span>: <span class="number">16</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;loc&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;start&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;column&quot;</span>: <span class="number">19</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;end&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;line&quot;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">&quot;column&quot;</span>: <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;generator&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;expression&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;async&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;loc&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;start&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;column&quot;</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;end&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;line&quot;</span>: <span class="number">3</span>,</span><br><span class="line">          <span class="attr">&quot;column&quot;</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;sourceType&quot;</span>: <span class="string">&quot;script&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;loc&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;column&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;end&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;line&quot;</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="attr">&quot;column&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果把 JavsScript 看作一台机器，那么 AST 就是描述这台机器构成的最小单元集合，将这些最小单元通过一定的方式衔接在一起，这个台机器就能运转</p>
</blockquote>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>基于以上的象形解释，不难看到 AST 就是一棵标准的语法树结构，遍历树节点我们就可以修剪这个棵树, 最终将修剪后得树交给编译器。比如通过 <a href="https://www.npmjs.com/package/recast">recast</a> 我们就可以轻松操纵 AST 以达到我们的意愿</p>
<p>可以预见，基于 AST 我们可以做到以下事情：</p>
<ul>
<li><p>静态分析工具</p>
<p>比如 ESLint，可以格式化，可以检查代码漏洞</p>
</li>
<li><p>元资产，基于元资产可以做文档输出，做可视化输出，做数据库存储并二次消费等</p>
<p>比如<a href="https://www.npmjs.com/package/typescript-doc-gen">typescript-doc-gen</a>可以快速将 TSX interface 转成 Markdown，<br><a href="http://documentation.js.org/">documentation</a>使用 babel 输出漂亮的多格式文档，<a href="https://github.com/SBoudrias/AST-query">AST Query</a>让你想查询数据库一样操作 AST</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/babel/babylon/blob/master/ast/spec.md#node-objects">Babylon AST node types</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/81764012">揭秘 Prettier</a></p>
<p><a href="https://segmentfault.com/a/1190000016231512">AST 实战</a></p>
<p><a href="https://github.com/eslint/espree">Espree——JavaScript 解释器</a></p>
<p><a href="https://github.com/acornjs/acorn">Acorn——JavaScript 解释器</a></p>
<p><a href="https://esprima.org/demo/parse.html">在线查看 AST</a></p>
<p><a href="https://babeljs.io/docs/en/babel-core">babel-core</a></p>
<p><a href="https://www.npmjs.com/package/recast">recast—AST 手术刀</a></p>
<p><a href="https://github.com/jamiebuilds/the-super-tiny-compiler">The Super Tiny Compiler</a></p>
<p><a href="https://astexplorer.net/">AST Explorer</a></p>
<p><a href="https://m.zhipin.com/mpa/html/get/column?contentId=87995370b56b0ac0qxB70tu1&identity=undefined&userId=undefined">Babel 使用全景图</a></p>
<p><a href="https://www.npmjs.com/package/typescript-doc-gen">typescript-doc-gen</a></p>
<p><a href="http://documentation.js.org/">documentation</a></p>
<p><a href="https://github.com/SBoudrias/AST-query">AST Query</a></p>
]]></content>
      <categories>
        <category>编译相关</category>
      </categories>
      <tags>
        <tag>AST</tag>
        <tag>babel</tag>
        <tag>parser</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包是什么？</title>
    <url>/bloger/2021/08/24/JavaScript/%E9%97%AD%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="谈谈你对闭包的理解"><a href="#谈谈你对闭包的理解" class="headerlink" title="谈谈你对闭包的理解"></a>谈谈你对闭包的理解</h1><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>JavaScript 中，变量的作用域有两种：全局作用域和局部作用域</p>
<p>JavaScript 语言特殊之处在于，函数内部可以直接读取全局变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>

<p>另一方面，在函数外部自然无法读取函数内部局部变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 注意此处必须使用var声明符，否则就是全局声明</span></span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(n); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<h2 id="如何从函数外部读取函数内局部变量"><a href="#如何从函数外部读取函数内局部变量" class="headerlink" title="如何从函数外部读取函数内局部变量"></a>如何从函数外部读取函数内局部变量</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. JavaScript 语言允许在函数内部定义新的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(n); <span class="comment">// 2. 可以在内部函数中访问父函数中定义的变量</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> f2; <span class="comment">// 3. 函数是一等公民，所以函数可以作为返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line"></span><br><span class="line">result(); <span class="comment">// 999  如此便实现了在函数外部访问函数内部局部变量</span></span><br></pre></td></tr></table></figure>

<h2 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h2><p>上述代码中的 f2 函数就是一个闭包, 闭包就是能够<em>读取其他函数内部变量</em>的<em>函数</em></p>
<p>本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁</p>
<h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><ul>
<li><p>读取函数内部变量</p>
</li>
<li><p>让函数内部被闭包引用的变量始终保持在内存中</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局变量+匿名函数，同时也是一个闭包</span></span><br><span class="line">  <span class="comment">// 通过此函数，不仅可以访问函数内部变量，还可以修改函数内部变量</span></span><br><span class="line">  add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    n += <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line"></span><br><span class="line">result(); <span class="comment">// 999</span></span><br><span class="line"></span><br><span class="line">add();</span><br><span class="line"></span><br><span class="line">result(); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，result 实际上就是一个闭包函数 f2。第一次运行的值是 999，第二次运行的值是 1000。这说明了，函数 f1 中的局部变量 n 一直保留在内存中，并没有在函数 f1 调用后被自动清除</p>
<p>由于闭包会使得函数内变量被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页性能问题</p>
<p>闭包会在父函数外部，改变父函数内部变量的值，所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（public method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用闭包来定义公共函数，并令其可以访问私有函数和变量</span></span><br><span class="line"><span class="keyword">var</span> Counter = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(-<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 0 */</span></span><br><span class="line">Counter.increment();</span><br><span class="line">Counter.increment();</span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 2 */</span></span><br><span class="line">Counter.decrement();</span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 1 */</span></span><br></pre></td></tr></table></figure>

<p>以这种方式使用闭包，提供了许多与面向对象编程相关的好处 —— 特别是数据隐藏和封装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> addFun1 = add(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">let</span> addFun2 = add(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(addFun1(<span class="number">2</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(addFun2(<span class="number">2</span>)); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>函数柯里化使用了闭包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原生的setTimeout传递的第一个函数不能带参数</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">  alert(params);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过闭包可以实现传参效果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(params);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f1 = func(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(f1, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>setTimeout 传参使用了闭包</p>
<p>debounce/throttle 都是用到了闭包</p>
<p>通过闭包创建一个立即执行函数，可以用来做模块化，比如 jQuery, 再比如 Webpack 打包后的 bundle</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">global</span>, factory</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="built_in">global</span>.document</span><br><span class="line">      ? factory(<span class="built_in">global</span>, <span class="literal">true</span>)</span><br><span class="line">      : <span class="function"><span class="keyword">function</span> (<span class="params">w</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!w.document) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;jQuery requires a window with a document&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> factory(w);</span><br><span class="line">        &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory(<span class="built_in">global</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pass this if window is not defined yet</span></span><br><span class="line">&#125;)(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&quot;undefined&quot;</span> ? <span class="built_in">window</span> : <span class="built_in">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span>, noGlobal</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// @CODE</span></span><br><span class="line">  <span class="comment">// build.js inserts compiled jQuery here</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> jQuery;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params">name, message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name.toString();</span><br><span class="line">  <span class="built_in">this</span>.message = message.toString();</span><br><span class="line">  <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.getMessage = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.message;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码创建了一个闭包，但是完全是没有必要的闭包，可以使用原型替代</p>
<h2 id="闭包面试题"><a href="#闭包面试题" class="headerlink" title="闭包面试题"></a>闭包面试题</h2><p>代码片段 1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;The Window&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line"></span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this指向obj</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// this指向window</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(obj.getNameFunc()()); <span class="comment">// &quot;The Window&quot;</span></span><br></pre></td></tr></table></figure>

<p>代码片段 2</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;The Window&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line"></span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// that是上一层函数的this，相当于把obj传递下来了</span></span><br><span class="line">      <span class="keyword">return</span> that.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(obj.getNameFunc()()); <span class="comment">// &quot;My Object&quot;</span></span><br></pre></td></tr></table></figure>

<p>代码片段 3</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">data[<span class="number">0</span>](); <span class="comment">// 3</span></span><br><span class="line">data[<span class="number">1</span>](); <span class="comment">// 3</span></span><br><span class="line">data[<span class="number">2</span>](); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>代码片段 4</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(</span><br><span class="line">      (data[j] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j);</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">    );</span><br><span class="line">  &#125;)(i); <span class="comment">// 立即调用函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不用调用就会依次打印0，1, 2</span></span><br></pre></td></tr></table></figure>

<p>代码片段 5</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">data[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">data[<span class="number">1</span>](); <span class="comment">// 1</span></span><br><span class="line">data[<span class="number">2</span>](); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="V8-如何处理闭包"><a href="#V8-如何处理闭包" class="headerlink" title="V8 如何处理闭包"></a>V8 如何处理闭包</h2><h3 id="惰性解析"><a href="#惰性解析" class="headerlink" title="惰性解析"></a>惰性解析</h3><p>V8 执行 JavaScript 代码，需要经过编译和执行两个阶段，其中编译过程是指 V8 将 JavaScript 代码转换为字节码或者二进制机器代码的阶段，而执行阶段则是指解释器解释执行字节码，或者是 CPU 直接执行二进制机器代码的阶段</p>
<p><img src="https://static001.geekbang.org/resource/image/fe/db/fe3d39715d28a833883df6702930a0db.jpg"></p>
<p>在编译 JavaScript 代码的过程中，V8 并不会一次性将所有的 JavaScript 解析为中间代码，这主要是基于以下两点：首先，如果一次解析和编译所有的 JavaScript 代码，过多的代码会增加编译时间，这会严重影响到首次执行 JavaScript 代码的速度，让用户感觉到卡顿。因为有时候一个页面的 JavaScript 代码都有 10 多兆，如果要将所有的代码一次性解析编译完成，那么会大大增加用户的等待时间；其次，解析完成的字节码和编译之后的机器代码都会存放在内存中，如果一次性解析和编译所有 JavaScript 代码，那么这些中间代码和机器代码将会一直占用内存，特别是在手机普及的年代，内存是非常宝贵的资源。</p>
<p>基于以上的原因，所有主流的 JavaScript 虚拟机都实现了<em>惰性解析</em>。所谓惰性解析是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码。</p>
<p>关于惰性解析，可以结合下面这个例子来分析下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> d + f + a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">4</span>;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>当把这段代码交给 V8 处理时，V8 会至上而下解析这段代码，在解析过程中首先会遇到 foo 函数，由于这只是一个函数声明语句，V8 在这个阶段只需要将该函数转换为函数对象，如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/35/4a/35ce3f6469a7024ca14d81b6c804044a.jpg"></p>
<p>注意，这里只是将该函数声明转换为函数对象，但是并没有解析和编译函数内部的代码，所以也不会为 foo 函数的内部代码生成抽象语法树。</p>
<p>然后继续往下解析，由于后续的代码都是顶层代码，所以 V8 会为它们生成抽象语法树，最终生成的结果如下所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/e5/62/e52476efb6ef924e74f470ead4970262.jpg"></p>
<p>代码解析完成之后，V8 便会按照顺序自上而下执行代码，首先会先执行“a=1”和“c=4”这两个赋值表达式，接下来执行 foo 函数的调用，过程是从 foo 函数对象中取出函数代码，然后和编译顶层代码一样，V8 会先编译 foo 函数的代码，编译时同样需要先将其编译为抽象语法树和字节码，然后再解释执行。</p>
<p>好了，上面就是惰性解析的一个大致过程，看上去是不是很简单，不过在 V8 实现惰性解析的过程中，需要支持 JavaScript 中的闭包特性，这会使得 V8 的解析过程变得异常复杂。</p>
<p>为什么闭包会让 V8 解析代码的过程变得复杂呢？要解答这个问题，我们先来拆解闭包的特性，然后再来分析为什么闭包影响到了 V8 的解析流程。</p>
<h3 id="拆解闭包——JavaScript-的三个特性"><a href="#拆解闭包——JavaScript-的三个特性" class="headerlink" title="拆解闭包——JavaScript 的三个特性"></a>拆解闭包——JavaScript 的三个特性</h3><p>JavaScript 中的闭包有三个基础特性。</p>
<p>第一，JavaScript 语言允许在函数内部定义新的函数，代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这和其他的流行语言有点差异，在其他的大部分语言中，函数只能声明在顶层代码中，而 JavaScript 中之所以可以在函数中声明另外一个函数，主要是因为 JavaScript 中的函数即对象，你可以在函数中声明一个变量，当然你也可以在函数中声明一个函数。</p>
<p>第二，可以在内部函数中访问父函数中定义的变量，代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//inner函数的父函数，词法作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="number">55</span>;</span><br><span class="line">  <span class="comment">//foo的内部函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于可以在函数中定义新的函数，所以很自然的，内部的函数可以使用外部函数中定义的变量，注意上面代码中的 inner 函数和 foo 函数，inner 是在 foo 函数内部定义的，我们就称 inner 函数是 foo 函数的子函数，foo 函数是 inner 函数的父函数。这里的父子关系是针对词法作用域而言的，因为词法作用域在函数声明时就决定了，比如 inner 函数是在 foo 函数内部声明的，所以 inner 函数可以访问 foo 函数内部的变量，比如 inner 就可以访问 foo 函数中的变量 d。</p>
<p>但是如果在 foo 函数外部，也定义了一个变量 d，那么当 inner 函数访问该变量时，到底是该访问哪个变量呢？</p>
<p>我们知道，每个函数有自己的词法作用域，该函数中定义的变量都存在于该作用域中，然后 V8 会将这些作用域按照词法的位置，也就是代码位置关系，将这些作用域串成一个链，这就是词法作用域链，查找变量的时候会沿着词法作用域链的途径来查找。</p>
<p>所以，inner 函数在自己的作用域中没有查找到变量 d，就接着在 foo 函数的作用域中查找，再查找不到才会查找顶层作用域中的变量。所以 inner 函数中使用的变量 d 就是 foo 函数中的变量 d。</p>
<p>第三，因为函数是一等公民，所以函数可以作为返回值，我们可以看下面这段代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = foo();</span><br></pre></td></tr></table></figure>

<p>观察上面这段代码，我们将 inner 函数作为了 foo 函数的返回值，也就是说，当调用 foo 函数时，最终会返回 inner 函数给调用者，比如上面我们将 inner 函数返回给了全局变量 f，接下来就可以在外部像调用 inner 函数一样调用 f 了。</p>
<p>以上就是和 JavaScript 闭包相关的三个重要特性：</p>
<ul>
<li>可以在 JavaScript 函数内部定义新的函数；</li>
<li>内部函数中访问父函数中定义的变量；</li>
<li>因为 JavaScript 中的函数是一等公民，所以函数可以作为另外一个函数的返回值。</li>
</ul>
<p>这也是 JavaScript 过于灵活的一个原因，比如在 C/C++ 中，你就不可以在一个函数中定义另外一个函数，所以也就没了内部函数访问外部函数中变量的问题了。</p>
<h3 id="闭包给惰性解析带来的问题"><a href="#闭包给惰性解析带来的问题" class="headerlink" title="闭包给惰性解析带来的问题"></a>闭包给惰性解析带来的问题</h3><p>上面我们了解了 JavaScript 的这三个特性，下面我们就来使用这三个特性组装的一段经典的闭包代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> c = a + b + d;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = foo();</span><br></pre></td></tr></table></figure>

<p>观察上面上面这段代码，我们在 foo 函数中定义了 inner 函数，并返回 inner 函数，同时在 inner 函数中访问了 foo 函数中的变量 d。</p>
<ul>
<li>当调用 foo 函数时，foo 函数会将它的内部函数 inner 返回给全局变量 f；</li>
<li>然后 foo 函数执行结束，执行上下文被 V8 销毁；</li>
<li>虽然 foo 函数的执行上下文被销毁了，但是依然存活的 inner 函数引用了 foo 函数作用域中的变量 d。</li>
</ul>
<p>按照通用的做法，d 已经被 v8 销毁了，但是由于存活的函数 inner 依然引用了 foo 函数中的变量 d，这样就会带来两个问题：</p>
<ul>
<li><p>当 foo 执行结束时，变量 d 该不该被销毁？如果不应该被销毁，那么应该采用什么策略？</p>
</li>
<li><p>如果采用了惰性解析，那么当执行到 foo 函数时，V8 只会解析 foo 函数，并不会解析内部的 inner 函数，那么这时候 V8 就不知道 inner 函数中是否引用了 foo 函数的变量 d。</p>
</li>
</ul>
<p>这么讲可能有点抽象，下面我们就来看一下上面这段代码的执行流程，我们上节分析过了，JavaScript 是一门基于堆和栈的语言，当执行 foo 函数的时候，堆栈的变化如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/de/10/deaa69d414571516a1debd9712860110.jpg"></p>
<p>从上图可以看出来，在执行全局代码时，V8 会将全局执行上下文压入到调用栈中，然后进入执行 foo 函数的调用过程，这时候 V8 会为 foo 函数创建执行上下文，执行上下文中包括了变量 d，然后将 foo 函数的执行上下文压入栈中，foo 函数执行结束之后，foo 函数执行上下文从栈中弹出，这时候 foo 执行上下文中的变量 d 也随之被销毁。</p>
<p>但是这时候，由于 inner 函数被保存到全局变量中了，所以 inner 函数依然存在，最关键的地方在于 inner 函数使用了 foo 函数中的变量 d，按照正常执行流程，变量 d 在 foo 函数执行结束之后就被销毁了。</p>
<p>所以正常的处理方式应该是 foo 函数的执行上下文虽然被销毁了，但是 inner 函数引用的 foo 函数中的变量却不能被销毁，那么 V8 就需要为这种情况做特殊处理，需要保证即便 foo 函数执行结束，但是 foo 函数中的 d 变量依然保持在内存中，不能随着 foo 函数的执行上下文被销毁掉。</p>
<p>那么怎么处理呢？</p>
<p>在执行 foo 函数的阶段，虽然采取了惰性解析，不会解析和执行 foo 函数中的 inner 函数，但是 V8 还是需要判断 inner 函数是否引用了 foo 函数中的变量，负责处理这个任务的模块叫做预解析器。</p>
<h3 id="预解析器如何解决闭包所带来的问题？"><a href="#预解析器如何解决闭包所带来的问题？" class="headerlink" title="预解析器如何解决闭包所带来的问题？"></a>预解析器如何解决闭包所带来的问题？</h3><p>V8 引入预解析器，比如当解析顶层代码的时候，遇到了一个函数，那么预解析器并不会直接跳过该函数，而是对该函数做一次快速的预解析，其主要目的有两个。</p>
<p>第一，是判断当前函数是不是存在一些语法上的错误，如下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  &#123;<span class="regexp">/&#125; /</span><span class="regexp">/语法错误</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">var a = 1</span></span><br><span class="line"><span class="regexp">var c = 4</span></span><br><span class="line"><span class="regexp">foo(1, 5)</span></span><br></pre></td></tr></table></figure>

<p>在预解析过程中，预解析器发现了语法错误，那么就会向 V8 抛出语法错误，比如上面这段代码的语法错误是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Uncaught <span class="built_in">SyntaxError</span>: Invalid regular expression: missing /</span><br></pre></td></tr></table></figure>

<p>第二，除了检查语法错误之外，预解析器另外的一个重要的功能就是检查函数内部是否引用了外部变量，如果引用了外部的变量，预解析器会将栈中的变量复制到堆中，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所谓惰性解析是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码。</p>
<p>利用惰性解析可以加速 JavaScript 代码的启动速度，如果要将所有的代码一次性解析编译完成，那么会大大增加用户的等待时间。</p>
<p>由于 JavaScript 是一门天生支持闭包的语言，由于闭包会引用当前函数作用域之外的变量，所以当 V8 解析一个函数的时候，还需要判断该函数的内部函数是否引用了当前函数内部声明的变量，如果引用了，那么需要将该变量存放到堆中，即便当前函数执行结束之后，也不会释放该变量。</p>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行foo函数时，函数foo的上下文和变量a会存放到栈上，随着函数执行完毕会被销毁</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 foo函数之后先解析，在解析过程中发现有内部函数，因此会发生预解析</span></span><br><span class="line"><span class="comment">// 发现内部函数会引用外部函数中的变量 a，因此将这个 a 写到内存堆上。</span></span><br><span class="line"><span class="comment">// 最终 foo 函数执行完毕之后，a 变量不会随之销毁</span></span><br></pre></td></tr></table></figure>

<p>问题：当调用 foo 函数时，foo 函数内部的变量 a 会分别分配到栈上？还是堆上？</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>React 中的高阶组件及其应用场景</title>
    <url>/bloger/2021/04/10/UI%E6%A1%86%E6%9E%B6/React%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h2 id="React-中的高阶组件及其应用场景"><a href="#React-中的高阶组件及其应用场景" class="headerlink" title="React 中的高阶组件及其应用场景"></a>React 中的高阶组件及其应用场景</h2><h3 id="什么是高阶组件"><a href="#什么是高阶组件" class="headerlink" title="什么是高阶组件"></a>什么是高阶组件</h3><p>如果一个函数 接受一个或多个组件作为参数并且返回一个组件 就可称之为 高阶组件 下面就是一个简单的高阶组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HigherOrderComponent = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="React-中的高阶组件"><a href="#React-中的高阶组件" class="headerlink" title="React 中的高阶组件"></a>React 中的高阶组件</h3><p>React 中的高阶组件主要有两种形式：属性代理 和 反向继承</p>
<h4 id="属性代理（Props-Proxy）"><a href="#属性代理（Props-Proxy）" class="headerlink" title="属性代理（Props Proxy）"></a>属性代理（Props Proxy）</h4><p>最简单的属性代理实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HigherOrderComponent</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HigherOrderComponent</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，属性代理其实就是 一个函数接受一个<code>WrappedComponent </code>组件作为参数传入，并返回一个继承了<code>React.Component</code>组件的类，且在该类的 render()<br>方法中返回被传入的<code>WrappedComponent </code>组件。</p>
<p>那我们可以利用属性代理类型的高阶组件做一些什么呢？</p>
<p>因为属性代理类型的高阶组件返回返回继承自<code>React.Component</code>的标准组件。 因此，在 React 标准组件中可以做什么，高阶组件也可以做，比如：</p>
<ul>
<li>操作 props</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; userInfo &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;h1&gt;Learn React&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;&#123;<span class="built_in">JSON</span>.stringify(userInfo, <span class="literal">null</span>, <span class="number">2</span>)&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在高阶组件里操作props</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">WrappedComponent</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> HigherOrderComponent = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">      <span class="built_in">this</span>.state = &#123;</span><br><span class="line">        userInfo: <span class="literal">null</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      fetch(<span class="string">&quot;https://jsonplaceholder.typicode.com/users/1&quot;</span>)</span><br><span class="line">        .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json())</span><br><span class="line">        .then(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="built_in">this</span>.setState(&#123; <span class="attr">userInfo</span>: data &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; userInfo &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        ...this.props,</span><br><span class="line">        userInfo,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...newProps</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HigherOrderComponent(App);</span><br></pre></td></tr></table></figure>

<ul>
<li>抽离 state</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    name: &#123; value, onChange &#125;,</span><br><span class="line">  &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;h1&gt;Learn React&lt;/h1&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">&quot;text&quot;</span></span><br><span class="line">        value=&#123;value&#125;</span><br><span class="line">        onChange=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> onChange(e.target.value)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在高阶组件里抽离 state</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">WrappedComponent</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> withOnChange = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">      <span class="built_in">this</span>.state = &#123;</span><br><span class="line">        name: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onChange = <span class="function">(<span class="params">newName</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;onChange&quot;</span>, newName);</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123; <span class="attr">name</span>: newName &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; name &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        name: &#123;</span><br><span class="line">          value: name,</span><br><span class="line">          onChange: <span class="built_in">this</span>.onChange,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...newProps</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withOnChange(App);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 ref 访问到组件实例 有时会有需要访问 DOM element （使用第三方 DOM 操作库）的时候就会用到组件的 ref 属性。它只能声明在 Class 类型的组件上，而无法声明在函数（无状态）类型的组件上。</li>
</ul>
<p>ref 的值可以是字符串（不推荐使用）也可以是一个回调函数，如果是回调函数的话，它的执行时机是：</p>
<p>组件被挂载后（<code>componentDidMount</code>），回调函数立即执行，回调函数的参数为该组件的实例。 组件被卸载（<code>componentDidUnmount</code>）或者原有的 ref<br>属性本身发生变化的时候，此时回调函数也会立即执行，且回调函数的参数为 null。 如何在 高阶组件 中获取到<code>WrappedComponent </code>组件的实例呢？答案就是可以通过 <code>WrappedComponent </code>组件的 ref<br>属性，该属性会在组件 <code>componentDidMount</code> 的时候执行 ref 的回调函数并传入该组件的实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, createRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      value: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">value</span>: e.target.value &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;App3 componentDidMount&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">        &lt;h1&gt;Learn React&lt;/h1&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> value=&#123;value&#125; onChange=&#123;<span class="built_in">this</span>.onChange&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在高阶组件里通过 ref 访问到组件实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">WrappedComponent</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> HigherOrderComponent = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">&quot;HigherOrderComponent componentDidMount&quot;</span>,</span><br><span class="line">        <span class="built_in">this</span>.instance.state,</span><br><span class="line">        <span class="built_in">this</span>.instance.onChange</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="comment">// 注意：不能在函数组件上使用 ref 属性，因为无状态组件没有实例。</span></span><br><span class="line">        &lt;WrappedComponent</span><br><span class="line">          &#123;...this.props&#125;</span><br><span class="line">          ref=&#123;<span class="function">(<span class="params">obj</span>) =&gt;</span> (<span class="built_in">this</span>.instance = obj)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HigherOrderComponent(App);</span><br></pre></td></tr></table></figure>

<ul>
<li>用其他元素包裹 <code>WrappedComponent</code><br>给 <code>WrappedComponent</code> 组件包一层背景色为<code>#f80</code>的 div 元素：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withBackgroundColor</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div style=&#123;&#123; <span class="attr">backgroundColor</span>: <span class="string">&quot;#f80&quot;</span> &#125;&#125;&gt;</span><br><span class="line">          &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="反向继承（Inheritance-Inversion）"><a href="#反向继承（Inheritance-Inversion）" class="headerlink" title="反向继承（Inheritance Inversion）"></a>反向继承（Inheritance Inversion）</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HigherOrderComponent</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反向继承其实就是 一个函数接受一个 <code>WrappedComponent</code> 组件作为参数传入，并返回一个继承了该传入 <code>WrappedComponent</code> 组件的类，且在该类的<code>render()</code><br>方法中返回 <code>super.render() </code>方法</p>
<p>会发现其属性代理和反向继承的实现有些类似的地方，都是返回一个继承了某个父类的子类，只不过属性代理中继承的是<code>React.Component</code>，反向继承中继承的是传入的组件 <code>WrappedComponent</code></p>
<p>那么，反向继承可以做什么？</p>
<ul>
<li>操作 state 高阶组件中可以读取、编辑和删除<code>WrappedComponent</code> 组件实例中的 state。甚至可以增加更多的 state 项，但是这么做可能会导致 state 难以维护及管理</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLogging</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h2&gt;Debugger Component&lt;/h2&gt;</span><br><span class="line">          &lt;p&gt;state:&lt;/p&gt;</span><br><span class="line">          &lt;pre&gt;&#123;<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.state, <span class="literal">null</span>, <span class="number">2</span>)&#125;&lt;/pre&gt;</span><br><span class="line">          &lt;p&gt;props:&lt;/p&gt;</span><br><span class="line">          &lt;pre&gt;&#123;<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.props, <span class="literal">null</span>, <span class="number">2</span>)&#125;&lt;/pre&gt;</span><br><span class="line">          &#123;<span class="built_in">super</span>.render()&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>渲染劫持（<code>Render Highjacking</code>） 通过渲染劫持，我们可以：<ul>
<li>有条件地展示元素树（element tree）</li>
<li>操作由 render() 输出的 React 元素树</li>
<li>在任何由 render() 输出的 React 元素中操作 props</li>
<li>用其他元素包裹传入的组件<code>WrappedComponent</code>（同<strong>属性代理</strong>）</li>
</ul>
</li>
</ul>
<h3 id="高阶组件存在的问题"><a href="#高阶组件存在的问题" class="headerlink" title="高阶组件存在的问题"></a>高阶组件存在的问题</h3><h4 id="静态方法丢失"><a href="#静态方法丢失" class="headerlink" title="静态方法丢失"></a>静态方法丢失</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> 因为原始组件被包裹于一个容器组件内，也就意味着新组件会没有原始组件的任何静态方法：</span><br><span class="line"><span class="comment">// 定义静态方法</span></span><br><span class="line">WrappedComponent.staticMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用高阶组件</span></span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = HigherOrderComponent(WrappedComponent);</span><br><span class="line"><span class="comment">// 增强型组件没有静态方法</span></span><br><span class="line"><span class="keyword">typeof</span> EnhancedComponent.staticMethod === <span class="string">&#x27;undefined&#x27;</span> <span class="comment">// true</span></span><br><span class="line">所以必须将静态方法做拷贝：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HigherOrderComponent</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Enhance</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须得知道要拷贝的方法</span></span><br><span class="line">    Enhance.staticMethod = WrappedComponent.staticMethod;</span><br><span class="line">    <span class="keyword">return</span> Enhance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">但是这么做的一个缺点就是必须知道要拷贝的方法是什么，不过</span><br><span class="line">React</span><br><span class="line">社区实现了一个库</span><br><span class="line">hoist - non - react - statics</span><br><span class="line">来自动处理，它会</span><br><span class="line">自动拷贝所有非</span><br><span class="line">React</span><br><span class="line">的静态方法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hoistNonReactStatic <span class="keyword">from</span> <span class="string">&#x27;hoist-non-react-statics&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HigherOrderComponent</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Enhance</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hoistNonReactStatic(Enhance, WrappedComponent);</span><br><span class="line">    <span class="keyword">return</span> Enhance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="refs-属性不能透传"><a href="#refs-属性不能透传" class="headerlink" title="refs 属性不能透传"></a>refs 属性不能透传</h4><p>一般来说高阶组件可以传递所有的 props 给包裹的组件<code>WrappedComponent</code>，但是有一种属性不能传递，它就是 ref。与其他属性不同的地方在于 React 对其进行了特殊的处理。</p>
<p>如果你向一个由高阶组件创建的组件的元素添加 ref 引用，那么 ref 指向的是最外层容器组件实例的，而不是被包裹的 <code>WrappedComponent</code>组件。</p>
<p>不过，React 为我们提供了一个名为<code>React.forwardRef</code>的 API 来解决这一问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      data: [],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">        &lt;h1&gt;Learn React&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">          &#123;<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.state, <span class="literal">null</span>, <span class="number">2</span>)&#125;</span><br><span class="line">          &#123;<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.props, <span class="literal">null</span>, <span class="number">2</span>)&#125;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLogging</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Enhance</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">UNSAFE_componentWillReceiveProps</span>(<span class="params">nextProps</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Current props&quot;</span>, <span class="built_in">this</span>.props);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Next props&quot;</span>, nextProps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; forwardedRef, ...rest &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">      <span class="comment">// 把 forwardedRef 赋值给 WrappedComponent 的 ref</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...rest</span>&#125; <span class="attr">ref</span>=<span class="string">&#123;forwardedRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// React.forwardRef 方法会传入 props 和 ref 两个参数给其回调函数</span></span><br><span class="line">  <span class="comment">// 所以这边的 ref 是由 React.forwardRef 提供的</span></span><br><span class="line">  <span class="keyword">return</span> React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Enhance</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">data</span>=<span class="string">&#123;123&#125;</span> <span class="attr">forwardRef</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withLogging(App);</span><br></pre></td></tr></table></figure>

<h4 id="反向继承不能保证完整的子组件树被解析"><a href="#反向继承不能保证完整的子组件树被解析" class="headerlink" title="反向继承不能保证完整的子组件树被解析"></a>反向继承不能保证完整的子组件树被解析</h4><p>React 组件有两种形式，分别是 class 类型和 function 类型</p>
<p>我们知道反向继承的渲染劫持可以控制<code>WrappedComponent </code>的渲染过程，也就是说这个过程中我们可以对 elements tree、state、props 或 render() 的结果做各种操作</p>
<p>如果渲染 elements tree 中包含了 function 类型的组件的话，这时候就不能操作组件的子组件了</p>
<h3 id="高阶组件的约定"><a href="#高阶组件的约定" class="headerlink" title="高阶组件的约定"></a>高阶组件的约定</h3><p>高阶组件带给我们极大方便的同时，我们也要遵循一些 约定：</p>
<h4 id="props-保持一致"><a href="#props-保持一致" class="headerlink" title="props 保持一致"></a>props 保持一致</h4><p>高阶组件在为子组件添加特性的同时，要尽量保持原有组件的 props 不受影响，也就是说传入的组件和返回的组件在 props 上尽量保持一致。</p>
<p>不要改变原始组件<code>WrappedComponent</code><br>不要在高阶组件内以任何方式修改一个组件的原型，思考一下下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLogging</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  WrappedComponent.prototype.componentWillReceiveProps = <span class="function"><span class="keyword">function</span> (<span class="params">nextProps</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Current props&quot;</span>, <span class="built_in">this</span>.props);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Next props&quot;</span>, nextProps);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> WrappedComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = withLogging(SomeComponent);</span><br></pre></td></tr></table></figure>

<p>会发现在高阶组件的内部对 <code>WrappedComponent</code>进行了修改，一旦对原组件进行了修改，那么就失去了组件复用的意义，所以请通过 纯函数（相同的输入总有相同的输出） 返回新的组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLogging</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Current props&quot;</span>, <span class="built_in">this</span>.props);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Next props&quot;</span>, nextProps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 透传参数，不要修改它</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样优化之后的<code>withLogging </code>是一个 纯函数，并不会修改 <code>WrappedComponent</code>组件，所以不需要担心有什么副作用，进而达到组件复用的目的。</p>
<h4 id="透传不相关-props-属性给被包裹的组件-WrappedComponent"><a href="#透传不相关-props-属性给被包裹的组件-WrappedComponent" class="headerlink" title="透传不相关 props 属性给被包裹的组件 WrappedComponent"></a>透传不相关 props 属性给被包裹的组件 <code>WrappedComponent</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HigherOrderComponent</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不要在-render-方法中使用高阶组件"><a href="#不要在-render-方法中使用高阶组件" class="headerlink" title="不要在 render() 方法中使用高阶组件"></a>不要在 render() 方法中使用高阶组件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用高阶函数的时候每次都会返回一个新的组件</span></span><br><span class="line">    <span class="keyword">const</span> EnchancedComponent = enhance(WrappedComponent);</span><br><span class="line">    <span class="comment">// 每次 render 的时候，都会使子对象树完全被卸载和重新</span></span><br><span class="line">    <span class="comment">// 重新加载一个组件会引起原有组件的状态和它的所有子组件丢失</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">EnchancedComponent</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-compose-组合高阶组件"><a href="#使用-compose-组合高阶组件" class="headerlink" title="使用 compose 组合高阶组件"></a>使用 compose 组合高阶组件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不要这么使用</span></span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))；</span><br><span class="line"><span class="comment">// 可以使用一个 compose 函数组合这些高阶组件</span></span><br><span class="line"><span class="comment">// lodash, redux, ramda 等第三方库都提供了类似 `compose` 功能的函数</span></span><br><span class="line"><span class="keyword">const</span> enhance = compose(withRouter, connect(commentSelector))；</span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = enhance(WrappedComponent)；</span><br></pre></td></tr></table></figure>

<p>因为按照 约定 实现的高阶组件其实就是一个纯函数，如果多个函数的参数一样，所以就可以通过 compose 方法来组合这些函数。</p>
<p>使用 compose 组合高阶组件使用，可以显著提高代码的可读性和逻辑的清晰度。 包装显示名字以便于调试 高阶组件创建的容器组件在 React Developer Tools 中的表现和其它的普通组件是一样的。</p>
<p>为了便于调试，可以选择一个显示名字，传达它是一个高阶组件的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getDisplayName = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span></span><br><span class="line">  WrappedComponent.displayName || WrappedComponent.name || <span class="string">&quot;Component&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HigherOrderComponent</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HigherOrderComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  HigherOrderComponent.displayName = <span class="string">`HigherOrderComponent(<span class="subst">$&#123;getDisplayName(</span></span></span><br><span class="line"><span class="string"><span class="subst">    WrappedComponent</span></span></span><br><span class="line"><span class="string"><span class="subst">  )&#125;</span>)`</span>;</span><br><span class="line">  <span class="keyword">return</span> HigherOrderComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高阶组件的应用场景"><a href="#高阶组件的应用场景" class="headerlink" title="高阶组件的应用场景"></a>高阶组件的应用场景</h3><h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><p>利用高阶组件的<strong>条件渲染</strong> 特性可以对页面进行权限控制，权限控制一般分为两个维度：<strong>页面级别</strong> 和<strong>页面元素级别</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HOC.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultMessageMap = &#123;</span><br><span class="line">    <span class="string">&#x27;Admin&#x27;</span>: <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>您没有权限查看该页面，请联系管理员！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">    <span class="string">&#x27;VIP&#x27;</span>: <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>您未购买该模块，请联系销售试用！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">    <span class="string">&#x27;&#x27;</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 权限控制</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">role</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> withAuth = <span class="function"><span class="params">role</span> =&gt;</span> <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        state = &#123;</span><br><span class="line">            auth: <span class="literal">false</span>,</span><br><span class="line">            role: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="title">UNSAFE_componentWillMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123;<span class="attr">role</span>: currentRole&#125; = <span class="keyword">await</span> fetch(<span class="string">&#x27;//localhost:9090/userInfo&#x27;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">                <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                    auth: currentRole === role,</span><br><span class="line">                    role: currentRole</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                    auth: <span class="literal">false</span>,</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.state.auth) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> defaultMessageMap[<span class="built_in">this</span>.state.role]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withAuth</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// pages/PageA.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> withAuth <span class="keyword">from</span> <span class="string">&quot;../HOC&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 管理员专用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageA</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;管理员专用&lt;/h2&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withAuth(<span class="string">&#x27;Admin&#x27;</span>)(PageA);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// pages/PageB.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> withAuth <span class="keyword">from</span> <span class="string">&quot;../HOC&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VIP专用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageB</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;VIP专用&lt;/h2&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withAuth(<span class="string">&#x27;VIP&#x27;</span>)(PageB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pages/PageC.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> withAuth <span class="keyword">from</span> <span class="string">&quot;../HOC&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通用户使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;普通用户使用&lt;/h2&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> PageC;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="组件渲染性能追踪"><a href="#组件渲染性能追踪" class="headerlink" title="组件渲染性能追踪"></a>组件渲染性能追踪</h4><p>借助父组件子组件生命周期规则捕获子组件的生命周期，可以方便的对某个组件的渲染时间进行记录</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用【反向继承】实现的一个高阶组件，功能是计算被包裹组件的渲染时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">WrappedComponent</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withTiming</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">      <span class="built_in">this</span>.start = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">this</span>.end = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">UNSAFE_componentWillMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>.UNSAFE_componentWillMount &amp;&amp; <span class="built_in">super</span>.UNSAFE_componentWillMount();</span><br><span class="line">      <span class="built_in">this</span>.start = <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>.componentDidMount &amp;&amp; <span class="built_in">super</span>.componentDidMount();</span><br><span class="line">      <span class="built_in">this</span>.end = <span class="built_in">Date</span>.now();</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`<span class="subst">$&#123;WrappedComponent.name&#125;</span> 组件渲染时间为 <span class="subst">$&#123;<span class="built_in">this</span>.end - <span class="built_in">this</span>.start&#125;</span> ms`</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">        &lt;h1&gt;Learn React&lt;/h1&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withTiming(App);</span><br></pre></td></tr></table></figure>

<h4 id="页面复用"><a href="#页面复用" class="headerlink" title="页面复用"></a>页面复用</h4><p>假设我们有三个页面 <code>pageA</code>，<code> pageB</code>，<code>pageC</code> 分别渲染<code>users列表</code>，<code>posts列表</code>, <code>comments列表</code>，普通写法可能是下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pages/PageA.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * users列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageA</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            data: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://jsonplaceholder.typicode.com/users?id_lte=10&#x27;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;data&#125;)</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;<span class="attr">data</span>: []&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;data&#125; = <span class="built_in">this</span>.state;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;users列表&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">                &lt;pre&gt; &#123;<span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="number">2</span>)&#125;&lt;/pre&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> PageA;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pages/PageB.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * posts列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageB</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            data: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://jsonplaceholder.typicode.com/posts?id_lte=10&#x27;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;data&#125;)</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;<span class="attr">data</span>: []&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;data&#125; = <span class="built_in">this</span>.state;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;posts列表&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">                &lt;pre&gt;&#123;<span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="number">2</span>)&#125;&lt;/pre&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> PageB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// pages/PageC</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * comments 列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            data: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://jsonplaceholder.typicode.com/comments?id_lte=10&#x27;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;data&#125;)</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;<span class="attr">data</span>: []&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;data&#125; = <span class="built_in">this</span>.state;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;comments列表&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">                &lt;pre&gt;&#123;<span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="number">2</span>)&#125;&lt;/pre&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> PageC;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>页面少的时候可能没什么问题，但是假如随着业务的进展，在这个页面展示更多类型的数据，就会写很多的重复代码，所以我们需要重构一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HOC.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> withFetching = <span class="function"><span class="params">fetchingFunc</span> =&gt;</span> <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        state = &#123;</span><br><span class="line">            data: [],</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> data = <span class="keyword">await</span> fetchingFunc();</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;data&#x27;</span>, data)</span><br><span class="line">                <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                    data,</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.setState(&#123;<span class="attr">data</span>: []&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withFetching</span><br><span class="line"></span><br><span class="line"><span class="comment">// pages/PageA.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> withFetching <span class="keyword">from</span> <span class="string">&quot;../HOC&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * users列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageA</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor(props) &#123;</span></span><br><span class="line">    <span class="comment">//     super(props);</span></span><br><span class="line">    <span class="comment">//     this.state = &#123;</span></span><br><span class="line">    <span class="comment">//         data: []</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// async componentDidMount() &#123;</span></span><br><span class="line">    <span class="comment">//     try &#123;</span></span><br><span class="line">    <span class="comment">//         const data = await fetch(&#x27;https://jsonplaceholder.typicode.com/users?id_lte=10&#x27;).then(response =&gt; response.json())</span></span><br><span class="line">    <span class="comment">//         this.setState(&#123;data&#125;)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//     &#125; catch &#123;</span></span><br><span class="line">    <span class="comment">//         this.setState(&#123;data: []&#125;)</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// const &#123;data&#125; = this.state;</span></span><br><span class="line">        <span class="keyword">const</span> &#123;data&#125; = <span class="built_in">this</span>.props;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;users列表&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">                &lt;pre&gt; &#123;<span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="number">2</span>)&#125;&lt;/pre&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// export default PageA;</span></span><br><span class="line"><span class="keyword">const</span> fetchingFunc = <span class="function">() =&gt;</span> fetch(<span class="string">&#x27;https://jsonplaceholder.typicode.com/users?id_lte=10&#x27;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withFetching(fetchingFunc)(PageA);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pages/PageB.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> withFetching <span class="keyword">from</span> <span class="string">&quot;../HOC&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * posts列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageB</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// const &#123;data&#125; = this.state;</span></span><br><span class="line">        <span class="keyword">const</span> &#123;data&#125; = <span class="built_in">this</span>.props;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;posts列表&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">                &lt;pre&gt;&#123;<span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="number">2</span>)&#125;&lt;/pre&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// export default PageB;</span></span><br><span class="line"><span class="keyword">const</span> fetchingFunc = <span class="function">() =&gt;</span> fetch(<span class="string">&#x27;https://jsonplaceholder.typicode.com/posts?id_lte=10&#x27;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withFetching(fetchingFunc)(PageB);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// pages/PageC.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> withFetching <span class="keyword">from</span> <span class="string">&quot;../HOC&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * comments 列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor(props) &#123;</span></span><br><span class="line">    <span class="comment">//     super(props);</span></span><br><span class="line">    <span class="comment">//     this.state = &#123;</span></span><br><span class="line">    <span class="comment">//         data: []</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// async componentDidMount() &#123;</span></span><br><span class="line">    <span class="comment">//     try &#123;</span></span><br><span class="line">    <span class="comment">//         const data = await fetch(&#x27;https://jsonplaceholder.typicode.com/comments?id_lte=10&#x27;).then(response =&gt; response.json())</span></span><br><span class="line">    <span class="comment">//         this.setState(&#123;data&#125;)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//     &#125; catch &#123;</span></span><br><span class="line">    <span class="comment">//         this.setState(&#123;data: []&#125;)</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// const &#123;data&#125; = this.state;</span></span><br><span class="line">        <span class="keyword">const</span> &#123;data&#125; = <span class="built_in">this</span>.props;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;comments列表&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">                &lt;pre&gt;&#123;<span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="number">2</span>)&#125;&lt;/pre&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// export default PageC;</span></span><br><span class="line"><span class="keyword">const</span> fetchingFunc = <span class="function">() =&gt;</span> fetch(<span class="string">&#x27;https://jsonplaceholder.typicode.com/comments?id_lte=10&#x27;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withFetching(fetchingFunc)(PageC);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h4><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h4 id="统计上报"><a href="#统计上报" class="headerlink" title="统计上报"></a>统计上报</h4><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>高阶组件 不是组件，是 一个把某个组件转换成另一个组件的 函数</li>
<li>高阶组件的主要作用是 代码复用</li>
<li>高阶组件是 装饰器模式在 React 中的实现</li>
</ol>
]]></content>
      <categories>
        <category>UI框架</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/bloger/1970/01/01/React/React%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="React-中的高阶组件及其应用场景"><a href="#React-中的高阶组件及其应用场景" class="headerlink" title="React 中的高阶组件及其应用场景"></a>React 中的高阶组件及其应用场景</h2><h3 id="什么是高阶组件"><a href="#什么是高阶组件" class="headerlink" title="什么是高阶组件"></a>什么是高阶组件</h3><p>如果一个函数 接受一个或多个组件作为参数并且返回一个组件 就可称之为 高阶组件 下面就是一个简单的高阶组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HigherOrderComponent = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="React-中的高阶组件"><a href="#React-中的高阶组件" class="headerlink" title="React 中的高阶组件"></a>React 中的高阶组件</h3><p>React 中的高阶组件主要有两种形式：属性代理 和 反向继承</p>
<h4 id="属性代理（Props-Proxy）"><a href="#属性代理（Props-Proxy）" class="headerlink" title="属性代理（Props Proxy）"></a>属性代理（Props Proxy）</h4><p>最简单的属性代理实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HigherOrderComponent</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">props</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HigherOrderComponent</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，属性代理其实就是 一个函数接受一个<code>WrappedComponent </code>组件作为参数传入，并返回一个继承了<code>React.Component</code>组件的类，且在该类的 render()<br>方法中返回被传入的<code>WrappedComponent </code>组件。</p>
<p>那我们可以利用属性代理类型的高阶组件做一些什么呢？</p>
<p>因为属性代理类型的高阶组件返回返回继承自<code>React.Component</code>的标准组件。 因此，在 React 标准组件中可以做什么，高阶组件也可以做，比如：</p>
<ul>
<li>操作 props</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;userInfo&#125; = props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">            &lt;h1&gt;Learn React&lt;/h1&gt;</span><br><span class="line">            &lt;p&gt;</span><br><span class="line">                &#123;<span class="built_in">JSON</span>.stringify(userInfo, <span class="literal">null</span>, <span class="number">2</span>)&#125;</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在高阶组件里操作props</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">WrappedComponent</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> HigherOrderComponent = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(props);</span><br><span class="line">            <span class="built_in">this</span>.state = &#123;</span><br><span class="line">                userInfo: <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            fetch(<span class="string">&#x27;https://jsonplaceholder.typicode.com/users/1&#x27;</span>)</span><br><span class="line">                .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">                .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">this</span>.setState(&#123;<span class="attr">userInfo</span>: data&#125;))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;userInfo&#125; = <span class="built_in">this</span>.state;</span><br><span class="line">            <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">                ...this.props,</span><br><span class="line">                userInfo</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                &lt;WrappedComponent &#123;...newProps&#125; /&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HigherOrderComponent(App);</span><br></pre></td></tr></table></figure>

<ul>
<li>抽离 state</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;<span class="attr">name</span>: &#123;value, onChange&#125;&#125; = props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">            &lt;h1&gt;Learn React&lt;/h1&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;text&quot;</span> value=&#123;value&#125; onChange=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> onChange(e.target.value)&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在高阶组件里抽离 state</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">WrappedComponent</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> withOnChange = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(props);</span><br><span class="line">            <span class="built_in">this</span>.state = &#123;</span><br><span class="line">                name: <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onChange = <span class="function">(<span class="params">newName</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;onChange&#x27;</span>, newName)</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;<span class="attr">name</span>: newName&#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;name&#125; = <span class="built_in">this</span>.state;</span><br><span class="line">            <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">                name: &#123;</span><br><span class="line">                    value: name,</span><br><span class="line">                    onChange: <span class="built_in">this</span>.onChange</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                &lt;WrappedComponent &#123;...newProps&#125; /&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withOnChange(App);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 ref 访问到组件实例 有时会有需要访问 DOM element （使用第三方 DOM 操作库）的时候就会用到组件的 ref 属性。它只能声明在 Class 类型的组件上，而无法声明在函数（无状态）类型的组件上。</li>
</ul>
<p>ref 的值可以是字符串（不推荐使用）也可以是一个回调函数，如果是回调函数的话，它的执行时机是：</p>
<p>组件被挂载后（<code>componentDidMount</code>），回调函数立即执行，回调函数的参数为该组件的实例。 组件被卸载（<code>componentDidUnmount</code>）或者原有的 ref<br>属性本身发生变化的时候，此时回调函数也会立即执行，且回调函数的参数为 null。 如何在 高阶组件 中获取到<code>WrappedComponent </code>组件的实例呢？答案就是可以通过 <code>WrappedComponent </code>组件的 ref<br>属性，该属性会在组件 <code>componentDidMount</code> 的时候执行 ref 的回调函数并传入该组件的实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component, createRef&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            value: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">value</span>: e.target.value&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;App3 componentDidMount&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;value&#125; = <span class="built_in">this</span>.state</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">                &lt;h1&gt;Learn React&lt;/h1&gt;</span><br><span class="line">                &lt;input type=<span class="string">&quot;text&quot;</span> value=&#123;value&#125; onChange=&#123;<span class="built_in">this</span>.onChange&#125;/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在高阶组件里通过 ref 访问到组件实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">WrappedComponent</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> HigherOrderComponent = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;HigherOrderComponent componentDidMount&#x27;</span>, <span class="built_in">this</span>.instance.state, <span class="built_in">this</span>.instance.onChange)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                <span class="comment">// 注意：不能在函数组件上使用 ref 属性，因为无状态组件没有实例。</span></span><br><span class="line">                &lt;WrappedComponent &#123;...this.props&#125; ref=&#123;<span class="function">(<span class="params">obj</span>) =&gt;</span> <span class="built_in">this</span>.instance = obj&#125;/&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HigherOrderComponent(App);</span><br></pre></td></tr></table></figure>

<ul>
<li>用其他元素包裹 <code>WrappedComponent</code><br>给  <code>WrappedComponent</code> 组件包一层背景色为<code>#f80</code>的 div 元素：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withBackgroundColor</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                &lt;div style=&#123;&#123;<span class="attr">backgroundColor</span>: <span class="string">&#x27;#f80&#x27;</span>&#125;&#125;&gt;</span><br><span class="line">                    &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="反向继承（Inheritance-Inversion）"><a href="#反向继承（Inheritance-Inversion）" class="headerlink" title="反向继承（Inheritance Inversion）"></a>反向继承（Inheritance Inversion）</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HigherOrderComponent</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.render();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反向继承其实就是 一个函数接受一个 <code>WrappedComponent</code> 组件作为参数传入，并返回一个继承了该传入 <code>WrappedComponent</code> 组件的类，且在该类的<code>render()</code><br>方法中返回 <code>super.render() </code>方法</p>
<p>会发现其属性代理和反向继承的实现有些类似的地方，都是返回一个继承了某个父类的子类，只不过属性代理中继承的是<code>React.Component</code>，反向继承中继承的是传入的组件 <code>WrappedComponent</code></p>
<p>那么，反向继承可以做什么？</p>
<ul>
<li>操作 state 高阶组件中可以读取、编辑和删除<code>WrappedComponent</code> 组件实例中的 state。甚至可以增加更多的 state 项，但是这么做可能会导致 state 难以维护及管理</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLogging</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;h2&gt;Debugger Component&lt;/h2&gt;</span><br><span class="line">                    &lt;p&gt;state:&lt;/p&gt;</span><br><span class="line">                    &lt;pre&gt;&#123;<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.state, <span class="literal">null</span>, <span class="number">2</span>)&#125;&lt;/pre&gt;</span><br><span class="line">                    &lt;p&gt;props:&lt;/p&gt;</span><br><span class="line">                    &lt;pre&gt;&#123;<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.props, <span class="literal">null</span>, <span class="number">2</span>)&#125;&lt;/pre&gt;</span><br><span class="line">                    &#123;<span class="built_in">super</span>.render()&#125;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>渲染劫持（<code>Render Highjacking</code>） 通过渲染劫持，我们可以：<ul>
<li>有条件地展示元素树（element tree）</li>
<li>操作由 render() 输出的 React 元素树</li>
<li>在任何由 render() 输出的 React 元素中操作 props</li>
<li>用其他元素包裹传入的组件<code>WrappedComponent</code>（同<strong>属性代理</strong>）</li>
</ul>
</li>
</ul>
<h3 id="高阶组件存在的问题"><a href="#高阶组件存在的问题" class="headerlink" title="高阶组件存在的问题"></a>高阶组件存在的问题</h3><h4 id="静态方法丢失"><a href="#静态方法丢失" class="headerlink" title="静态方法丢失"></a>静态方法丢失</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> 因为原始组件被包裹于一个容器组件内，也就意味着新组件会没有原始组件的任何静态方法：</span><br><span class="line"><span class="comment">// 定义静态方法</span></span><br><span class="line">WrappedComponent.staticMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用高阶组件</span></span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = HigherOrderComponent(WrappedComponent);</span><br><span class="line"><span class="comment">// 增强型组件没有静态方法</span></span><br><span class="line"><span class="keyword">typeof</span> EnhancedComponent.staticMethod === <span class="string">&#x27;undefined&#x27;</span> <span class="comment">// true</span></span><br><span class="line">所以必须将静态方法做拷贝：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HigherOrderComponent</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Enhance</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须得知道要拷贝的方法</span></span><br><span class="line">    Enhance.staticMethod = WrappedComponent.staticMethod;</span><br><span class="line">    <span class="keyword">return</span> Enhance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">但是这么做的一个缺点就是必须知道要拷贝的方法是什么，不过</span><br><span class="line">React</span><br><span class="line">社区实现了一个库</span><br><span class="line">hoist - non - react - statics</span><br><span class="line">来自动处理，它会</span><br><span class="line">自动拷贝所有非</span><br><span class="line">React</span><br><span class="line">的静态方法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hoistNonReactStatic <span class="keyword">from</span> <span class="string">&#x27;hoist-non-react-statics&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HigherOrderComponent</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Enhance</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hoistNonReactStatic(Enhance, WrappedComponent);</span><br><span class="line">    <span class="keyword">return</span> Enhance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="refs-属性不能透传"><a href="#refs-属性不能透传" class="headerlink" title="refs 属性不能透传"></a>refs 属性不能透传</h4><p>一般来说高阶组件可以传递所有的 props 给包裹的组件<code>WrappedComponent</code>，但是有一种属性不能传递，它就是 ref。与其他属性不同的地方在于 React 对其进行了特殊的处理。</p>
<p>如果你向一个由高阶组件创建的组件的元素添加 ref 引用，那么 ref 指向的是最外层容器组件实例的，而不是被包裹的 <code>WrappedComponent</code>组件。</p>
<p>不过，React 为我们提供了一个名为<code>React.forwardRef</code>的 API 来解决这一问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            data: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">                &lt;h1&gt;Learn React&lt;/h1&gt;</span><br><span class="line">                &lt;p&gt;</span><br><span class="line">                    &#123;<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.state, <span class="literal">null</span>, <span class="number">2</span>)&#125;</span><br><span class="line">                    &#123;<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.props, <span class="literal">null</span>, <span class="number">2</span>)&#125;</span><br><span class="line">                &lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLogging</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Enhance</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">UNSAFE_componentWillReceiveProps</span>(<span class="params">nextProps</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;Current props&#x27;</span>, <span class="built_in">this</span>.props);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;Next props&#x27;</span>, nextProps);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;forwardedRef, ...rest&#125; = <span class="built_in">this</span>.props;</span><br><span class="line">            <span class="comment">// 把 forwardedRef 赋值给 WrappedComponent 的 ref</span></span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...rest</span>&#125; <span class="attr">ref</span>=<span class="string">&#123;forwardedRef&#125;/</span>&gt;</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// React.forwardRef 方法会传入 props 和 ref 两个参数给其回调函数</span></span><br><span class="line">    <span class="comment">// 所以这边的 ref 是由 React.forwardRef 提供的</span></span><br><span class="line">    <span class="keyword">return</span> React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Enhance</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">data</span>=<span class="string">&#123;123&#125;</span> <span class="attr">forwardRef</span>=<span class="string">&#123;ref&#125;/</span>&gt;</span></span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withLogging(App)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="反向继承不能保证完整的子组件树被解析"><a href="#反向继承不能保证完整的子组件树被解析" class="headerlink" title="反向继承不能保证完整的子组件树被解析"></a>反向继承不能保证完整的子组件树被解析</h4><p>React 组件有两种形式，分别是 class 类型和 function 类型</p>
<p>我们知道反向继承的渲染劫持可以控制<code>WrappedComponent </code>的渲染过程，也就是说这个过程中我们可以对 elements tree、state、props 或 render() 的结果做各种操作</p>
<p>如果渲染 elements tree 中包含了 function 类型的组件的话，这时候就不能操作组件的子组件了</p>
<h3 id="高阶组件的约定"><a href="#高阶组件的约定" class="headerlink" title="高阶组件的约定"></a>高阶组件的约定</h3><p>高阶组件带给我们极大方便的同时，我们也要遵循一些 约定：</p>
<h4 id="props-保持一致"><a href="#props-保持一致" class="headerlink" title="props 保持一致"></a>props 保持一致</h4><p>高阶组件在为子组件添加特性的同时，要尽量保持原有组件的 props 不受影响，也就是说传入的组件和返回的组件在 props 上尽量保持一致。</p>
<p>不要改变原始组件<code>WrappedComponent</code><br>不要在高阶组件内以任何方式修改一个组件的原型，思考一下下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLogging</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    WrappedComponent.prototype.componentWillReceiveProps = <span class="function"><span class="keyword">function</span> (<span class="params">nextProps</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Current props&#x27;</span>, <span class="built_in">this</span>.props);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Next props&#x27;</span>, nextProps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> WrappedComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = withLogging(SomeComponent);</span><br></pre></td></tr></table></figure>

<p>会发现在高阶组件的内部对 <code>WrappedComponent</code>进行了修改，一旦对原组件进行了修改，那么就失去了组件复用的意义，所以请通过 纯函数（相同的输入总有相同的输出） 返回新的组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLogging</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;Current props&#x27;</span>, <span class="built_in">this</span>.props);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;Next props&#x27;</span>, nextProps);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// 透传参数，不要修改它</span></span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样优化之后的<code>withLogging </code>是一个 纯函数，并不会修改 <code>WrappedComponent</code>组件，所以不需要担心有什么副作用，进而达到组件复用的目的。</p>
<h4 id="透传不相关-props-属性给被包裹的组件-WrappedComponent"><a href="#透传不相关-props-属性给被包裹的组件-WrappedComponent" class="headerlink" title="透传不相关 props 属性给被包裹的组件 WrappedComponent"></a>透传不相关 props 属性给被包裹的组件 <code>WrappedComponent</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HigherOrderComponent</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不要在-render-方法中使用高阶组件"><a href="#不要在-render-方法中使用高阶组件" class="headerlink" title="不要在 render() 方法中使用高阶组件"></a>不要在 render() 方法中使用高阶组件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用高阶函数的时候每次都会返回一个新的组件</span></span><br><span class="line">        <span class="keyword">const</span> EnchancedComponent = enhance(WrappedComponent);</span><br><span class="line">        <span class="comment">// 每次 render 的时候，都会使子对象树完全被卸载和重新</span></span><br><span class="line">        <span class="comment">// 重新加载一个组件会引起原有组件的状态和它的所有子组件丢失</span></span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">EnchancedComponent</span>/&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-compose-组合高阶组件"><a href="#使用-compose-组合高阶组件" class="headerlink" title="使用 compose 组合高阶组件"></a>使用 compose 组合高阶组件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不要这么使用</span></span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent))；</span><br><span class="line"><span class="comment">// 可以使用一个 compose 函数组合这些高阶组件</span></span><br><span class="line"><span class="comment">// lodash, redux, ramda 等第三方库都提供了类似 `compose` 功能的函数</span></span><br><span class="line"><span class="keyword">const</span> enhance = compose(withRouter, connect(commentSelector))；</span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = enhance(WrappedComponent)；</span><br></pre></td></tr></table></figure>

<p>因为按照 约定 实现的高阶组件其实就是一个纯函数，如果多个函数的参数一样，所以就可以通过 compose 方法来组合这些函数。</p>
<p>使用 compose 组合高阶组件使用，可以显著提高代码的可读性和逻辑的清晰度。 包装显示名字以便于调试 高阶组件创建的容器组件在 React Developer Tools 中的表现和其它的普通组件是一样的。</p>
<p>为了便于调试，可以选择一个显示名字，传达它是一个高阶组件的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getDisplayName = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> WrappedComponent.displayName || WrappedComponent.name || <span class="string">&#x27;Component&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HigherOrderComponent</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HigherOrderComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;<span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HigherOrderComponent.displayName = <span class="string">`HigherOrderComponent(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line">    <span class="keyword">return</span> HigherOrderComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高阶组件的应用场景"><a href="#高阶组件的应用场景" class="headerlink" title="高阶组件的应用场景"></a>高阶组件的应用场景</h3><h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><p>利用高阶组件的<strong>条件渲染</strong> 特性可以对页面进行权限控制，权限控制一般分为两个维度：<strong>页面级别</strong> 和<strong>页面元素级别</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HOC.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultMessageMap = &#123;</span><br><span class="line">    <span class="string">&#x27;Admin&#x27;</span>: <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>您没有权限查看该页面，请联系管理员！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">    <span class="string">&#x27;VIP&#x27;</span>: <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>您未购买该模块，请联系销售试用！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">    <span class="string">&#x27;&#x27;</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 权限控制</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">role</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> withAuth = <span class="function"><span class="params">role</span> =&gt;</span> <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        state = &#123;</span><br><span class="line">            auth: <span class="literal">false</span>,</span><br><span class="line">            role: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="title">UNSAFE_componentWillMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123;<span class="attr">role</span>: currentRole&#125; = <span class="keyword">await</span> fetch(<span class="string">&#x27;//localhost:9090/userInfo&#x27;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">                <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                    auth: currentRole === role,</span><br><span class="line">                    role: currentRole</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                    auth: <span class="literal">false</span>,</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.state.auth) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> defaultMessageMap[<span class="built_in">this</span>.state.role]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withAuth</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// pages/PageA.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> withAuth <span class="keyword">from</span> <span class="string">&quot;../HOC&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 管理员专用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageA</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;管理员专用&lt;/h2&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withAuth(<span class="string">&#x27;Admin&#x27;</span>)(PageA);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// pages/PageB.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> withAuth <span class="keyword">from</span> <span class="string">&quot;../HOC&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VIP专用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageB</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;VIP专用&lt;/h2&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withAuth(<span class="string">&#x27;VIP&#x27;</span>)(PageB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pages/PageC.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> withAuth <span class="keyword">from</span> <span class="string">&quot;../HOC&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通用户使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;普通用户使用&lt;/h2&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> PageC;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="组件渲染性能追踪"><a href="#组件渲染性能追踪" class="headerlink" title="组件渲染性能追踪"></a>组件渲染性能追踪</h4><p>借助父组件子组件生命周期规则捕获子组件的生命周期，可以方便的对某个组件的渲染时间进行记录</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用【反向继承】实现的一个高阶组件，功能是计算被包裹组件的渲染时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">WrappedComponent</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withTiming</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(props);</span><br><span class="line">            <span class="built_in">this</span>.start = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.end = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">UNSAFE_componentWillMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.UNSAFE_componentWillMount &amp;&amp; <span class="built_in">super</span>.UNSAFE_componentWillMount();</span><br><span class="line">            <span class="built_in">this</span>.start = <span class="built_in">Date</span>.now();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.componentDidMount &amp;&amp; <span class="built_in">super</span>.componentDidMount();</span><br><span class="line">            <span class="built_in">this</span>.end = <span class="built_in">Date</span>.now();</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;WrappedComponent.name&#125;</span> 组件渲染时间为 <span class="subst">$&#123;<span class="built_in">this</span>.end - <span class="built_in">this</span>.start&#125;</span> ms`</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.render();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">                &lt;h1&gt;Learn React&lt;/h1&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withTiming(App)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="页面复用"><a href="#页面复用" class="headerlink" title="页面复用"></a>页面复用</h4><p>假设我们有三个页面 <code>pageA</code>，<code> pageB</code>，<code>pageC</code> 分别渲染<code>users列表</code>，<code>posts列表</code>, <code>comments列表</code>，普通写法可能是下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pages/PageA.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * users列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageA</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            data: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://jsonplaceholder.typicode.com/users?id_lte=10&#x27;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;data&#125;)</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;<span class="attr">data</span>: []&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;data&#125; = <span class="built_in">this</span>.state;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;users列表&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">                &lt;pre&gt; &#123;<span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="number">2</span>)&#125;&lt;/pre&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> PageA;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pages/PageB.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * posts列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageB</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            data: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://jsonplaceholder.typicode.com/posts?id_lte=10&#x27;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;data&#125;)</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;<span class="attr">data</span>: []&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;data&#125; = <span class="built_in">this</span>.state;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;posts列表&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">                &lt;pre&gt;&#123;<span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="number">2</span>)&#125;&lt;/pre&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> PageB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// pages/PageC</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * comments 列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            data: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://jsonplaceholder.typicode.com/comments?id_lte=10&#x27;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;data&#125;)</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;<span class="attr">data</span>: []&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;data&#125; = <span class="built_in">this</span>.state;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;comments列表&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">                &lt;pre&gt;&#123;<span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="number">2</span>)&#125;&lt;/pre&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> PageC;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>页面少的时候可能没什么问题，但是假如随着业务的进展，在这个页面展示更多类型的数据，就会写很多的重复代码，所以我们需要重构一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HOC.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> withFetching = <span class="function"><span class="params">fetchingFunc</span> =&gt;</span> <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        state = &#123;</span><br><span class="line">            data: [],</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> data = <span class="keyword">await</span> fetchingFunc();</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;data&#x27;</span>, data)</span><br><span class="line">                <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                    data,</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.setState(&#123;<span class="attr">data</span>: []&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withFetching</span><br><span class="line"></span><br><span class="line"><span class="comment">// pages/PageA.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> withFetching <span class="keyword">from</span> <span class="string">&quot;../HOC&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * users列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageA</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor(props) &#123;</span></span><br><span class="line">    <span class="comment">//     super(props);</span></span><br><span class="line">    <span class="comment">//     this.state = &#123;</span></span><br><span class="line">    <span class="comment">//         data: []</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// async componentDidMount() &#123;</span></span><br><span class="line">    <span class="comment">//     try &#123;</span></span><br><span class="line">    <span class="comment">//         const data = await fetch(&#x27;https://jsonplaceholder.typicode.com/users?id_lte=10&#x27;).then(response =&gt; response.json())</span></span><br><span class="line">    <span class="comment">//         this.setState(&#123;data&#125;)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//     &#125; catch &#123;</span></span><br><span class="line">    <span class="comment">//         this.setState(&#123;data: []&#125;)</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// const &#123;data&#125; = this.state;</span></span><br><span class="line">        <span class="keyword">const</span> &#123;data&#125; = <span class="built_in">this</span>.props;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;users列表&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">                &lt;pre&gt; &#123;<span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="number">2</span>)&#125;&lt;/pre&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// export default PageA;</span></span><br><span class="line"><span class="keyword">const</span> fetchingFunc = <span class="function">() =&gt;</span> fetch(<span class="string">&#x27;https://jsonplaceholder.typicode.com/users?id_lte=10&#x27;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withFetching(fetchingFunc)(PageA);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pages/PageB.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> withFetching <span class="keyword">from</span> <span class="string">&quot;../HOC&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * posts列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageB</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// const &#123;data&#125; = this.state;</span></span><br><span class="line">        <span class="keyword">const</span> &#123;data&#125; = <span class="built_in">this</span>.props;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;posts列表&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">                &lt;pre&gt;&#123;<span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="number">2</span>)&#125;&lt;/pre&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// export default PageB;</span></span><br><span class="line"><span class="keyword">const</span> fetchingFunc = <span class="function">() =&gt;</span> fetch(<span class="string">&#x27;https://jsonplaceholder.typicode.com/posts?id_lte=10&#x27;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withFetching(fetchingFunc)(PageB);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// pages/PageC.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> withFetching <span class="keyword">from</span> <span class="string">&quot;../HOC&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * comments 列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor(props) &#123;</span></span><br><span class="line">    <span class="comment">//     super(props);</span></span><br><span class="line">    <span class="comment">//     this.state = &#123;</span></span><br><span class="line">    <span class="comment">//         data: []</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// async componentDidMount() &#123;</span></span><br><span class="line">    <span class="comment">//     try &#123;</span></span><br><span class="line">    <span class="comment">//         const data = await fetch(&#x27;https://jsonplaceholder.typicode.com/comments?id_lte=10&#x27;).then(response =&gt; response.json())</span></span><br><span class="line">    <span class="comment">//         this.setState(&#123;data&#125;)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//     &#125; catch &#123;</span></span><br><span class="line">    <span class="comment">//         this.setState(&#123;data: []&#125;)</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// const &#123;data&#125; = this.state;</span></span><br><span class="line">        <span class="keyword">const</span> &#123;data&#125; = <span class="built_in">this</span>.props;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;comments列表&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">                &lt;pre&gt;&#123;<span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="number">2</span>)&#125;&lt;/pre&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// export default PageC;</span></span><br><span class="line"><span class="keyword">const</span> fetchingFunc = <span class="function">() =&gt;</span> fetch(<span class="string">&#x27;https://jsonplaceholder.typicode.com/comments?id_lte=10&#x27;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withFetching(fetchingFunc)(PageC);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h4><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h4 id="统计上报"><a href="#统计上报" class="headerlink" title="统计上报"></a>统计上报</h4><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>高阶组件 不是组件，是 一个把某个组件转换成另一个组件的 函数</li>
<li>高阶组件的主要作用是 代码复用</li>
<li>高阶组件是 装饰器模式在 React 中的实现</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>解析 webpack 核心——Babel 原理</title>
    <url>/bloger/2020/12/07/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/%E8%A7%A3%E6%9E%90%20webpack%20%E6%A0%B8%E5%BF%83%E2%80%94%E2%80%94Babel%20%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="解析-webpack-核心——Babel-原理"><a href="#解析-webpack-核心——Babel-原理" class="headerlink" title="解析 webpack 核心——Babel 原理"></a>解析 webpack 核心——Babel 原理</h1><h2 id="Babel-做了什么，怎么做的？"><a href="#Babel-做了什么，怎么做的？" class="headerlink" title="Babel 做了什么，怎么做的？"></a>Babel 做了什么，怎么做的？</h2><ul>
<li><p>Babel 将 ESNextCode 代码转换成了浏览器兼容的 ES5Code</p>
</li>
<li><p>其过程(code –(1)-&gt; ast –(2)-&gt; ast2 –(3)-&gt; code2)</p>
<ul>
<li><p>parse: 把代码 ESNextCode 变成 AST</p>
</li>
<li><p>traverse: 遍历 AST 进行修改得到 AST2</p>
</li>
<li><p>generate: 把 AST2 变成代码 ES5Code</p>
</li>
</ul>
</li>
<li><p>示例<code>let_to_var.ts</code></p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">&quot;@babel/parser&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">&quot;@babel/traverse&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> generate <span class="keyword">from</span> <span class="string">&quot;@babel/generator&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行 node -r ts-node/register --inspect-brk let_to_var.ts 浏览器Node里面看下数据结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`let a = &#x27;let&#x27;; let b = 2`</span>;</span><br><span class="line"><span class="comment">// Step1 parse  把代码code变成AST</span></span><br><span class="line"><span class="keyword">const</span> ast = parse(code, &#123; <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span> &#125;);</span><br><span class="line"><span class="comment">// console.log(&#x27;ast&#x27;, ast)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Step2 traverse  遍历AST进行修改</span></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  enter: <span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.node.type === <span class="string">&quot;VariableDeclaration&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.node.kind === <span class="string">&quot;let&quot;</span>) &#123;</span><br><span class="line">        item.node.kind = <span class="string">&quot;var&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step3 generate  把AST代码变成code2</span></span><br><span class="line"><span class="keyword">const</span> result = generate(ast, &#123;&#125;, code);</span><br><span class="line"><span class="comment">// console.log(result.code);</span></span><br></pre></td></tr></table></figure>

<p>运行<code>node -r ts-node/register --inspect-brk let_to_var.ts</code><br><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/webpack-1.png" alt="bash"><br><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/webpack-2.png" alt="Node Debugger"><br>最终结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let转为了var，还给代码加了分号</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;let&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="为什么非得使用-AST"><a href="#为什么非得使用-AST" class="headerlink" title="为什么非得使用 AST"></a>为什么非得使用 AST</h2><ul>
<li><p>你很难用正则表达式来替换，正则很容易把 let a = ‘let’ 变成 var a = ‘var’</p>
</li>
<li><p>你需要识别每个单词的意思，才能做到只修改用于声明变量的 let，而 AST 能明确地告诉你每个 let 的意思</p>
</li>
</ul>
<h2 id="能不能自动把代码转为-ES5Code-并单独文件输出？"><a href="#能不能自动把代码转为-ES5Code-并单独文件输出？" class="headerlink" title="能不能自动把代码转为 ES5Code 并单独文件输出？"></a>能不能自动把代码转为 ES5Code 并单独文件输出？</h2><ul>
<li><p>使用 <code>@babel/core</code> 和 <code>@babel/preset-env</code> 即可</p>
</li>
<li><p>代码如下：</p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;let&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(set);</span><br><span class="line"></span><br><span class="line"><span class="comment">// file_to_es5.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">&quot;@babel/parser&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babel <span class="keyword">from</span> <span class="string">&quot;@babel/core&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">&quot;fs&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = fs.readFileSync(<span class="string">&quot;./test.js&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = parse(code, &#123; <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">babel</span><br><span class="line">  .transformFromAstAsync(ast, code, &#123;</span><br><span class="line">    presets: [</span><br><span class="line">      <span class="comment">// 注意此处是一个数组，如果有options的话</span></span><br><span class="line">      <span class="comment">// useBuiltIns有三种选项：usage entry false</span></span><br><span class="line">      <span class="comment">// 具体参考：https://babel.docschina.org/docs/en/6.26.3/babel-polyfill/</span></span><br><span class="line">      [<span class="string">&quot;@babel/preset-env&quot;</span>, &#123; <span class="attr">useBuiltIns</span>: <span class="string">&quot;usage&quot;</span>, <span class="attr">corejs</span>: <span class="number">2</span> &#125;],</span><br><span class="line">    ],</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123; code &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.writeFileSync(<span class="string">&quot;./test.es5.js&quot;</span>, code);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>执行<code>node -r ts-node/register file_to_es5.ts</code>生成文件如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.es5.js</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;core-js/modules/web.dom.iterable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;core-js/modules/es6.array.iterator&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;core-js/modules/es6.object.to-string&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;core-js/modules/es6.string.iterator&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;core-js/modules/es6.set&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;let&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(set);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：Babel 默认只转换新的 JavaScript 语法，而不转换新的 API。 例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。 如果想使用这些新的对象和方法，则需要为当前环境提供一个 polyfill<br>具体：<code>yarn add babel-polyfill core-js@2</code></p>
</blockquote>
<h2 id="Babel-还做了什么"><a href="#Babel-还做了什么" class="headerlink" title="Babel 还做了什么?"></a>Babel 还做了什么?</h2><blockquote>
<p>分析 JS 文件的依赖关系</p>
</blockquote>
<ul>
<li>简单依赖<code>project_1</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// deps_1.ts</span></span><br><span class="line"><span class="comment">// 请确保你的 Node 版本大于等于 14</span></span><br><span class="line"><span class="comment">// 请先运行 yarn 或 npm i 来安装依赖</span></span><br><span class="line"><span class="comment">// 然后使用 node -r ts-node/register 文件路径 来运行，</span></span><br><span class="line"><span class="comment">// 如果需要调试，可以加一个选项 --inspect-brk，再打开 Chrome 开发者工具，点击 Node 图标即可调试</span></span><br><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">&#x27;@babel/parser&#x27;</span></span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">&#x27;@babel/traverse&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFileSync &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; resolve, relative, dirname &#125; <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置根目录</span></span><br><span class="line"><span class="keyword">const</span> projectRoot = resolve(__dirname, <span class="string">&#x27;project_1&#x27;</span>)</span><br><span class="line"><span class="comment">// 类型声明</span></span><br><span class="line">type DepRelation = &#123; [key: string]: &#123; <span class="attr">deps</span>: string[], <span class="attr">code</span>: string &#125; &#125;</span><br><span class="line"><span class="comment">// 初始化一个空的 depRelation，用于收集依赖</span></span><br><span class="line"><span class="keyword">const</span> depRelation: DepRelation = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将入口文件的绝对路径传入函数，如 D:\demo\fixture_1\index.js</span></span><br><span class="line">collectCodeAndDeps(resolve(projectRoot, <span class="string">&#x27;index.js&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(depRelation)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;done&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectCodeAndDeps</span>(<span class="params">filepath: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> key = getProjectPath(filepath) <span class="comment">// 文件的项目路径，如 index.js</span></span><br><span class="line">  <span class="comment">// 获取文件内容，将内容放至 depRelation</span></span><br><span class="line">  <span class="keyword">const</span> code = readFileSync(filepath).toString()</span><br><span class="line">  <span class="comment">// 初始化 depRelation[key]</span></span><br><span class="line">  depRelation[key] = &#123; <span class="attr">deps</span>: [], <span class="attr">code</span>: code &#125;</span><br><span class="line">  <span class="comment">// 将代码转为 AST</span></span><br><span class="line">  <span class="keyword">const</span> ast = parse(code, &#123; <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span> &#125;)</span><br><span class="line">  <span class="comment">// 分析文件依赖，将内容放至 depRelation</span></span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    enter: <span class="function"><span class="params">path</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (path.node.type === <span class="string">&#x27;ImportDeclaration&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// path.node.source.value 往往是一个相对路径，如 ./a.js，需要先把它转为一个绝对路径</span></span><br><span class="line">        <span class="keyword">const</span> depAbsolutePath = resolve(dirname(filepath), path.node.source.value)</span><br><span class="line">        <span class="comment">// 然后转为项目路径</span></span><br><span class="line">        <span class="keyword">const</span> depProjectPath = getProjectPath(depAbsolutePath)</span><br><span class="line">        <span class="comment">// 把依赖写进 depRelation</span></span><br><span class="line">        depRelation[key].deps.push(depProjectPath)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件相对于根目录的相对路径</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProjectPath</span>(<span class="params">path: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> relative(projectRoot, path).replace(<span class="regexp">/\\/g</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// project_1/a.js</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  value: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment">// project_1/b.js</span></span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  value: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">// project_1/index.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&#x27;./b.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.value + b.value)</span><br></pre></td></tr></table></figure>

<p>执行<code>node -r ts-node/register deps_1.ts</code>结果输出如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&#x27;index.js&#x27;</span>: &#123;</span><br><span class="line">    deps: [ <span class="string">&#x27;a.js&#x27;</span>, <span class="string">&#x27;b.js&#x27;</span> ],</span><br><span class="line">    code: <span class="string">&quot;import a from &#x27;./a.js&#x27;\r\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;import b from &#x27;./b.js&#x27;\r\n&quot;</span> +</span><br><span class="line">      <span class="string">&#x27;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;console.log(a.value + b.value)&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>嵌套依赖<code>project_2</code><br>目录结构如图：<br><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/webpack-3.png" alt="文件目录"></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// deps_2.ts</span></span><br><span class="line"><span class="comment">// 请确保你的 Node 版本大于等于 14</span></span><br><span class="line"><span class="comment">// 请先运行 yarn 或 npm i 来安装依赖</span></span><br><span class="line"><span class="comment">// 然后使用 node -r ts-node/register 文件路径 来运行，</span></span><br><span class="line"><span class="comment">// 如果需要调试，可以加一个选项 --inspect-brk，再打开 Chrome 开发者工具，点击 Node 图标即可调试</span></span><br><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">&#x27;@babel/parser&#x27;</span></span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">&#x27;@babel/traverse&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFileSync &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; resolve, relative, dirname &#125; <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置根目录</span></span><br><span class="line"><span class="keyword">const</span> projectRoot = resolve(__dirname, <span class="string">&#x27;project_2&#x27;</span>)</span><br><span class="line"><span class="comment">// 类型声明</span></span><br><span class="line">type DepRelation = &#123; [key: string]: &#123; <span class="attr">deps</span>: string[], <span class="attr">code</span>: string &#125; &#125;</span><br><span class="line"><span class="comment">// 初始化一个空的 depRelation，用于收集依赖</span></span><br><span class="line"><span class="keyword">const</span> depRelation: DepRelation = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将入口文件的绝对路径传入函数，如 D:\demo\fixture_1\index.js</span></span><br><span class="line">collectCodeAndDeps(resolve(projectRoot, <span class="string">&#x27;index.js&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(depRelation)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;done&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectCodeAndDeps</span>(<span class="params">filepath: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> key = getProjectPath(filepath) <span class="comment">// 文件的项目路径，如 index.js</span></span><br><span class="line">  <span class="comment">// 获取文件内容，将内容放至 depRelation</span></span><br><span class="line">  <span class="keyword">const</span> code = readFileSync(filepath).toString()</span><br><span class="line">  <span class="comment">// 初始化 depRelation[key]</span></span><br><span class="line">  depRelation[key] = &#123; <span class="attr">deps</span>: [], <span class="attr">code</span>: code &#125;</span><br><span class="line">  <span class="comment">// 将代码转为 AST</span></span><br><span class="line">  <span class="keyword">const</span> ast = parse(code, &#123; <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span> &#125;)</span><br><span class="line">  <span class="comment">// 分析文件依赖，将内容放至 depRelation</span></span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    enter: <span class="function"><span class="params">path</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (path.node.type === <span class="string">&#x27;ImportDeclaration&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// path.node.source.value 往往是一个相对路径，如 ./a.js，需要先把它转为一个绝对路径</span></span><br><span class="line">        <span class="keyword">const</span> depAbsolutePath = resolve(dirname(filepath), path.node.source.value)</span><br><span class="line">        <span class="comment">// 然后转为项目路径</span></span><br><span class="line">        <span class="keyword">const</span> depProjectPath = getProjectPath(depAbsolutePath)</span><br><span class="line">        <span class="comment">// 把依赖写进 depRelation</span></span><br><span class="line">        depRelation[key].deps.push(depProjectPath)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note: 相比于deps_1.ts只加了一行代码  继续往下分析  递归</span></span><br><span class="line">        collectCodeAndDeps(depAbsolutePath)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件相对于根目录的相对路径</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProjectPath</span>(<span class="params">path: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> relative(projectRoot, path).replace(<span class="regexp">/\\/g</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// project_2/index.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&#x27;./b.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.value + b.value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// project_2/a.js</span></span><br><span class="line"><span class="keyword">import</span> a2 <span class="keyword">from</span> <span class="string">&#x27;./dir/a2.js&#x27;</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  value2: a2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment">// project_2/b.js</span></span><br><span class="line"><span class="keyword">import</span> b2 <span class="keyword">from</span> <span class="string">&#x27;./dir/b2.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  value2: b2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">// project_2/dir/a2.js</span></span><br><span class="line"><span class="keyword">import</span> a3 <span class="keyword">from</span> <span class="string">&#x27;./dir_in_dir/a3.js&#x27;</span></span><br><span class="line"><span class="keyword">const</span> a2 = &#123;</span><br><span class="line">  value: <span class="number">12</span>,</span><br><span class="line">  value3: a3</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a2</span><br><span class="line"></span><br><span class="line"><span class="comment">// project_2/dir/b2.js</span></span><br><span class="line"><span class="keyword">import</span> b3 <span class="keyword">from</span> <span class="string">&#x27;./dir_in_dir/b3.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b2 = &#123;</span><br><span class="line">  value: <span class="number">22</span>,</span><br><span class="line">  value3: b3</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> b2</span><br><span class="line"></span><br><span class="line"><span class="comment">// project_2/dir/dir_in_dir/a3.js</span></span><br><span class="line"><span class="keyword">const</span> a3 = &#123;</span><br><span class="line">  value: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a3</span><br><span class="line"></span><br><span class="line"><span class="comment">// project_2/dir/dir_in_dir/b3.js</span></span><br><span class="line"><span class="keyword">const</span> b3 = &#123;</span><br><span class="line">  value: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> b3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行<code>node -r ts-node/register deps_2.ts</code>结果输出如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&#x27;index.js&#x27;</span>: &#123;</span><br><span class="line">    deps: [ <span class="string">&#x27;a.js&#x27;</span>, <span class="string">&#x27;b.js&#x27;</span> ],</span><br><span class="line">    code: <span class="string">&quot;import a from &#x27;./a.js&#x27;\r\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;import b from &#x27;./b.js&#x27;\r\n&quot;</span> +</span><br><span class="line">      <span class="string">&#x27;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;console.log(a.value + b.value)&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;a.js&#x27;</span>: &#123;</span><br><span class="line">    deps: [ <span class="string">&#x27;dir/a2.js&#x27;</span> ],</span><br><span class="line">    code: <span class="string">&quot;import a2 from &#x27;./dir/a2.js&#x27;\r\n&quot;</span> +</span><br><span class="line">      <span class="string">&#x27;const a = &#123;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;  value: 1,\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;  value2: a2\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;&#125;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;export default a&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;dir/a2.js&#x27;</span>: &#123;</span><br><span class="line">    deps: [ <span class="string">&#x27;dir/dir_in_dir/a3.js&#x27;</span> ],</span><br><span class="line">    code: <span class="string">&quot;import a3 from &#x27;./dir_in_dir/a3.js&#x27;\r\n&quot;</span> +</span><br><span class="line">      <span class="string">&#x27;const a2 = &#123;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;  value: 12,\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;  value3: a3\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;&#125;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;export default a2&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;dir/dir_in_dir/a3.js&#x27;</span>: &#123;</span><br><span class="line">    deps: [],</span><br><span class="line">    code: <span class="string">&#x27;const a3 = &#123;\r\n  value: 123\r\n&#125;\r\nexport default a3&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;b.js&#x27;</span>: &#123;</span><br><span class="line">    deps: [ <span class="string">&#x27;dir/b2.js&#x27;</span> ],</span><br><span class="line">    code: <span class="string">&quot;import b2 from &#x27;./dir/b2.js&#x27;\r\n&quot;</span> +</span><br><span class="line">      <span class="string">&#x27;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;const b = &#123;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;  value: 2,\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;  value2: b2\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;&#125;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;export default b&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;dir/b2.js&#x27;</span>: &#123;</span><br><span class="line">    deps: [ <span class="string">&#x27;dir/dir_in_dir/b3.js&#x27;</span> ],</span><br><span class="line">    code: <span class="string">&quot;import b3 from &#x27;./dir_in_dir/b3.js&#x27;\r\n&quot;</span> +</span><br><span class="line">      <span class="string">&#x27;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;const b2 = &#123;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;  value: 22,\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;  value3: b3\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;&#125;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;export default b2&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;dir/dir_in_dir/b3.js&#x27;</span>: &#123;</span><br><span class="line">    deps: [],</span><br><span class="line">    code: <span class="string">&#x27;const b3 = &#123;\r\n  value: 123\r\n&#125;\r\nexport default b3&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>嵌套依赖<code>project_3</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// project_3/index.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&#x27;./b.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.value + b.value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// project_3/a.js</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&#x27;./b.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  value: b.value + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment">// project_3/b.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  value: a.value + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">// deps_3.ts同deps_2.ts</span></span><br></pre></td></tr></table></figure>

<p>执行<code>node -r ts-node/register deps_3.ts</code>报错<code>RangeError: Maximum call stack size exceeded</code>说明出现了循环嵌套</p>
<ul>
<li>嵌套依赖解决<code>project_4</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// project_4文件同project_3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// deps_4.ts</span></span><br><span class="line"><span class="comment">// 请确保你的 Node 版本大于等于 14</span></span><br><span class="line"><span class="comment">// 请先运行 yarn 或 npm i 来安装依赖</span></span><br><span class="line"><span class="comment">// 然后使用 node -r ts-node/register 文件路径 来运行，</span></span><br><span class="line"><span class="comment">// 如果需要调试，可以加一个选项 --inspect-brk，再打开 Chrome 开发者工具，点击 Node 图标即可调试</span></span><br><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">&quot;@babel/parser&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">&quot;@babel/traverse&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; readFileSync &#125; <span class="keyword">from</span> <span class="string">&quot;fs&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; resolve, relative, dirname &#125; <span class="keyword">from</span> <span class="string">&quot;path&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置根目录</span></span><br><span class="line"><span class="keyword">const</span> projectRoot = resolve(__dirname, <span class="string">&quot;project_3&quot;</span>);</span><br><span class="line"><span class="comment">// 类型声明</span></span><br><span class="line">type DepRelation = &#123; [key: string]: &#123; <span class="attr">deps</span>: string[], <span class="attr">code</span>: string &#125; &#125;;</span><br><span class="line"><span class="comment">// 初始化一个空的 depRelation，用于收集依赖</span></span><br><span class="line"><span class="keyword">const</span> depRelation: DepRelation = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将入口文件的绝对路径传入函数，如 D:\demo\fixture_1\index.js</span></span><br><span class="line">collectCodeAndDeps(resolve(projectRoot, <span class="string">&quot;index.js&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(depRelation);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;done&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectCodeAndDeps</span>(<span class="params">filepath: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> key = getProjectPath(filepath); <span class="comment">// 文件的项目路径，如 index.js</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note: 相比于deps_3.ts只加一行代码  避免循环依赖</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(depRelation).includes(key)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">`duplicated dependency: <span class="subst">$&#123;key&#125;</span>`</span>); <span class="comment">// 注意，重复依赖不一定是循环依赖</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取文件内容，将内容放至 depRelation</span></span><br><span class="line">  <span class="keyword">const</span> code = readFileSync(filepath).toString();</span><br><span class="line">  <span class="comment">// 初始化 depRelation[key]</span></span><br><span class="line">  depRelation[key] = &#123; <span class="attr">deps</span>: [], <span class="attr">code</span>: code &#125;;</span><br><span class="line">  <span class="comment">// 将代码转为 AST</span></span><br><span class="line">  <span class="keyword">const</span> ast = parse(code, &#123; <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span> &#125;);</span><br><span class="line">  <span class="comment">// 分析文件依赖，将内容放至 depRelation</span></span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    enter: <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (path.node.type === <span class="string">&quot;ImportDeclaration&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// path.node.source.value 往往是一个相对路径，如 ./a.js，需要先把它转为一个绝对路径</span></span><br><span class="line">        <span class="keyword">const</span> depAbsolutePath = resolve(</span><br><span class="line">          dirname(filepath),</span><br><span class="line">          path.node.source.value</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 然后转为项目路径</span></span><br><span class="line">        <span class="keyword">const</span> depProjectPath = getProjectPath(depAbsolutePath);</span><br><span class="line">        <span class="comment">// 把依赖写进 depRelation</span></span><br><span class="line">        depRelation[key].deps.push(depProjectPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note: 相比于deps_1.ts只加了一行代码  继续往下分析  递归</span></span><br><span class="line">        collectCodeAndDeps(depAbsolutePath);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件相对于根目录的相对路径</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProjectPath</span>(<span class="params">path: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> relative(projectRoot, path).replace(<span class="regexp">/\\/g</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>node -r ts-node/register deps_4.ts</code>结果如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">duplicated dependency: a.js</span><br><span class="line">duplicated dependency: b.js</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&#x27;index.js&#x27;</span>: &#123;</span><br><span class="line">    deps: [ <span class="string">&#x27;a.js&#x27;</span>, <span class="string">&#x27;b.js&#x27;</span> ],</span><br><span class="line">    code: <span class="string">&quot;import a from &#x27;./a.js&#x27;\r\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;import b from &#x27;./b.js&#x27;\r\n&quot;</span> +</span><br><span class="line">      <span class="string">&#x27;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;console.log(a.value + b.value)&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;a.js&#x27;</span>: &#123;</span><br><span class="line">    deps: [ <span class="string">&#x27;b.js&#x27;</span> ],</span><br><span class="line">    code: <span class="string">&quot;import b from &#x27;./b.js&#x27;\r\n&quot;</span> +</span><br><span class="line">      <span class="string">&#x27;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;const a = &#123;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;  value: b.value + 1\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;&#125;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;export default a&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;b.js&#x27;</span>: &#123;</span><br><span class="line">    deps: [ <span class="string">&#x27;a.js&#x27;</span> ],</span><br><span class="line">    code: <span class="string">&quot;import a from &#x27;./a.js&#x27;\r\n&quot;</span> +</span><br><span class="line">      <span class="string">&#x27;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;const b = &#123;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;  value: a.value + 1\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;&#125;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;export default b&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>node project_4/index.js</code>会报错</p>
<ul>
<li>循环依赖 有的循环依赖可以正常运行<code>project_5</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// project_4/index.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&#x27;./b.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.getB())</span><br><span class="line"><span class="built_in">console</span>.log(b.getA())</span><br><span class="line"></span><br><span class="line"><span class="comment">// project_4/a.js</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&#x27;./b.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  value: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  getB: <span class="function">() =&gt;</span> b.value + <span class="string">&#x27; from a.js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment">// project_4/b.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  value: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  getA: <span class="function">() =&gt;</span> a.value + <span class="string">&#x27; from b.js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">// deps_5.ts同deps_4.ts</span></span><br></pre></td></tr></table></figure>

<p>执行<code>node -r ts-node/register deps_5.ts</code>结果如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">duplicated dependency: a.js</span><br><span class="line">duplicated dependency: b.js</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&#x27;index.js&#x27;</span>: &#123;</span><br><span class="line">    deps: [ <span class="string">&#x27;a.js&#x27;</span>, <span class="string">&#x27;b.js&#x27;</span> ],</span><br><span class="line">    code: <span class="string">&quot;import a from &#x27;./a.js&#x27;\r\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;import b from &#x27;./b.js&#x27;\r\n&quot;</span> +</span><br><span class="line">      <span class="string">&#x27;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;console.log(a.getB())\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;console.log(b.getA())&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;a.js&#x27;</span>: &#123;</span><br><span class="line">    deps: [ <span class="string">&#x27;b.js&#x27;</span> ],</span><br><span class="line">    code: <span class="string">&quot;import b from &#x27;./b.js&#x27;\r\n&quot;</span> +</span><br><span class="line">      <span class="string">&#x27;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;const a = &#123;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&quot;  value: &#x27;a&#x27;,\r\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;  getB: () =&gt; b.value + &#x27; from a.js&#x27;\r\n&quot;</span> +</span><br><span class="line">      <span class="string">&#x27;&#125;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;export default a&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;b.js&#x27;</span>: &#123;</span><br><span class="line">    deps: [ <span class="string">&#x27;a.js&#x27;</span> ],</span><br><span class="line">    code: <span class="string">&quot;import a from &#x27;./a.js&#x27;\r\n&quot;</span> +</span><br><span class="line">      <span class="string">&#x27;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;const b = &#123;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&quot;  value: &#x27;b&#x27;,\r\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;  getA: () =&gt; a.value + &#x27; from b.js&#x27;\r\n&quot;</span> +</span><br><span class="line">      <span class="string">&#x27;&#125;\r\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;export default b&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>node project_5/index.js</code>不会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">b <span class="keyword">from</span> a.js</span><br><span class="line">a <span class="keyword">from</span> b.js</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="Babel-原理-AST"><a href="#Babel-原理-AST" class="headerlink" title="Babel 原理(AST)"></a>Babel 原理(AST)</h3><ul>
<li>parse 把代码 code 变成 AST</li>
<li>traverse 遍历 AST 进行修改</li>
<li>generate 把 AST 变成代码 code2</li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li><p>babel 可以把高级代码翻译为 ES5</p>
</li>
<li><p>@babel/parser</p>
</li>
<li><p>@babel/traverse</p>
</li>
<li><p>@babel/generator</p>
</li>
<li><p>@babel/core 包含前三者</p>
</li>
<li><p>@babel/preset-env 内置很多规则</p>
</li>
</ul>
<h3 id="代码技巧"><a href="#代码技巧" class="headerlink" title="代码技巧"></a>代码技巧</h3><ul>
<li><p>通过哈希表存储数据</p>
</li>
<li><p>通过检测 key 避免重复</p>
</li>
</ul>
<h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><ul>
<li><p>有的循环依赖可以正常执行</p>
</li>
<li><p>有的循环依赖不可以</p>
</li>
<li><p>但都可以做静态分析</p>
</li>
</ul>
<blockquote>
<p>源码参考：<a href="https://github.com/Matthrews/webpack-core">https://github.com/Matthrews/webpack-core</a></p>
</blockquote>
]]></content>
      <categories>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>Webpack Babel</tag>
      </tags>
  </entry>
  <entry>
    <title>ChromeV8是如何工作的</title>
    <url>/bloger/2021/05/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/ChromeV8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
    <content><![CDATA[<h1 id="Chrome-V8-是如何工作的"><a href="#Chrome-V8-是如何工作的" class="headerlink" title="Chrome V8 是如何工作的"></a>Chrome V8 是如何工作的</h1><p>我们知道，V8 是 Google 开源的 JavaScript 引擎，被广泛应用于各种 JavaScript 执行环境，比如 Chrome 浏览器、NodeJS、Electron 以及 Deno。但是，很多前端开发人员对 V8 的理解还停留在表面，只是单纯地使用 JavaScript 和调用 Web API, 并不了解 V8 这个黑盒内部是如何工作的。我们只有搞清楚这个问题，才能写出性能更好，更优雅的 JavaScript 代码。</p>
<p>同时，了解 JavaScript 的执行原理，也能够让你更轻松的理解 Babel 的词法分析和语法分析原理、ESLint 的原发检查机制、React 和 Vue 等前端框架的底层实现，以后你在面对其他新的技术和新框架，也能够以不变应万变。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/v8.jpg" alt="v8"></p>
<p>所以，我们先从宏观上学习 V8 架构的演进历史，了解 V8 是如何演进成如此成熟的架构，然后在此基础上深入学习 V8 执行 JavaScript 过程中的词法分析、语法分析、解释器、优化编译器的工作机制及原理，让我们知其然并知其所以然。</p>
<h2 id="V8-架构演进"><a href="#V8-架构演进" class="headerlink" title="V8 架构演进"></a>V8 架构演进</h2><p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/v82.jpg" alt="v82"></p>
<p>2008 年，V8 发布了第一个版本，V8 刚一发布，其性能远超同时期竞争对手，比如 SpiderMonkey、JavaScriptCore，关注度非常高。不过，当时 V8 架构比较激进，是直接将 JavaScript 代码编译为机器码并执行，所以执行速度很快。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/v83.jpg" alt="v83"></p>
<p>但在这个结构中，V8 只有 Codegen 一个编译器，对代码的优化很有限。所以在 2010 年 V8 发布了 Crankshaft 编译器，JavaScript 函数通常会先被 Full-Codegen 编译器，如果后续该函数会被多次执行，那么就是用 Crankshaft 再重新编译，生成更优化的代码，之后就是用优化后的代码来执行，进而提升性能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/v84.jpg" alt="v84"></p>
<p>但是 Crankshaft 对代码的优化有限, 所以 2015 年 V8 中加入了 TurboFan。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/v85.jpg" alt="v85"></p>
<p>这时的 V8 依旧是直接将源码编译为机器码的架构，这种架构存在核心问题是内存消耗过大，尤其是在移动设备上，通过 Full-Codegen 编译出来的代码，几乎占整个 Chrome 浏览器的三分之一的内存，这样为代码运行时留下的内存就更少了，于是 2016 年 V8 加入了 Ignition 解释器，重新引入了字节码，旨在减少内存使用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/v86.jpg" alt="v86"></p>
<p>2017 年 V8 正式发布全新编译 pipeline，也就是使用 Ignition 和 TurboFan 的组合来编译执行代码。从 V85.9 版本开始，早期的 Full-Codegen 和 Crankshaft 编译器就不再用来执行 JavaScript 代码，在最新的架构中，最核心的就三个模块：解析器(Parser)、解释器(Ignition)、优化编译器(TurboFan)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/v87.jpg" alt="v87"></p>
<p>所以，接下来我们从解析、解释、编译三个部分触发，深入学习 V8 中 JavaScript 的代码执行逻辑。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/v88.jpg" alt="v88"></p>
<p>当 V8 执行 JavaScript 源码时，首先解析器会把源码解析为抽象语法树(Abstract Sytntax Tree)，然后解释器再将 AST 翻译为字节码，一边解释一边执行，在此过程中，解释器会记录特定代码片段的运行次数，如果运行次数超过某个阈值，那么这段代码就被标记为热代码(Hot Code)，并将运行信息反馈给优化编译器，优化编译器根据反馈信息优化并编译字节码，最终生成优化后的机器码。这样，当该段代码再次执行时，解释器就直接使用优化机器码执行，不用再次解释，从而大大提高了代码运行效率，这种在运行时编译代码的技术也被称为即时编译(JIT)，通过 JIT，可以极大提升 JavaScript 代码的执行性能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/v89.jpg" alt="v89"></p>
<p>那么解析器是如何把源码转换为 AST 呢？首先我们要清楚，要让 V8 执行我们编写的源码，那么就要将源码转换为 V8 能理解的格式，V8 首先会把源码解析为一个抽象语法树(AST)，抽象语法树是用来表现源码树结构的对象，这个过程称为解析(Parsing)，主要由 V8 的 Parser 模块实现，然后 V8 的解释器会把 AST 编译为字节码</p>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/parser.jpg" alt="parser"></p>
<p>解析和编译过程的性能非常重要，因为 V8 只有等编译完成后才能运行代码，整个解析的过程可以分为两部分：</p>
<ul>
<li>第一部分词法分析(Lexical Analysis)，词法分析就是将字符流转换为 tokens，字符流就是我们编写的一行行代码，token 是指语法上不能再分割的最小单位，可能是单个字符，也可能是字符串，图中的 Scanner 就是 V8 的词法分析器</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/parser2.jpg" alt="parser2"></p>
<ul>
<li>第二部分语法分析(Syntax Analysis), 语法分析是根据语法规则将 tokens 组成一个有嵌套层级的的抽象语法树，在这个过程中，如果源码不符合语法规范，解析过程就会终止，并抛出语法错误。图中的 Parser 和 Pre-Parser 都是 V8 的语法分析器。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/parser3.jpg" alt="parser3"></p>
<p>接下来我们就详细看一下词法分析和语法分析</p>
<p>首先是词法分析，在 V8 中，Scanner 负责接收 Unicode 字符流，并将其解析为 tokens，提供给解析器使用。比如<code>var a = 1;</code>这行代码词法分析后得 tokens 如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Keyword&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;var&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;a&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Punctuator&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;=&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Numeric&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Punctuator&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>可以看到，我们这行代码包括 5 个 tokens： <code>关键字var</code>, <code>标识符a</code>，<code>赋值运算符=</code>， <code>数字1</code>以及<code>分隔符;</code></p>
<p>加下来，V8 解析器会通过语法分析，根据 tokens 生成 AST，这行代码生成的 AST 如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Program&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;body&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;VariableDeclaration&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;declarations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;VariableDeclarator&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;id&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;a&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;init&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Literal&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;var&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;sourceType&quot;</span>: <span class="string">&quot;script&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以在<a href="https://esprima.org/demo/parse.html?code=var%20a%20=%201;%0A">在线工具</a>上修改代码，观察 AST 的结构</p>
<p>但是，对于一份 JavaScript 源码，如果所有源码在执行前都要完全经过解析才能执行，那必然会面临三个问题：</p>
<ul>
<li><p>代码执行时间变长，因为一次性解析所有代码必然会增加代码的运行时间</p>
</li>
<li><p>消耗更多内存，因为解析完的 AST 以及根据 AST 编译后的字节码都会放在内存中，这样必然会消耗更多的内存</p>
</li>
<li><p>占用磁盘空间，因为编译后的代码还会缓存在磁盘上，所以会重用磁盘空间</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/p1.jpg" alt="p1"></p>
<p>因此，现在主流的 JavaScript 引擎都实现了<code>延迟解析</code>, 延迟解析的思想很简单，就是在解析过程中，对于那些不是立即执行的函数，只进行预解析(Pre-Parser)，只有当函数调用时才对函数进行全量解析。进行预解析时，只验证函数的语法是否有效，解析函数声明以及确定函数作用域，不生成 AST。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/p2.jpg" alt="p2"></p>
<p>实现预解析的就是 Pre-Parser 解析器, 以如下代码为例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = a + b;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>由于 Scanner 是按字节流从上往下一行行读取代码，所以 V8 解析器也是从上往下解析代码，当 V8 解析器解释到函数声明时，发现他不是立即执行的，会使用 Pre-Parser 解释器对其预解析，这个过程中，只会解析函数声明，不会解析函数内部的代码，不会为函数内部的代码生成 AST，然后 Ignition 解释器会把 AST 编译为字节码并执行，解释器也会按照自上而下的顺序执行代码，先执行<code>var a = 1;</code>和<code>var b = 2;</code>两个赋值表达式，然后再执行函数调用<code>foo(1, 2);</code>, 这是 Parser 解析器才会继续解析函数内的代码并生成 AST，再将该 AST 交给 Ignition 解释器编译执行。</p>
<p>那么解释器(Ignition)是如何将 AST 翻译为字节码并执行的呢？在 V8 架构的演进中，V8 为了解决内存占用问题引入了字节码，如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/byte.jpg" alt="byte"></p>
<p>通常，一个几 KB 的文件转换为机器码可能就是几十兆，这回消耗巨大的内存空间，所以 V8 引入了字节码。V8 的字节码是对机器码的抽象，其语法与汇编有些类似，你可以把 V8 字节码看成一个个指令，这些指令组合在一起，就实现了我们编写的功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/byte2.jpg" alt="byte2"></p>
<p>V8 一共定义了几百个字节码，你可以在 V8 解释器的头文件中查看所有的字节码，Ignition 解释器在执行字节码时, 主要使用了通用寄存器和累加寄存器，其中，函数参数和局部变量都保存在通用寄存器中，而累加寄存器用于保存中间结果，让我们来看一段代码来进一步学习字节码的执行流程</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = c - <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> a + d * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">5</span>, <span class="number">2</span>, <span class="number">150</span>);</span><br></pre></td></tr></table></figure>

<p>首先，我们定义了一个含有三个参数的函数 f，函数的功能就是对参数进行计算，并返回值。<br>假设我们以参数 5, 2, 150 调用这个函数，那么 Ignition 解释器首先会把函数编译为字节码，执行<code>node --print-bytecode test/index.js &gt; bytecode.txt</code>来查看 JavaScript 文件生成的字节码输出到<code>bytecode.txt</code>文件，打开该文件直接查看文件末尾的字节码如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">[generated bytecode for function: f (0x00ece2c7ad59 &lt;SharedFunctionInfo f&gt;)]</span><br><span class="line">Parameter count 4</span><br><span class="line">Register count 1</span><br><span class="line">Frame size 8</span><br><span class="line">   33 S&gt; 000000ECE2C7B4D6 @    0 : 25 02             Ldar a2</span><br><span class="line">   35 E&gt; 000000ECE2C7B4D8 @    2 : 41 64 00          SubSmi [100], [0]</span><br><span class="line">         000000ECE2C7B4DB @    5 : 26 fb             Star r0</span><br><span class="line">   45 S&gt; 000000ECE2C7B4DD @    7 : 25 03             Ldar a1</span><br><span class="line">   58 E&gt; 000000ECE2C7B4DF @    9 : 36 fb 02          Mul r0, [2]</span><br><span class="line">   54 E&gt; 000000ECE2C7B4E2 @   12 : 34 04 01          Add a0, [1]</span><br><span class="line">   62 S&gt; 000000ECE2C7B4E5 @   15 : aa                Return</span><br><span class="line">Constant pool (size = 0)</span><br><span class="line">Handler Table (size = 0)</span><br><span class="line">Source Position Table (size = 14)</span><br><span class="line">0x00ece2c7b4e9 &lt;ByteArray[14]&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/byte3.jpg" alt="byte3"></p>
<p>如图所示，当 Ignition 解释器执行代码时，首先会把参数分别加载到 a0, a1, a2 寄存器上，图中的 accumulator 表示累加寄存器，然后在逐行执行字节码。<code>Ldar a2</code>表示将 a2 寄存器的值加载到累加寄存器中，加载后，累加寄存器的值就变为了 150<br><code>SubSmi [100]</code>表示将累加寄存器的值减少 100，这时累加寄存器的值就变为了 50，<code>[0]</code>表示反馈向量(FeedBack Vector)的索引，反馈向量就记录了函数在执行过程中的一些关键数据。<code>Star r0</code>表示把累加寄存器的值保存在寄存器 r0 中，这时 r0 的值就变为了 50，<code>Ldar a1</code>表示将 a1 寄存器的值加载到累加寄存器中，这时累加寄存器的值就变为了 2，<br><code>Mul r0, [2]</code>表示将累加寄存器的值与 r0 寄存器的值相乘，并将结果再次放入累加寄存器，其中<code>[2]</code>同样是反馈向量，执行完毕后，accumulator 的值就变成了 100，<code>Add a0, [1]</code>表示将累加寄存器的值与 a0 寄存器的值相加，并将结果再次放入累加寄存器，这是 accumulator 的值就变成了 105，Return 表示结束当前函数的执行并返回累加寄存器中的值。所以最终函数的执行结果时 105</p>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/byte9.jpg" alt="byte9"><br>这里需要注意的是，Ignition 解释器在执行字节码时，依旧需要将字节码转换为机器码，因为 CPU 只能识别机器码，虽然多了一层字节码的转换，看起来效率低了，但是相比于机器码，基于字节码可以更方便进行行性能优化。<br><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/byte10.jpg" alt="byte10"><br>而 V8 的确也做了很多性能优化的工作，其中，最主要的就是使用 TurboFan 编译器编译热点代码，这些性能优化，使得如今基于字节码架构的行呢个优化要远超当年直接编译机器码架构的性能</p>
<p>Ignition 解释器在解释执行的过程中，会标记重复执行的热点代码，这些被标记的代码，会被 TurboFan 编译器编译生成效率更高的机器码，那么 TurboFan 编译器具体是怎么工作的呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/byte11.jpg" alt="byte11"></p>
<p>其中，主要有两个算法，一个是内联，一个是逃逸分析，我们先看看内联</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">three</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码如果未经优化，直接编译该段代码，会分别生成两个函数的机器码</p>
<p>但为了进一步提升性能，TurboFan 编译器就会对以上两个函数进行内联，然后再编译</p>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/byte12.jpg" alt="byte12"></p>
<p>由于函数内部的行为就是求 1 和 2 的和，所以这段代码就有了改变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">three_add_inlined</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> add_return_value = x + y;</span><br><span class="line">  <span class="keyword">return</span> add_return_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更进一步，由于函数 three_add_inlined 中的 x 和 y 的值都是确定的，所以 three_add_inlined 还可以优化，直接返回结果 3</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">three_add_const_folded</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终编译生成的机器码相比优化前就少了非常之多，执行效率自然也高了很多。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/byte13.jpg" alt="byte13"></p>
<p>通过内联，可以降低复杂度，消除冗余代码，合并常量，并且内联技术通常也是逃逸分析的基础。那么什么是逃逸分析呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/t1.jpg" alt="t1"></p>
<p>简单来说，它是指分析对象的的生命周期，是否仅局限于当前函数</p>
<p>让我们在来看一个简单的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 求曼哈顿距离</span></span><br><span class="line">  <span class="function"><span class="title">distance</span>(<span class="params">that</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs(<span class="built_in">this</span>.x - that.x) + <span class="built_in">Math</span>.abs(<span class="built_in">this</span>.y - that.y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">manhattan</span>(<span class="params">x1, y1, x2, y2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">new</span> Point(x1, y1);</span><br><span class="line">  <span class="keyword">const</span> b = <span class="keyword">new</span> Point(x2, y2;</span><br><span class="line">  <span class="keyword">return</span> a.distance(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TurboFan 编译器首先会通过内联，将 manhattan 函数转换为如下函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">manhattan_inlined</span>(<span class="params">x1, y1, x2, y2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = &#123; <span class="attr">x</span>: x1, <span class="attr">y</span>: y1 &#125;;</span><br><span class="line">  <span class="keyword">const</span> b = &#123; <span class="attr">x</span>: x2, <span class="attr">y</span>: y2 &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(a.x - b.x) + <span class="built_in">Math</span>.abs(a.y - b.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样函数看起来就简单多了，再接下来，就会对 manhattan_inlined 中的对象进行逃逸分析</p>
<p>什么样的对象会被认为是“未逃逸”的呢？主要要满足如下两个条件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/t2.jpg" alt="t2"></p>
<p>首先，对象是在函数内部定义；其次，对象只作用于函数内部。比如，函数没有被返回，也没有传递或者给其他函数调用</p>
<p>在 manhattan_inlined 函数中，变量 a 和 b 都是函数里内部普通变量，所以他们都是未逃逸对象，那么我们就可以对函数中的对象进行替换了，使用变量替换掉对象，这样函数内部就不再有对象定义，取而代之的是 a_x, a_y, b_x, b_y，并且直接来源于函数参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">manhattan_scalar_eplacement</span>(<span class="params">x1, y1, x2, y2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a_x = x1;</span><br><span class="line">  <span class="keyword">const</span> a_y = y1;</span><br><span class="line">  <span class="keyword">const</span> b_x = x2;</span><br><span class="line">  <span class="keyword">const</span> b_y = y2;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(a_x - b_x) + <span class="built_in">Math</span>.abs(a_y - b_y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做的好处就是，我们可以直接将变量加载到寄存器上，不再需要从内存中访问对象了，提升了执行效率的同时，还减少了内存的使用</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>V8 架构演进史</li>
</ul>
<p>最初，V8 是没有字节码的，直接将 JavaScript 源码编译为机器码执行，这种架构导致内存占用过高</p>
<p>后来引入了字节码</p>
<ul>
<li>V8 执行 JavaScript 的原理</li>
</ul>
<p>大致分为第三个步骤</p>
<p>首先，解释器将 JavaScript 源码解析为 AST，解析过程分为词法分析和语法分析，V8 通过预解析提升执行效率</p>
<p>然后，解释器 Ignition 根据 AST 生成字节码并执行，这个过程中会收集反馈信息，交给 TurboFan 进行优化编译，TurboFan 根据 Ignition 收集的反馈信息，将字节码编译为优化后的机器码，后续 Ignition 用优化机器码代替字节码执行，进而提升性能</p>
<!-- https://segmentfault.com/a/1190000040331440 -->
]]></content>
      <categories>
        <category>浏览器相关</category>
      </categories>
      <tags>
        <tag>V8</tag>
      </tags>
  </entry>
  <entry>
    <title>精简版React源码手稿</title>
    <url>/bloger/2022/03/11/UI%E6%A1%86%E6%9E%B6/%E7%B2%BE%E7%AE%80%E7%89%88React%E6%BA%90%E7%A0%81%E6%89%8B%E7%A8%BF/</url>
    <content><![CDATA[<h1 id="精简版-React-源码手稿"><a href="#精简版-React-源码手稿" class="headerlink" title="精简版 React 源码手稿"></a>精简版 React 源码手稿</h1><blockquote>
<p>TLDR: 全是源码，适合看过源码想回头细看的同学</p>
</blockquote>
<blockquote>
<p>本次分享源码版本<a href="mailto:&#x72;&#x65;&#x61;&#x63;&#x74;&#64;&#49;&#x36;&#46;&#x36;&#x2e;&#48;">&#x72;&#x65;&#x61;&#x63;&#x74;&#64;&#49;&#x36;&#46;&#x36;&#x2e;&#48;</a>和react@16.7.0</p>
</blockquote>
<blockquote>
<p>注：本此分享更多的是源码，概念性的东西读者可自行查阅官网文档或者 YouTube React Conference</p>
</blockquote>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><ul>
<li><p>packages/react</p>
</li>
<li><p>packages/react-dom</p>
</li>
<li><p>packages/react-reconciler</p>
</li>
</ul>
<p>平台无关 DOM 操作，包括任务调度</p>
<h2 id="JSX-到-JS"><a href="#JSX-到-JS" class="headerlink" title="JSX 到 JS"></a>JSX 到 JS</h2><p>React.createElement, 入参 type, config, children，返回一个对象</p>
<h2 id="API-源码"><a href="#API-源码" class="headerlink" title="API 源码"></a>API 源码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react\src\React.js</span></span><br><span class="line"><span class="comment">// 暴露出来的API</span></span><br><span class="line"><span class="keyword">const</span> React = &#123;</span><br><span class="line">  Children: &#123;</span><br><span class="line">    map,</span><br><span class="line">    forEach,</span><br><span class="line">    count,</span><br><span class="line">    toArray,</span><br><span class="line">    only,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  createRef,</span><br><span class="line">  Component,</span><br><span class="line">  PureComponent,</span><br><span class="line"></span><br><span class="line">  createContext,</span><br><span class="line">  forwardRef,</span><br><span class="line">  lazy,</span><br><span class="line">  memo,</span><br><span class="line"></span><br><span class="line">  Fragment: REACT_FRAGMENT_TYPE,</span><br><span class="line">  StrictMode: REACT_STRICT_MODE_TYPE,</span><br><span class="line">  unstable_ConcurrentMode: REACT_CONCURRENT_MODE_TYPE,</span><br><span class="line">  Suspense: REACT_SUSPENSE_TYPE,</span><br><span class="line">  unstable_Profiler: REACT_PROFILER_TYPE,</span><br><span class="line"></span><br><span class="line">  createElement: __DEV__ ? createElementWithValidation : createElement,</span><br><span class="line">  cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement,</span><br><span class="line">  createFactory: __DEV__ ? createFactoryWithValidation : createFactory,</span><br><span class="line">  isValidElement: isValidElement,</span><br><span class="line"></span><br><span class="line">  version: ReactVersion,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React;</span><br></pre></td></tr></table></figure>

<h3 id="React-Element"><a href="#React-Element" class="headerlink" title="React Element"></a>React Element</h3><ul>
<li>React Element 是什么？</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react\src\ReactElement.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create and return a new ReactElement of the given type.</span></span><br><span class="line"><span class="comment"> * See https://reactjs.org/docs/react-api.html#createelement</span></span><br><span class="line"><span class="comment"> * type 类型  原生标签的话是一个字符串，自定义组件的话是一个变量</span></span><br><span class="line"><span class="comment"> * config 节点attributes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, config, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> propName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reserved names are extracted</span></span><br><span class="line">  <span class="keyword">const</span> props = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> ref = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> source = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析上述四个字段以及props属性</span></span><br><span class="line">  <span class="comment">// for/in</span></span><br><span class="line">  <span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasValidRef(config)) &#123;</span><br><span class="line">      ref = config.ref;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasValidKey(config)) &#123;</span><br><span class="line">      key = <span class="string">&quot;&quot;</span> + config.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self = config.__self === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__self;</span><br><span class="line">    source = config.__source === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__source;</span><br><span class="line">    <span class="comment">// Remaining properties are added to a new props object</span></span><br><span class="line">    <span class="keyword">for</span> (propName <span class="keyword">in</span> config) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class="line">        !RESERVED_PROPS.hasOwnProperty(propName)</span><br><span class="line">      ) &#123;</span><br><span class="line">        props[propName] = config[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * https://babeljs.io/repl</span></span><br><span class="line"><span class="comment">   * const jsx = </span></span><br><span class="line"><span class="comment">  &lt;div key=&quot;435ksdfds&quot; class=&quot;wrapper&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;span&gt;matthew&lt;/span&gt;</span></span><br><span class="line"><span class="comment">    &lt;span&gt;green&lt;/span&gt;</span></span><br><span class="line"><span class="comment">  &lt;/div&gt; </span></span><br><span class="line"><span class="comment">   * 转换为js就是</span></span><br><span class="line"><span class="comment">   * const jsx = React.createElement(</span></span><br><span class="line"><span class="comment">    &quot;div&quot;,</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        key: &quot;435ksdfds&quot;,</span></span><br><span class="line"><span class="comment">        class: &quot;wrapper&quot;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    React.createElement(&quot;span&quot;, null, &quot;matthew&quot;),</span></span><br><span class="line"><span class="comment">    React.createElement(&quot;span&quot;, null, &quot;green&quot;)</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">   * 可以看到children从三个参数开始</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 找到props的children属性，children可能是对象也可能是数组</span></span><br><span class="line">  <span class="keyword">const</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">    props.children = children;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> childArray = <span class="built_in">Array</span>(childrenLength);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    props.children = childArray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Resolve default props</span></span><br><span class="line">  <span class="comment">// 这里只有Class组件才会走到，因为原生标签type就是一个字符串</span></span><br><span class="line">  <span class="comment">// 判断有没有使用的是undefined</span></span><br><span class="line">  <span class="keyword">if</span> (type &amp;&amp; type.defaultProps) &#123;</span><br><span class="line">    <span class="keyword">const</span> defaultProps = type.defaultProps;</span><br><span class="line">    <span class="keyword">for</span> (propName <span class="keyword">in</span> defaultProps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (props[propName] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        props[propName] = defaultProps[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ReactElement(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    ReactCurrentOwner.current, <span class="comment">// 当前Fiber节点, 后面解析</span></span><br><span class="line">    props</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react\src\ReactElement.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory method to create a new React element.</span></span><br><span class="line"><span class="comment"> * 不是通过class模式创建的，所以不要使用new</span></span><br><span class="line"><span class="comment"> * 也不要用instanceOf检测类型，而因该通过Symbol.for(&#x27;react.element&#x27;)检测类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ReactElement返回一个对象</span></span><br><span class="line"><span class="comment"> * 这也是VDOM diff的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> ReactElement = <span class="function"><span class="keyword">function</span> (<span class="params">type, key, ref, self, source, owner, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = &#123;</span><br><span class="line">    <span class="comment">// 通过Symbol唯一确定是否是React Element</span></span><br><span class="line">    <span class="comment">// 同时兼具安全的功能</span></span><br><span class="line">    <span class="comment">// Symbol参考：https://www.jianshu.com/p/f6e0972b24d0</span></span><br><span class="line">    $$typeof: REACT_ELEMENT_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Built-in properties that belong on the element</span></span><br><span class="line">    type: type,</span><br><span class="line">    key: key,</span><br><span class="line">    ref: ref,</span><br><span class="line">    props: props,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record the component responsible for creating this element.</span></span><br><span class="line">    _owner: owner, <span class="comment">// 父Fiber节点</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\shared\ReactSymbols.js</span></span><br><span class="line"><span class="comment">// 如果没有Symbol就使用一个简单的字符</span></span><br><span class="line"><span class="keyword">const</span> hasSymbol = <span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">&quot;function&quot;</span> &amp;&amp; <span class="built_in">Symbol</span>.for;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REACT_ELEMENT_TYPE = hasSymbol</span><br><span class="line">  ? <span class="built_in">Symbol</span>.for(<span class="string">&quot;react.element&quot;</span>)</span><br><span class="line">  : <span class="number">0xeac7</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>React Element 只是一个普通的 JavaScript 对象，用来告诉 React 怎么创建真实的 DOM</p>
</blockquote>
<blockquote>
<p>新的疑问： 1. $$typeof 如何使用的 2. type, key, ref,owner 如何使用的</p>
</blockquote>
<h3 id="React-Component"><a href="#React-Component" class="headerlink" title="React Component"></a>React Component</h3><ul>
<li><p>什么是 React Component？和 React Element 有啥不一样？</p>
</li>
<li><p>猜测组件应该是 React Element 的集合，也就是返回一个大对象，应该还提供一些方法用于更新卸载捕获异常吧</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react\src\ReactElement.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; Component, PureComponent &#125; <span class="keyword">from</span> <span class="string">&quot;./ReactBaseClasses&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react\src\ReactBaseClasses.js</span></span><br><span class="line"><span class="comment">// 更新Component state 的基类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">props, context, updater</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.props = props;</span><br><span class="line">  <span class="comment">// read from getInitialState</span></span><br><span class="line">  <span class="comment">// 可用于跨层级通信</span></span><br><span class="line">  <span class="built_in">this</span>.context = context;</span><br><span class="line">  <span class="comment">// If a component has string refs, we will assign a different object later.</span></span><br><span class="line">  <span class="built_in">this</span>.refs = emptyObject;</span><br><span class="line">  <span class="comment">// We initialize the default updater but the real one gets injected by the</span></span><br><span class="line">  <span class="comment">// renderer.</span></span><br><span class="line">  <span class="built_in">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Component.prototype.isReactComponent = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * this.state是不可变的，想要修改需要手动调用setState修改</span></span><br><span class="line"><span class="comment"> * this.state 不一定是立即更新的</span></span><br><span class="line"><span class="comment"> * setState 不一定是同步的，因为有可能有批处理环节</span></span><br><span class="line"><span class="comment"> * 如果有callback，它将会再setState完成后调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;object|function&#125;</span> </span>partialState Next partial state or function to</span></span><br><span class="line"><span class="comment"> * produce next partial state to be merged with current state.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;?function&#125;</span> </span>callback Called after state is updated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Component.prototype.setState = <span class="function"><span class="keyword">function</span> (<span class="params">partialState, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.updater.enqueueSetState(<span class="built_in">this</span>, partialState, callback, <span class="string">&quot;setState&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认情况下，当组件的 state 或 props 发生变化时，组件将重新渲染。</span></span><br><span class="line"><span class="comment"> * 如果 render 方法依赖于其他数据，则可以调用 forceUpdate 强制让组件重新渲染</span></span><br><span class="line"><span class="comment"> * 不会调用 shouldComponentUpdate，但会调用 componentWillUpdate 和 componentDidUpdate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Component.prototype.forceUpdate = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.updater.enqueueForceUpdate(<span class="built_in">this</span>, callback, <span class="string">&quot;forceUpdate&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 含有默认浅比较的Component</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PureComponent</span>(<span class="params">props, context, updater</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.props = props;</span><br><span class="line">  <span class="built_in">this</span>.context = context;</span><br><span class="line">  <span class="built_in">this</span>.refs = emptyObject;</span><br><span class="line">  <span class="built_in">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pureComponentPrototype = (PureComponent.prototype = <span class="keyword">new</span> ComponentDummy());</span><br><span class="line">pureComponentPrototype.constructor = PureComponent;</span><br><span class="line"><span class="built_in">Object</span>.assign(pureComponentPrototype, Component.prototype);</span><br><span class="line"><span class="comment">// 看起来和Component就只有下面这点区别了</span></span><br><span class="line">pureComponentPrototype.isPureReactComponent = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Component 是一个基类，提供了 setState 和 forceUpdate 两个方法</p>
</blockquote>
<blockquote>
<p>新的疑问： setState 和 forceUpdate 貌似进了 enqueueSetState 队列之类的东西，后面发生了什么</p>
</blockquote>
<h3 id="ReactRef-amp-ref"><a href="#ReactRef-amp-ref" class="headerlink" title="ReactRef &amp; ref"></a>ReactRef &amp; ref</h3><p>用于获取 DOM 实例，应该尽量避免过多使用</p>
<p>有三种使用姿势: <code>stringRef, function ref, React.createRef</code></p>
<p><a href="https://reactjs.org/docs/forwarding-refs.html">Forwarding Refs</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 举例使用ref</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.objRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    <span class="comment">// this.refs.stringRef</span></span><br><span class="line">    <span class="comment">// this.methodRef</span></span><br><span class="line">    <span class="comment">// this.myRef.current</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;p ref=<span class="string">&quot;stringRef&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">        &lt;p ref=&#123;<span class="function">(<span class="params">obj</span>) =&gt;</span> (<span class="built_in">this</span>.methodRef = obj)&#125;&gt;&lt;/p&gt;</span><br><span class="line">        &lt;p ref=&#123;<span class="built_in">this</span>.objRef&#125;&gt;&lt;/p&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react\src\ReactCreateRef.js</span></span><br><span class="line"><span class="comment">// 看了源码的发现就返回了这么一个简单对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createRef</span>(<span class="params"></span>): <span class="title">RefObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> refObject = &#123;</span><br><span class="line">    current: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> refObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>新问题：Component 和 createRef 中 ref 后续是如何使用的</p>
</blockquote>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>两种使用方式，childContextType(即将在 react@17 版本中废弃), createContext</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demos\src\context\index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&quot;prop-types&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; Provider, Consumer &#125; = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    childContext: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">    newContext: <span class="string">&quot;456&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getChildContext</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="built_in">this</span>.state.childContext &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;label&gt;childContext: &lt;/label&gt;</span><br><span class="line">          &lt;input</span><br><span class="line">            type=<span class="string">&quot;text&quot;</span></span><br><span class="line">            value=&#123;<span class="built_in">this</span>.state.childContext&#125;</span><br><span class="line">            onChange=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.setState(&#123; <span class="attr">childContext</span>: e.target.value &#125;)&#125;</span><br><span class="line">          /&gt;</span><br><span class="line"></span><br><span class="line">          &lt;br /&gt;</span><br><span class="line">          &lt;br /&gt;</span><br><span class="line">          &lt;label&gt;newContext: &lt;/label&gt;</span><br><span class="line">          &lt;input</span><br><span class="line">            type=<span class="string">&quot;text&quot;</span></span><br><span class="line">            value=&#123;<span class="built_in">this</span>.state.newContext&#125;</span><br><span class="line">            onChange=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.setState(&#123; <span class="attr">newContext</span>: e.target.value &#125;)&#125;</span><br><span class="line">          /&gt;</span><br><span class="line"></span><br><span class="line">          &lt;Provider value=&#123;<span class="built_in">this</span>.state.newContext&#125;&gt;</span><br><span class="line">            &#123;<span class="built_in">this</span>.props.children&#125;</span><br><span class="line">          &lt;/Provider&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Consumer</span>&gt;</span>&#123;(value) =&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>newContext: &#123;value&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;<span class="tag">&lt;/<span class="name">Consumer</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>childContext: &#123;this.context.value&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 务必申明，否则拿不到</span></span><br><span class="line">Child2.contextTypes = &#123;</span><br><span class="line">  value: PropTypes.string,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 务必申明，否则报错</span></span><br><span class="line">Parent.childContextTypes = &#123;</span><br><span class="line">  value: PropTypes.string,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Demo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Parent&gt;</span><br><span class="line">      &lt;Child1 /&gt;</span><br><span class="line">      &lt;Child2 /&gt;</span><br><span class="line">    &lt;/Parent&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Demo;</span><br></pre></td></tr></table></figure>

<p>再看看源码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react\src\ReactElement.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">&quot;./ReactContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react\src\ReactContext.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createContext</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  defaultValue: T,</span></span></span><br><span class="line"><span class="function"><span class="params">  calculateChangedBits: ?(a: T, b: T) =&gt; number</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ReactContext</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> context: ReactContext&lt;T&gt; = &#123;</span><br><span class="line">    $$typeof: REACT_CONTEXT_TYPE,</span><br><span class="line">    <span class="comment">// As a workaround to support multiple concurrent renderers, we categorize</span></span><br><span class="line">    <span class="comment">// some renderers as primary and others as secondary. We only expect</span></span><br><span class="line">    <span class="comment">// there to be two concurrent renderers at most: React Native (primary) and</span></span><br><span class="line">    <span class="comment">// Fabric (secondary); React DOM (primary) and React ART (secondary).</span></span><br><span class="line">    <span class="comment">// Secondary renderers store their context values on separate fields.</span></span><br><span class="line">    <span class="comment">// 两个变量值相同，是同的地方不同而已</span></span><br><span class="line">    _currentValue: defaultValue,</span><br><span class="line">    _currentValue2: defaultValue,</span><br><span class="line">    <span class="comment">// These are circular</span></span><br><span class="line">    Provider: (<span class="literal">null</span>: any),</span><br><span class="line">    Consumer: (<span class="literal">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  context.Provider = &#123;</span><br><span class="line">    $$typeof: REACT_PROVIDER_TYPE,</span><br><span class="line">    _context: context,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 又指向了自己，意味着Consumer还可以是Provider继续向下无限传递</span></span><br><span class="line">  context.Consumer = context;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentMode"><a href="#ConcurrentMode" class="headerlink" title="ConcurrentMode"></a>ConcurrentMode</h3><p>之前是 AsyncMode<br>react@16 之后提出的一种优先级策略，它使得 react 的渲染是可以中断的, 从而可以操作渲染调度，最终让渲染更加流畅</p>
<p>案列可以参考 demo</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react\src\React.js</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// unstable_ConcurrentMode只是一个Symbol</span></span><br><span class="line">unstable_ConcurrentMode: REACT_CONCURRENT_MODE_TYPE,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h3><blockquote>
<p>参考：<a href="https://www.infoq.cn/article/sVaeA7Y3pei2sYy_lK9e">React 的未来：与 Suspense 共舞</a></p>
</blockquote>
<ul>
<li><p>React Suspense 是组件从缓存中加载数据时暂停呈现的一种通行方法。它解决的问题：渲染是和 I/O 绑定时的情况。</p>
</li>
<li><p>支持 lazy, 此时 lazy 的组件会被 webpack 进行代码分割处理</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 在包裹的异步组件全部加载完毕之后Spinner才消失</span></span><br><span class="line">    &lt;React.Suspense fallback=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Spinner</span> /&gt;</span></span>&#125;&gt;</span><br><span class="line">      &lt;LazyComponent /&gt;</span><br><span class="line">      &lt;LazyComponent2 /&gt;</span><br><span class="line">    &lt;/React.Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react\src\React.js</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// Suspense只是一个Symbol</span></span><br><span class="line">Suspense: REACT_SUSPENSE_TYPE,</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react\src\React.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;lazy&#125; <span class="keyword">from</span> <span class="string">&#x27;./ReactLazy&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react\src\ReactLazy.js</span></span><br><span class="line"><span class="comment">// 是一个函数，接受一个thenable函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">lazy</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt;(<span class="params">ctor: () =&gt; Thenable&lt;T, R&gt;</span>): <span class="title">LazyComponent</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    $$typeof: REACT_LAZY_TYPE,</span><br><span class="line">    _ctor: ctor,</span><br><span class="line">    <span class="comment">// React uses these fields to store the result.</span></span><br><span class="line">    _status: -<span class="number">1</span>,</span><br><span class="line">    _result: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Suspense 只是一个 Symbol</p>
</blockquote>
<blockquote>
<p>新的问题： 一个 Symbol 是如何承载元素的？</p>
</blockquote>
<h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><blockquote>
<p><a href="https://reactjs.org/docs/hooks-intro.html">Hook 简介</a></p>
</blockquote>
<blockquote>
<p><a href="mailto:&#x72;&#x65;&#x61;&#99;&#116;&#x40;&#49;&#54;&#x2e;&#55;&#46;&#x30;">&#x72;&#x65;&#x61;&#99;&#116;&#x40;&#49;&#54;&#x2e;&#55;&#46;&#x30;</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react\src\React.js</span></span><br><span class="line"><span class="keyword">if</span> (enableHooks) &#123;</span><br><span class="line">  React.useCallback = useCallback;</span><br><span class="line">  React.useContext = useContext;</span><br><span class="line">  React.useEffect = useEffect;</span><br><span class="line">  React.useImperativeMethods = useImperativeMethods;</span><br><span class="line">  React.useLayoutEffect = useLayoutEffect;</span><br><span class="line">  React.useMemo = useMemo;</span><br><span class="line">  React.useReducer = useReducer;</span><br><span class="line">  React.useRef = useRef;</span><br><span class="line">  React.useState = useState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react\src\ReactHooks.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useState</span>&lt;<span class="title">S</span>&gt;(<span class="params">initialState: (() =&gt; S) | S</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: () =&gt; mixed,</span></span></span><br><span class="line"><span class="function"><span class="params">  inputs: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useEffect(create, inputs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一步是在dom渲染的时候才拿到的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveDispatcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = ReactCurrentOwner.currentDispatcher;</span><br><span class="line">  <span class="keyword">return</span> dispatcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染的时候从不同平台传进来的全局对象</span></span><br><span class="line"><span class="keyword">const</span> ReactCurrentOwner = &#123;</span><br><span class="line">  current: (<span class="literal">null</span>: <span class="literal">null</span> | Fiber),</span><br><span class="line">  currentDispatcher: (<span class="literal">null</span>: <span class="literal">null</span> | Dispatcher),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>hooks 都挂载在 ReactCurrentOwner 全局对象上</p>
</blockquote>
<blockquote>
<p>新的问题： ReactCurrentOwner 是什么</p>
</blockquote>
<h3 id="Children"><a href="#Children" class="headerlink" title="Children"></a>Children</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react\src\React.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; forEach, map, count, toArray, only &#125; <span class="keyword">from</span> <span class="string">&quot;./ReactChildren&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> React = &#123;</span><br><span class="line">  Children: &#123;</span><br><span class="line">    map, <span class="comment">// 和普通数组map区别在于最终结果是一维数组，不管你怎么嵌套</span></span><br><span class="line">    forEach,</span><br><span class="line">    count,</span><br><span class="line">    toArray,</span><br><span class="line">    only,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react\src\ReactChildren.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapChildren</span>(<span class="params">children, func, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (children == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  mapIntoWithKeyPrefixInternal(children, result, <span class="literal">null</span>, func, context);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mapChildren 的处理流程如下图：<br><img src="https://cdn.jsdelivr.net/gh/Matthrews/zm_cdn/images/mapChildren.png" alt="mapChildren"></p>
<p>看懂流程图我们再深入源码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react\src\ReactChildren.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapIntoWithKeyPrefixInternal</span>(<span class="params">children, array, prefix, func, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> escapedPrefix = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (prefix != <span class="literal">null</span>) &#123;</span><br><span class="line">    escapedPrefix = escapeUserProvidedKey(prefix) + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> traverseContext = getPooledTraverseContext(</span><br><span class="line">    array,</span><br><span class="line">    escapedPrefix,</span><br><span class="line">    func,</span><br><span class="line">    context</span><br><span class="line">  );</span><br><span class="line">  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);</span><br><span class="line">  releaseTraverseContext(traverseContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mapSingleChildIntoContext</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapSingleChildIntoContext</span>(<span class="params">bookKeeping, child, childKey</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// bookKeeping就是从对象池里面取出来的traverseContext</span></span><br><span class="line">  <span class="keyword">const</span> &#123; result, keyPrefix, func, context &#125; = bookKeeping;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> mappedChild = func.call(context, child, bookKeeping.count++);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(mappedChild)) &#123;</span><br><span class="line">    <span class="comment">// 外层递归，此时对象池的作用就体现出来了</span></span><br><span class="line">    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, <span class="function">(<span class="params">c</span>) =&gt;</span> c);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappedChild != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isValidElement(mappedChild)) &#123;</span><br><span class="line">      <span class="comment">// cloneAndReplaceKey</span></span><br><span class="line">      mappedChild = cloneAndReplaceKey(</span><br><span class="line">        mappedChild,</span><br><span class="line">        <span class="comment">// Keep both the (mapped) and old keys if they differ, just as</span></span><br><span class="line">        <span class="comment">// traverseAllChildren used to do for objects as children</span></span><br><span class="line">        keyPrefix +</span><br><span class="line">          (mappedChild.key &amp;&amp; (!child || child.key !== mappedChild.key)</span><br><span class="line">            ? escapeUserProvidedKey(mappedChild.key) + <span class="string">&quot;/&quot;</span></span><br><span class="line">            : <span class="string">&quot;&quot;</span>) +</span><br><span class="line">          childKey</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(mappedChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traverseAllChildren</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverseAllChildren</span>(<span class="params">children, callback, traverseContext</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (children == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> traverseAllChildrenImpl(children, <span class="string">&quot;&quot;</span>, callback, traverseContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traverseAllChildrenImpl</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverseAllChildrenImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children,</span></span></span><br><span class="line"><span class="function"><span class="params">  nameSoFar,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback,</span></span></span><br><span class="line"><span class="function"><span class="params">  traverseContext</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="keyword">typeof</span> children;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&quot;undefined&quot;</span> || type === <span class="string">&quot;boolean&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// All of the above are perceived as null.</span></span><br><span class="line">    children = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> invokeCallback = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (children === <span class="literal">null</span>) &#123;</span><br><span class="line">    invokeCallback = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;string&quot;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;number&quot;</span>:</span><br><span class="line">        invokeCallback = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;object&quot;</span>:</span><br><span class="line">        <span class="keyword">switch</span> (children.$$typeof) &#123;</span><br><span class="line">          <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">          <span class="keyword">case</span> REACT_PORTAL_TYPE:</span><br><span class="line">            invokeCallback = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (invokeCallback) &#123;</span><br><span class="line">    callback(</span><br><span class="line">      traverseContext,</span><br><span class="line">      children,</span><br><span class="line">      <span class="comment">// If it&#x27;s the only child, treat the name as if it was wrapped in an array</span></span><br><span class="line">      <span class="comment">// so that it&#x27;s consistent if the number of children grows.</span></span><br><span class="line">      nameSoFar === <span class="string">&quot;&quot;</span> ? SEPARATOR + getComponentKey(children, <span class="number">0</span>) : nameSoFar</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> child;</span><br><span class="line">  <span class="keyword">let</span> nextName;</span><br><span class="line">  <span class="keyword">let</span> subtreeCount = <span class="number">0</span>; <span class="comment">// Count of children found in the current subtree.</span></span><br><span class="line">  <span class="keyword">const</span> nextNamePrefix =</span><br><span class="line">    nameSoFar === <span class="string">&quot;&quot;</span> ? SEPARATOR : nameSoFar + SUBSEPARATOR;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">    <span class="comment">// 开始递归调用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">      child = children[i];</span><br><span class="line">      nextName = nextNamePrefix + getComponentKey(child, i);</span><br><span class="line">      subtreeCount += traverseAllChildrenImpl(</span><br><span class="line">        child,</span><br><span class="line">        nextName,</span><br><span class="line">        callback,</span><br><span class="line">        traverseContext</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> iteratorFn = getIteratorFn(children);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> iteratorFn === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> iterator = iteratorFn.call(children);</span><br><span class="line">      <span class="keyword">let</span> step;</span><br><span class="line">      <span class="keyword">let</span> ii = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (!(step = iterator.next()).done) &#123;</span><br><span class="line">        child = step.value;</span><br><span class="line">        nextName = nextNamePrefix + getComponentKey(child, ii++);</span><br><span class="line">        subtreeCount += traverseAllChildrenImpl(</span><br><span class="line">          child,</span><br><span class="line">          nextName,</span><br><span class="line">          callback,</span><br><span class="line">          traverseContext</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> subtreeCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> POOL_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 对象池</span></span><br><span class="line"><span class="comment">// mapFunction可能会频繁调用，对象频繁声明释放会很消耗内存，使用对象池保存对象引用，重复利用减少内存创建回收开销</span></span><br><span class="line"><span class="comment">// React合成事件系统中也用到了对象池进行性能优化</span></span><br><span class="line"><span class="comment">// 正常情况下对象池里面只有一个对象，但是如果像下面这样调用的时候对象池里面就不止一个了，真正的效果也就开始体现出来了</span></span><br><span class="line"><span class="comment">// React.Children.map(props.children, (c) =&gt; [c, [c, [c, c]]])  对象池里面有三个</span></span><br><span class="line"><span class="keyword">const</span> traverseContextPool = [];</span><br><span class="line"><span class="comment">// getPooledTraverseContext</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPooledTraverseContext</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  mapResult,</span></span></span><br><span class="line"><span class="function"><span class="params">  keyPrefix,</span></span></span><br><span class="line"><span class="function"><span class="params">  mapFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">  mapContext</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (traverseContextPool.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> traverseContext = traverseContextPool.pop();</span><br><span class="line">    traverseContext.result = mapResult;</span><br><span class="line">    traverseContext.keyPrefix = keyPrefix;</span><br><span class="line">    traverseContext.func = mapFunction;</span><br><span class="line">    traverseContext.context = mapContext;</span><br><span class="line">    traverseContext.count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> traverseContext;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      result: mapResult,</span><br><span class="line">      keyPrefix: keyPrefix,</span><br><span class="line">      func: mapFunction,</span><br><span class="line">      context: mapContext,</span><br><span class="line">      count: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// releaseTraverseContext</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">releaseTraverseContext</span>(<span class="params">traverseContext</span>) </span>&#123;</span><br><span class="line">  traverseContext.result = <span class="literal">null</span>;</span><br><span class="line">  traverseContext.keyPrefix = <span class="literal">null</span>;</span><br><span class="line">  traverseContext.func = <span class="literal">null</span>;</span><br><span class="line">  traverseContext.context = <span class="literal">null</span>;</span><br><span class="line">  traverseContext.count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (traverseContextPool.length &lt; POOL_SIZE) &#123;</span><br><span class="line">    traverseContextPool.push(traverseContext);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>两层递归，最终返回一维数组<br>学到一个优化： 对象池 pool</p>
</blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p>memo</p>
</li>
<li><p>Fragment StrictMode</p>
</li>
<li><p>cloneElement createFactory</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>React 只是创建了一些 DOM 节点，以及一些 ref 等，并没有具体的操作，好像是一个空壳子，而 React-DOM 和 React-Native 才是具体实现</p>
<blockquote>
<p><a href="https://github.com/Matthrews/react-core/tree/main/demos">案列 Demo</a></p>
</blockquote>
<hr />

<h2 id="创建和更新"><a href="#创建和更新" class="headerlink" title="创建和更新"></a>创建和更新</h2><ul>
<li><p>ReactDOM.render/hydrate</p>
</li>
<li><p>setState/replaceState[后者将会废弃]</p>
</li>
<li><p>forceUpdate</p>
</li>
</ul>
<h3 id="ReactDOM-render-步骤"><a href="#ReactDOM-render-步骤" class="headerlink" title="ReactDOM.render 步骤"></a>ReactDOM.render 步骤</h3><ul>
<li><p>创建 ReactRoot</p>
</li>
<li><p>创建 FiberRoot 和 RootFiber</p>
</li>
<li><p>创建 更新</p>
</li>
</ul>
<blockquote>
<p>创建完更新，进入调度换节，调度换节不接暂时不讲</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-dom\src\client\ReactDOM.js</span></span><br><span class="line"><span class="keyword">const</span> ReactDOM = &#123;</span><br><span class="line">  createPortal,</span><br><span class="line">  findDOMNode,</span><br><span class="line">  <span class="comment">// hydrate 是 React 中提供在初次渲染的时候，去复用原本已经存在的 DOM 节点，减少重新生成节点以及删除原本 DOM 节点的开销，来加速初次渲染的功能。</span></span><br><span class="line">  <span class="comment">// 主要使用场景是 服务端渲染或者像 prerender 等情况 。</span></span><br><span class="line">  <span class="comment">// 与render区别在于第四个参数</span></span><br><span class="line">  <span class="function"><span class="title">hydrate</span>(<span class="params">element: React$Node, container: DOMContainer, callback: ?<span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> throw or warn if we couldn&#x27;t hydrate?</span></span><br><span class="line">    <span class="keyword">return</span> legacyRenderSubtreeIntoContainer(</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      element,</span><br><span class="line">      container,</span><br><span class="line">      <span class="literal">true</span>,</span><br><span class="line">      callback</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  render(</span><br><span class="line">    element: React$Element&lt;any&gt;,</span><br><span class="line">    container: DOMContainer,</span><br><span class="line">    callback: ?<span class="built_in">Function</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> legacyRenderSubtreeIntoContainer(</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      element,</span><br><span class="line">      container,</span><br><span class="line">      <span class="literal">false</span>,</span><br><span class="line">      callback</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  unstable_renderSubtreeIntoContainer,</span><br><span class="line">  unmountComponentAtNode,</span><br><span class="line">  unstable_createPortal, <span class="comment">// <span class="doctag">TODO:</span> remove in React 17</span></span><br><span class="line">  unstable_batchedUpdates: batchedUpdates,</span><br><span class="line">  unstable_interactiveUpdates: interactiveUpdates,</span><br><span class="line">  flushSync: flushSync,</span><br><span class="line">  unstable_createRoot: createRoot,</span><br><span class="line">  unstable_flushControlled: flushControlled,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReactDOM;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先大致过一下render函数调用链</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react-dom\src\client\ReactDOM.js</span></span><br><span class="line"><span class="comment">// ======================= //</span></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="comment">// legacyRenderSubtreeIntoContainer</span></span><br><span class="line"><span class="comment">//     return new ReactRoot(container, isConcurrent, shouldHydrate);</span></span><br><span class="line"><span class="comment">// ReactRoot</span></span><br><span class="line"><span class="comment">//     createContainer(container, isConcurrent, hydrate)</span></span><br><span class="line"><span class="comment">// ReactRoot.prototype.render = function()&#123;...&#125;</span></span><br><span class="line"><span class="comment">// ReactRoot.prototype.unmount = function()&#123;...&#125;</span></span><br><span class="line"><span class="comment">// ReactRoot.prototype.legacy_renderSubtreeIntoContainer = function()&#123;...&#125;</span></span><br><span class="line"><span class="comment">// ReactRoot.prototype.createBatch = function()&#123;...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberReconciler.js</span></span><br><span class="line"><span class="comment">// ======================= //</span></span><br><span class="line"><span class="comment">// createContainer</span></span><br><span class="line"><span class="comment">//     return createFiberRoot(containerInfo, isConcurrent, hydrate)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberRoot.js</span></span><br><span class="line"><span class="comment">// ======================= //</span></span><br><span class="line"><span class="comment">// createFiberRoot</span></span><br><span class="line"><span class="comment">//     return root // 此处root就是Fiber节点数据对象  暂时停下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再详细看下render函数</span></span><br><span class="line"><span class="comment">// packages\react-dom\src\client\ReactDOM.js</span></span><br><span class="line">ReactRoot.prototype.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: ?() =&gt; mixed</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Work</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  updateContainer(children, root, <span class="literal">null</span>, work._onCommit);</span><br><span class="line">  <span class="keyword">return</span> work;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberReconciler.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  container: OpaqueRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  parentComponent: ?React$Component&lt;any, any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: ?<span class="built_in">Function</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ExpirationTime</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> current = container.current;</span><br><span class="line">  <span class="keyword">const</span> currentTime = requestCurrentTime();</span><br><span class="line">  <span class="keyword">const</span> expirationTime = computeExpirationForFiber(currentTime, current);</span><br><span class="line">  <span class="keyword">return</span> updateContainerAtExpirationTime(</span><br><span class="line">    element,</span><br><span class="line">    container,</span><br><span class="line">    parentComponent,</span><br><span class="line">    expirationTime,</span><br><span class="line">    callback</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateContainerAtExpirationTime</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  container: OpaqueRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  parentComponent: ?React$Component&lt;any, any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: ?<span class="built_in">Function</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> scheduleRootUpdate(current, element, expirationTime, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleRootUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: ?<span class="built_in">Function</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> update = createUpdate(expirationTime);</span><br><span class="line">  flushPassiveEffects();</span><br><span class="line">  enqueueUpdate(current, update);</span><br><span class="line">  scheduleWork(current, expirationTime);</span><br><span class="line">  <span class="keyword">return</span> expirationTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>流程有点复杂,暂时先把流程记录下来</p>
</blockquote>
<blockquote>
<p>新的问题： hydrate 如何复用已有 DOM 节点？</p>
</blockquote>
<h3 id="FiberRoot"><a href="#FiberRoot" class="headerlink" title="FiberRoot"></a>FiberRoot</h3><ul>
<li><p>整个应用的起点</p>
</li>
<li><p>包含挂载的节点</p>
</li>
<li><p>记录应用更新过程中的各种信息</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberRoot.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createFiberRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  containerInfo: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  isConcurrent: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrate: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">FiberRoot</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Cyclic construction. This cheats the type system right now because</span></span><br><span class="line">  <span class="comment">// stateNode is any.</span></span><br><span class="line">  <span class="keyword">const</span> uninitializedFiber = createHostRootFiber(isConcurrent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> root = (&#123;</span><br><span class="line">      <span class="comment">// The currently active root fiber. This is the mutable root of the tree.</span></span><br><span class="line">      <span class="comment">// 当前应用对应的Fiber对象，是Root Fiber</span></span><br><span class="line">      <span class="comment">// 关于Fiber下节分享</span></span><br><span class="line">      current: uninitializedFiber,</span><br><span class="line">      <span class="comment">// Any additional information from the host associated with this root.</span></span><br><span class="line">      <span class="comment">// root节点，render方法接受的第二个参数</span></span><br><span class="line">      containerInfo: containerInfo,</span><br><span class="line">      <span class="comment">// Used only by persistent updates.</span></span><br><span class="line">      <span class="comment">// 只有在持久更新中会用到，也就是不支持增量更新的平台，react-dom不会用到</span></span><br><span class="line">      pendingChildren: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Suspend和lazy相关</span></span><br><span class="line">      pingCache: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The earliest and latest priority levels that are not known to be suspended.</span></span><br><span class="line">      <span class="comment">// 标记最新和最老的不确定是否会挂起的任务</span></span><br><span class="line">      earliestPendingTime: NoWork,</span><br><span class="line">      latestPendingTime: NoWork,</span><br><span class="line">      <span class="comment">// The following priority levels are used to distinguish between 1)</span></span><br><span class="line">      <span class="comment">// uncommitted work, 2) uncommitted work that is suspended, and 3) uncommitted</span></span><br><span class="line">      <span class="comment">// work that may be unsuspended. We choose not to track each individual</span></span><br><span class="line">      <span class="comment">// pending level, trading granularity for performance.</span></span><br><span class="line">      <span class="comment">// The earliest and latest priority levels that are suspended from committing.</span></span><br><span class="line">      <span class="comment">// 标记最新和最老的在提交时候被挂起的任务</span></span><br><span class="line">      earliestSuspendedTime: NoWork,</span><br><span class="line">      latestSuspendedTime: NoWork,</span><br><span class="line">      <span class="comment">// The latest priority level that was pinged by a resolved promise and can be retried.</span></span><br><span class="line">      <span class="comment">// 标记最新的通过一个promise被resolve并且可以重新尝试的优先级任务</span></span><br><span class="line">      latestPingedTime: NoWork,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If an error is thrown, and there are no more updates in the queue, we try</span></span><br><span class="line">      <span class="comment">// rendering from the root one more time, synchronously, before handling</span></span><br><span class="line">      <span class="comment">// the error.</span></span><br><span class="line">      <span class="comment">// 如果有错误并且没有更多的更新存在，我们尝试在处理错误前同步重新从头渲染</span></span><br><span class="line">      <span class="comment">// 在rednerRoot出现无法处理的错误的时候会被设置为true</span></span><br><span class="line">      didError: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 标记正在等待提交的任务</span></span><br><span class="line">      pendingCommitExpirationTime: NoWork,</span><br><span class="line">      <span class="comment">// A finished work-in-progress HostRoot that&#x27;s ready to be committed.</span></span><br><span class="line">      <span class="comment">// 已经完成的任务的FiberRoot对象，如果你只有一个Root，那它永远只可能是这个Root对下个的Fiber或者是null</span></span><br><span class="line">      <span class="comment">// 在commit阶段只会处理这个值对应的任务</span></span><br><span class="line">      finishedWork: <span class="literal">null</span>,</span><br><span class="line">      <span class="comment">// 在任务被挂起的时候通过setTimeout设置的返回内容，用来下一次如果有新的任务挂起时清理还没触发的timeout</span></span><br><span class="line">      <span class="comment">// Timeout handle returned by setTimeout. Used to cancel a pending timeout, if</span></span><br><span class="line">      <span class="comment">// it&#x27;s superseded by a new one.</span></span><br><span class="line">      timeoutHandle: noTimeout,</span><br><span class="line">      <span class="comment">// Top context object, used by renderSubtreeIntoContainer</span></span><br><span class="line">      <span class="comment">// 顶层context对象，只有主动调用`renderSubtreeIntoContainer`时才会有用</span></span><br><span class="line">      context: <span class="literal">null</span>,</span><br><span class="line">      pendingContext: <span class="literal">null</span>,</span><br><span class="line">      <span class="comment">// Determines if we should attempt to hydrate on the initial mount</span></span><br><span class="line">      <span class="comment">// 用来确定第一次渲染的时候是否需要融合</span></span><br><span class="line">      hydrate,</span><br><span class="line">      <span class="comment">// Remaining expiration time on this root.</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> Lift this into the renderer</span></span><br><span class="line">      <span class="comment">// 当前root上剩余的过期时间</span></span><br><span class="line">      nextExpirationTimeToWorkOn: NoWork,</span><br><span class="line">      <span class="comment">// 当前更新对应的过期时间</span></span><br><span class="line">      expirationTime: NoWork,</span><br><span class="line">      <span class="comment">// List of top-level batches. This list indicates whether a commit should be</span></span><br><span class="line">      <span class="comment">// deferred. Also contains completion callbacks.</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> Lift this into the renderer</span></span><br><span class="line">      <span class="comment">// 顶层批次（批处理任务？）这个变量指明一个commit是否应该被推迟, 同时包括完成之后的回调</span></span><br><span class="line">      firstBatch: <span class="literal">null</span>,</span><br><span class="line">      <span class="comment">// Linked-list of roots</span></span><br><span class="line">      <span class="comment">// root之间关联的链表结构</span></span><br><span class="line">      nextScheduledRoot: <span class="literal">null</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// FiberRoot ==&gt; current ==&gt; RootFiber</span></span><br><span class="line">  <span class="comment">// RootFiber ==&gt; stateNode  ==&gt; FiberRoot</span></span><br><span class="line">  uninitializedFiber.stateNode = root;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h3><ul>
<li><p>每一个 ReactElement 对应一个 Fiber 对象</p>
</li>
<li><p>记录节点的各种状态</p>
</li>
<li><p>串联整个应用性成数结构</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiber.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createHostRootFiber</span>(<span class="params">isConcurrent: boolean</span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> mode = isConcurrent ? ConcurrentMode | StrictMode : NoContext;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123;</span><br><span class="line">    <span class="comment">// Always collect profile timings when DevTools are present.</span></span><br><span class="line">    <span class="comment">// This enables DevTools to start capturing timing at any point–</span></span><br><span class="line">    <span class="comment">// Without some nodes in the tree having empty base times.</span></span><br><span class="line">    mode |= ProfileMode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> createFiber(HostRoot, <span class="literal">null</span>, <span class="literal">null</span>, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a constructor function, rather than a POJO constructor, still</span></span><br><span class="line"><span class="comment">// please ensure we do the following:</span></span><br><span class="line"><span class="comment">// 1) Nobody should add any instance methods on this. Instance methods can be</span></span><br><span class="line"><span class="comment">//    more difficult to predict when they get optimized and they are almost</span></span><br><span class="line"><span class="comment">//    never inlined properly in static compilers.</span></span><br><span class="line"><span class="comment">// 2) Nobody should rely on `instanceof Fiber` for type testing. We should</span></span><br><span class="line"><span class="comment">//    always know when it is a fiber.</span></span><br><span class="line"><span class="comment">// 3) We might want to experiment with using numeric keys since they are easier</span></span><br><span class="line"><span class="comment">//    to optimize in a non-JIT environment.</span></span><br><span class="line"><span class="comment">// 4) We can easily go from a constructor to a createFiber object literal if that</span></span><br><span class="line"><span class="comment">//    is faster.</span></span><br><span class="line"><span class="comment">// 5) It should be easy to port this to a C struct and keep a C implementation</span></span><br><span class="line"><span class="comment">//    compatible.</span></span><br><span class="line"><span class="keyword">const</span> createFiber = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  tag: WorkTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  pendingProps: mixed,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: <span class="literal">null</span> | string,</span></span></span><br><span class="line"><span class="function"><span class="params">  mode: TypeOfMode</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="comment">// $FlowFixMe: the shapes are exact here but Flow doesn&#x27;t like constructors</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FiberNode(tag, pendingProps, key, mode);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Fiber is work on a Component that needs to be done or was done. There can</span></span><br><span class="line"><span class="comment">// be more than one per component.</span></span><br><span class="line"><span class="comment">// Fiber对应一个组件需要被处理或者已经处理了，一个组件可以有一个或者多个Fiber</span></span><br><span class="line"><span class="keyword">export</span> type Fiber = &#123;|</span><br><span class="line">  <span class="comment">// These first fields are conceptually members of an Instance. This used to</span></span><br><span class="line">  <span class="comment">// be split into a separate type and intersected with the other Fiber fields,</span></span><br><span class="line">  <span class="comment">// but until Flow fixes its intersection bugs, we&#x27;ve merged them into a</span></span><br><span class="line">  <span class="comment">// single type.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An Instance is shared between all versions of a component. We can easily</span></span><br><span class="line">  <span class="comment">// break this out into a separate object to avoid copying so much to the</span></span><br><span class="line">  <span class="comment">// alternate versions of the tree. We put this on a single object for now to</span></span><br><span class="line">  <span class="comment">// minimize the number of objects created during the initial render.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tag identifying the type of fiber.</span></span><br><span class="line">  <span class="comment">// 标记不同的组件类型</span></span><br><span class="line">  tag: WorkTag,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unique identifier of this child.</span></span><br><span class="line">  <span class="comment">// ReactElement里面的key</span></span><br><span class="line">  key: <span class="literal">null</span> | string,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The value of element.type which is used to preserve the identity during</span></span><br><span class="line">  <span class="comment">// reconciliation of this child.</span></span><br><span class="line">  <span class="comment">// ReactElement.type，也就是我们调用`createElement`的第一个参数</span></span><br><span class="line">  elementType: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The resolved function/class/ associated with this fiber.</span></span><br><span class="line">  <span class="comment">// 异步组件resolved之后返回的内容，一般是`function`或者`class`</span></span><br><span class="line">  type: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The local state associated with this fiber.</span></span><br><span class="line">  <span class="comment">// 跟当前Fiber相关本地状态（比如浏览器环境就是DOM节点）</span></span><br><span class="line">  stateNode: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Conceptual aliases</span></span><br><span class="line">  <span class="comment">// parent : Instance -&gt; return The parent happens to be the same as the</span></span><br><span class="line">  <span class="comment">// return fiber since we&#x27;ve merged the fiber and instance.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remaining fields belong to Fiber</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The Fiber to return to after finishing processing this one.</span></span><br><span class="line">  <span class="comment">// This is effectively the parent, but there can be multiple parents (two)</span></span><br><span class="line">  <span class="comment">// so this is only the parent of the thing we&#x27;re currently processing.</span></span><br><span class="line">  <span class="comment">// It is conceptually the same as the return address of a stack frame.</span></span><br><span class="line">  <span class="comment">// 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回</span></span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Singly Linked List Tree Structure.</span></span><br><span class="line">  <span class="comment">// 单链表树结构</span></span><br><span class="line">  <span class="comment">// 指向自己的第一个子节点</span></span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向自己的兄弟结构</span></span><br><span class="line">  <span class="comment">// 兄弟节点的return指向同一个父节点</span></span><br><span class="line">  <span class="comment">// 所以我们会发现父节点不是指向所有子节点，而是指向第一个子结点，然后子结点之间通过sibling串联，并且所有子节点都通过return指向父节点</span></span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">  index: number,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The ref last used to attach this node.</span></span><br><span class="line">  <span class="comment">// I&#x27;ll avoid adding an owner field for prod and model that as functions.</span></span><br><span class="line">  <span class="comment">// ref属性</span></span><br><span class="line">  ref: <span class="literal">null</span> | ((<span class="function">(<span class="params">handle: mixed</span>) =&gt;</span> <span class="keyword">void</span>) &amp; &#123; <span class="attr">_stringRef</span>: ?string &#125;) | RefObject,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Input is the data coming into process this fiber. Arguments. Props.</span></span><br><span class="line">  <span class="comment">// 新的变动带来的新的props</span></span><br><span class="line">  pendingProps: any, <span class="comment">// This type will be more specific once we overload the tag.</span></span><br><span class="line">  <span class="comment">// 上一次渲染完成之后的props</span></span><br><span class="line">  memoizedProps: any, <span class="comment">// The props used to create the output.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A queue of state updates and callbacks.</span></span><br><span class="line">  <span class="comment">// 该Fiber对应的组件产生的Update会存放在这个队列里面</span></span><br><span class="line">  updateQueue: UpdateQueue&lt;any&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The state used to create the output</span></span><br><span class="line">  <span class="comment">// 上一次渲染的时候的state</span></span><br><span class="line">  memoizedState: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A linked-list of contexts that this fiber depends on</span></span><br><span class="line">  <span class="comment">// 一个列表，存放这个Fiber依赖的context</span></span><br><span class="line">  firstContextDependency: ContextDependency&lt;mixed&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Bitfield that describes properties about the fiber and its subtree. E.g.</span></span><br><span class="line">  <span class="comment">// the ConcurrentMode flag indicates whether the subtree should be async-by-</span></span><br><span class="line">  <span class="comment">// default. When a fiber is created, it inherits the mode of its</span></span><br><span class="line">  <span class="comment">// parent. Additional flags can be set at creation time, but after that the</span></span><br><span class="line">  <span class="comment">// value should remain unchanged throughout the fiber&#x27;s lifetime, particularly</span></span><br><span class="line">  <span class="comment">// before its child fibers are created.</span></span><br><span class="line">  <span class="comment">// 用来描述当前Fiber和他子树的`Bitfield`</span></span><br><span class="line">  <span class="comment">// 共存的模式表示这个子树是否默认是异步渲染的</span></span><br><span class="line">  <span class="comment">// Fiber被创建的时候他会继承父Fiber</span></span><br><span class="line">  <span class="comment">// 其他的标识也可以在创建的时候被设置</span></span><br><span class="line">  <span class="comment">// 但是在创建之后不应该再被修改，特别是他的子Fiber创建之前</span></span><br><span class="line">  mode: TypeOfMode,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Effect</span></span><br><span class="line">  <span class="comment">// 用来记录Side Effect</span></span><br><span class="line">  effectTag: SideEffectTag,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Singly linked list fast path to the next fiber with side-effects.</span></span><br><span class="line">  <span class="comment">// 单链表用来快速查找下一个side effect</span></span><br><span class="line">  nextEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The first and last fiber with side-effect within this subtree. This allows</span></span><br><span class="line">  <span class="comment">// us to reuse a slice of the linked list when we reuse the work done within</span></span><br><span class="line">  <span class="comment">// this fiber.</span></span><br><span class="line">  <span class="comment">// 子树中第一个side effect</span></span><br><span class="line">  firstEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 子树中最后一个side effect</span></span><br><span class="line">  lastEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Represents a time in the future by which this work should be completed.</span></span><br><span class="line">  <span class="comment">// Does not include work found in its subtree.</span></span><br><span class="line">  <span class="comment">// 代表任务在未来的哪个时间点应该被完成</span></span><br><span class="line">  <span class="comment">// 不包括他的子树产生的任务</span></span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is used to quickly determine if a subtree has no pending changes.</span></span><br><span class="line">  <span class="comment">// 快速确定子树中是否有不在等待的变化</span></span><br><span class="line">  childExpirationTime: ExpirationTime,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is a pooled version of a Fiber. Every fiber that gets updated will</span></span><br><span class="line">  <span class="comment">// eventually have a pair. There are cases when we can clean up pairs to save</span></span><br><span class="line">  <span class="comment">// memory if we need to.</span></span><br><span class="line">  <span class="comment">// 在Fiber树更新的过程中，每个Fiber都会有一个跟其对应的Fiber</span></span><br><span class="line">  <span class="comment">// 我们称他为`current &lt;==&gt; workInProgress`</span></span><br><span class="line">  <span class="comment">// 在渲染完成之后他们会交换位置</span></span><br><span class="line">  alternate: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面是调试相关的，收集每个Fiber和子树渲染时间的</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Time spent rendering this Fiber and its descendants for the current update.</span></span><br><span class="line">  <span class="comment">// This tells us how well the tree makes use of sCU for memoization.</span></span><br><span class="line">  <span class="comment">// It is reset to 0 each time we render and only updated when we don&#x27;t bailout.</span></span><br><span class="line">  <span class="comment">// This field is only set when the enableProfilerTimer flag is enabled.</span></span><br><span class="line">  actualDuration?: number,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the Fiber is currently active in the &quot;render&quot; phase,</span></span><br><span class="line">  <span class="comment">// This marks the time at which the work began.</span></span><br><span class="line">  <span class="comment">// This field is only set when the enableProfilerTimer flag is enabled.</span></span><br><span class="line">  actualStartTime?: number,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Duration of the most recent render time for this Fiber.</span></span><br><span class="line">  <span class="comment">// This value is not updated when we bailout for memoization purposes.</span></span><br><span class="line">  <span class="comment">// This field is only set when the enableProfilerTimer flag is enabled.</span></span><br><span class="line">  selfBaseDuration?: number,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sum of base times for all descedents of this Fiber.</span></span><br><span class="line">  <span class="comment">// This value bubbles up during the &quot;complete&quot; phase.</span></span><br><span class="line">  <span class="comment">// This field is only set when the enableProfilerTimer flag is enabled.</span></span><br><span class="line">  treeBaseDuration?: number,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Conceptual aliases</span></span><br><span class="line">  <span class="comment">// workInProgress : Fiber -&gt;  alternate The alternate used for reuse happens</span></span><br><span class="line">  <span class="comment">// to be the same as work in progress.</span></span><br><span class="line">|&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Update-amp-UpdateQueue"><a href="#Update-amp-UpdateQueue" class="headerlink" title="Update &amp; UpdateQueue"></a>Update &amp; UpdateQueue</h3><ul>
<li><p>用于记录组件状态的改变</p>
</li>
<li><p>存放于 UpdateQueue 里面</p>
</li>
<li><p>多个 Update 可以同时共存</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactUpdateQueue.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type Update&lt;State&gt; = &#123;</span><br><span class="line">  <span class="comment">// 更新的过期时间</span></span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// export const UpdateState = 0;</span></span><br><span class="line">  <span class="comment">// export const ReplaceState = 1;</span></span><br><span class="line">  <span class="comment">// export const ForceUpdate = 2;</span></span><br><span class="line">  <span class="comment">// export const CaptureUpdate = 3;</span></span><br><span class="line">  <span class="comment">// 指定更新的类型，值为以上几种</span></span><br><span class="line">  tag: <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>,</span><br><span class="line">  <span class="comment">// 更新内容，比如`setState`接收的第一个参数</span></span><br><span class="line">  payload: any,</span><br><span class="line">  <span class="comment">// 对应的回调，`setState`，`render`都有</span></span><br><span class="line">  callback: (<span class="function">() =&gt;</span> mixed) | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指向下一个更新</span></span><br><span class="line">  next: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向下一个`side effect`</span></span><br><span class="line">  nextEffect: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type UpdateQueue&lt;State&gt; = &#123;</span><br><span class="line">  <span class="comment">// 每一次操作完更新之后的`state`</span></span><br><span class="line">  baseState: State,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 队列中的第一个`Update`</span></span><br><span class="line">  firstUpdate: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 队列中的最后一个`Update`</span></span><br><span class="line">  lastUpdate: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一个捕获类型的`Update`</span></span><br><span class="line">  firstCapturedUpdate: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 最后一个捕获类型的`Update`</span></span><br><span class="line">  lastCapturedUpdate: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一个`side effect`</span></span><br><span class="line">  firstEffect: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 最后一个`side effect`</span></span><br><span class="line">  lastEffect: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一个和最后一个捕获产生的`side effect`</span></span><br><span class="line">  firstCapturedEffect: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">  lastCapturedEffect: Update&lt;State&gt; | <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createUpdate</span>(<span class="params">expirationTime: ExpirationTime</span>): <span class="title">Update</span>&lt;*&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    expirationTime: expirationTime,</span><br><span class="line"></span><br><span class="line">    tag: <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">    payload: <span class="literal">null</span>,</span><br><span class="line">    callback: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">    nextEffect: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createUpdateQueue</span>&lt;<span class="title">State</span>&gt;(<span class="params">baseState: State</span>): <span class="title">UpdateQueue</span>&lt;<span class="title">State</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> queue: UpdateQueue&lt;State&gt; = &#123;</span><br><span class="line">    baseState,</span><br><span class="line">    firstUpdate: <span class="literal">null</span>,</span><br><span class="line">    lastUpdate: <span class="literal">null</span>,</span><br><span class="line">    firstCapturedUpdate: <span class="literal">null</span>,</span><br><span class="line">    lastCapturedUpdate: <span class="literal">null</span>,</span><br><span class="line">    firstEffect: <span class="literal">null</span>,</span><br><span class="line">    lastEffect: <span class="literal">null</span>,</span><br><span class="line">    firstCapturedEffect: <span class="literal">null</span>,</span><br><span class="line">    lastCapturedEffect: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneUpdateQueue</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  currentQueue: UpdateQueue&lt;State&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">UpdateQueue</span>&lt;<span class="title">State</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> queue: UpdateQueue&lt;State&gt; = &#123;</span><br><span class="line">    baseState: currentQueue.baseState,</span><br><span class="line">    firstUpdate: currentQueue.firstUpdate,</span><br><span class="line">    lastUpdate: currentQueue.lastUpdate,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> With resuming, if we bail out and resuse the child tree, we should</span></span><br><span class="line">    <span class="comment">// keep these effects.</span></span><br><span class="line">    firstCapturedUpdate: <span class="literal">null</span>,</span><br><span class="line">    lastCapturedUpdate: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    firstEffect: <span class="literal">null</span>,</span><br><span class="line">    lastEffect: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    firstCapturedEffect: <span class="literal">null</span>,</span><br><span class="line">    lastCapturedEffect: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendUpdateToQueue</span>&lt;<span class="title">State</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  queue: UpdateQueue&lt;State&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  update: Update&lt;State&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Append the update to the end of the list.</span></span><br><span class="line">  <span class="keyword">if</span> (queue.lastUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Queue is empty</span></span><br><span class="line">    queue.firstUpdate = queue.lastUpdate = update;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queue.lastUpdate.next = update;</span><br><span class="line">    queue.lastUpdate = update;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>&lt;<span class="title">State</span>&gt;(<span class="params">fiber: Fiber, update: Update&lt;State&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Update queues are created lazily.</span></span><br><span class="line">  <span class="keyword">const</span> alternate = fiber.alternate;</span><br><span class="line">  <span class="keyword">let</span> queue1;</span><br><span class="line">  <span class="keyword">let</span> queue2;</span><br><span class="line">  <span class="keyword">if</span> (alternate === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// There&#x27;s only one fiber.</span></span><br><span class="line">    queue1 = fiber.updateQueue;</span><br><span class="line">    queue2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (queue1 === <span class="literal">null</span>) &#123;</span><br><span class="line">      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There are two owners.</span></span><br><span class="line">    queue1 = fiber.updateQueue;</span><br><span class="line">    queue2 = alternate.updateQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue1 === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (queue2 === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Neither fiber has an update queue. Create new ones.</span></span><br><span class="line">        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);</span><br><span class="line">        queue2 = alternate.updateQueue = createUpdateQueue(</span><br><span class="line">          alternate.memoizedState</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Only one fiber has an update queue. Clone to create a new one.</span></span><br><span class="line">        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (queue2 === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Only one fiber has an update queue. Clone to create a new one.</span></span><br><span class="line">        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Both owners have an update queue.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queue2 === <span class="literal">null</span> || queue1 === queue2) &#123;</span><br><span class="line">    <span class="comment">// There&#x27;s only a single queue.</span></span><br><span class="line">    appendUpdateToQueue(queue1, update);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There are two queues. We need to append the update to both queues,</span></span><br><span class="line">    <span class="comment">// while accounting for the persistent structure of the list — we don&#x27;t</span></span><br><span class="line">    <span class="comment">// want the same update to be added multiple times.</span></span><br><span class="line">    <span class="keyword">if</span> (queue1.lastUpdate === <span class="literal">null</span> || queue2.lastUpdate === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// One of the queues is not empty. We must add the update to both queues.</span></span><br><span class="line">      appendUpdateToQueue(queue1, update);</span><br><span class="line">      appendUpdateToQueue(queue2, update);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Both queues are non-empty. The last update is the same in both lists,</span></span><br><span class="line">      <span class="comment">// because of structural sharing. So, only append to one of the lists.</span></span><br><span class="line">      appendUpdateToQueue(queue1, update);</span><br><span class="line">      <span class="comment">// But we still need to update the `lastUpdate` pointer of queue2.</span></span><br><span class="line">      queue2.lastUpdate = update;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="expirationTime"><a href="#expirationTime" class="headerlink" title="expirationTime"></a>expirationTime</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberScheduler.js</span></span><br><span class="line"><span class="comment">// computeExpirationForFiber</span></span><br><span class="line"><span class="comment">//    computeInteractiveExpiration</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberExpirationTime.js</span></span><br><span class="line"><span class="comment">// computeInteractiveExpiration</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终计算公式：((((currentTime - 2 + 5000 / 10) / 25) | 0) + 1) * 25</span></span><br></pre></td></tr></table></figure>

<h3 id="不同类型的-expirationTime"><a href="#不同类型的-expirationTime" class="headerlink" title="不同类型的 expirationTime"></a>不同类型的 expirationTime</h3><ul>
<li><p>Sync 模式，优先级最高</p>
</li>
<li><p>Asnyc/Concurrent 模式</p>
</li>
<li><p>指定 context 模式</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberScheduler.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeExpirationForFiber</span>(<span class="params">currentTime: ExpirationTime, fiber: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> expirationTime;</span><br><span class="line">  <span class="keyword">if</span> (expirationContext !== NoWork) &#123;</span><br><span class="line">    <span class="comment">// An explicit expiration context was set;</span></span><br><span class="line">    expirationTime = expirationContext;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWorking) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isCommitting) &#123;</span><br><span class="line">      <span class="comment">// Updates that occur during the commit phase should have sync priority</span></span><br><span class="line">      <span class="comment">// by default.</span></span><br><span class="line">      expirationTime = Sync;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Updates during the render phase should expire at the same time as</span></span><br><span class="line">      <span class="comment">// the work that is being rendered.</span></span><br><span class="line">      expirationTime = nextRenderExpirationTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No explicit expiration context was set, and we&#x27;re not currently</span></span><br><span class="line">    <span class="comment">// performing work. Calculate a new expiration time.</span></span><br><span class="line">    <span class="keyword">if</span> (fiber.mode &amp; ConcurrentMode) &#123;</span><br><span class="line">      <span class="comment">// 往往是事件onClick等</span></span><br><span class="line">      <span class="keyword">if</span> (isBatchingInteractiveUpdates) &#123;</span><br><span class="line">        <span class="comment">// This is an interactive update</span></span><br><span class="line">        expirationTime = computeInteractiveExpiration(currentTime);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This is an async update</span></span><br><span class="line">        expirationTime = computeAsyncExpiration(currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// If we&#x27;re in the middle of rendering a tree, do not update at the same</span></span><br><span class="line">      <span class="comment">// expiration time that is already rendering.</span></span><br><span class="line">      <span class="keyword">if</span> (nextRoot !== <span class="literal">null</span> &amp;&amp; expirationTime === nextRenderExpirationTime) &#123;</span><br><span class="line">        expirationTime -= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// This is a sync update</span></span><br><span class="line">      expirationTime = Sync;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isBatchingInteractiveUpdates) &#123;</span><br><span class="line">    <span class="comment">// This is an interactive update. Keep track of the lowest pending</span></span><br><span class="line">    <span class="comment">// interactive expiration time. This allows us to synchronously flush</span></span><br><span class="line">    <span class="comment">// all interactive updates when needed.</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      lowestPriorityPendingInteractiveExpirationTime === NoWork ||</span><br><span class="line">      expirationTime &lt; lowestPriorityPendingInteractiveExpirationTime</span><br><span class="line">    ) &#123;</span><br><span class="line">      lowestPriorityPendingInteractiveExpirationTime = expirationTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> expirationTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react-reconciler\src\ReactTypeOfMode.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type TypeOfMode = number;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoContext = <span class="number">0b000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ConcurrentMode = <span class="number">0b001</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> StrictMode = <span class="number">0b010</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ProfileMode = <span class="number">0b100</span>;</span><br><span class="line"><span class="comment">// fiber.mode &amp; ConcurrentMode表示fiber.mode中是否包含ConcurrentMode</span></span><br><span class="line"><span class="comment">// 使用二进制便于组合，可参考：https://blog.csdn.net/zl544434558/article/details/79252751</span></span><br><span class="line"><span class="comment">// 关于位运算的性只，可参考：https://www.jianshu.com/p/7faf7c22c146</span></span><br><span class="line"><span class="comment">// fiber.mode |= ConcurrentMode  添加类型ConcurrentMode</span></span><br><span class="line"><span class="comment">// fiber.mode ^ ConcurrentMode  提出类型ConcurrentMode</span></span><br></pre></td></tr></table></figure>

<h3 id="setState-forceUpdate"><a href="#setState-forceUpdate" class="headerlink" title="setState/forceUpdate"></a>setState/forceUpdate</h3><ul>
<li><p>给节点的<code>Fiber</code>创建更新</p>
</li>
<li><p>更新类型不同</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react\src\ReactBaseClasses.js</span></span><br><span class="line">Component.prototype.setState = <span class="function"><span class="keyword">function</span> (<span class="params">partialState, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.updater.enqueueSetState(<span class="built_in">this</span>, partialState, callback, <span class="string">&quot;setState&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Component.prototype.forceUpdate = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.updater.enqueueForceUpdate(<span class="built_in">this</span>, callback, <span class="string">&quot;forceUpdate&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberClassComponent.js</span></span><br><span class="line"><span class="keyword">const</span> classComponentUpdater = &#123;</span><br><span class="line">  isMounted,</span><br><span class="line">  <span class="comment">// 可以看到和updateContainer方法流程是一样的</span></span><br><span class="line">  <span class="function"><span class="title">enqueueSetState</span>(<span class="params">inst, payload, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fiber = getInstance(inst);</span><br><span class="line">    <span class="keyword">const</span> currentTime = requestCurrentTime();</span><br><span class="line">    <span class="keyword">const</span> expirationTime = computeExpirationForFiber(currentTime, fiber);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> update = createUpdate(expirationTime);</span><br><span class="line">    update.payload = payload;</span><br><span class="line">    <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">      update.callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flushPassiveEffects();</span><br><span class="line">    enqueueUpdate(fiber, update);</span><br><span class="line">    scheduleWork(fiber, expirationTime);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 和enqueueSetState唯一的差别就在类型上update.tag</span></span><br><span class="line">  <span class="function"><span class="title">enqueueForceUpdate</span>(<span class="params">inst, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fiber = getInstance(inst);</span><br><span class="line">    <span class="keyword">const</span> currentTime = requestCurrentTime();</span><br><span class="line">    <span class="keyword">const</span> expirationTime = computeExpirationForFiber(currentTime, fiber);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> update = createUpdate(expirationTime);</span><br><span class="line">    <span class="comment">// enqueueForceUpdate标记类型是ForceUpdate</span></span><br><span class="line">    <span class="comment">// export const UpdateState = 0;</span></span><br><span class="line">    <span class="comment">// export const ReplaceState = 1;</span></span><br><span class="line">    <span class="comment">// export const ForceUpdate = 2;</span></span><br><span class="line">    <span class="comment">// export const CaptureUpdate = 3;</span></span><br><span class="line">    update.tag = ForceUpdate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">      update.callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flushPassiveEffects();</span><br><span class="line">    enqueueUpdate(fiber, update);</span><br><span class="line">    scheduleWork(fiber, expirationTime);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="fiber-conciler"><a href="#fiber-conciler" class="headerlink" title="fiber-conciler"></a>fiber-conciler</h2><p>基于<code>Fiber</code>，给任务区分不同优先级，以更好地控制渲染</p>
<h3 id="FiberReconciler-总体流程"><a href="#FiberReconciler-总体流程" class="headerlink" title="FiberReconciler 总体流程"></a>FiberReconciler 总体流程</h3><ul>
<li>TODO 流程图</li>
</ul>
<h3 id="scheduleWork"><a href="#scheduleWork" class="headerlink" title="scheduleWork"></a>scheduleWork</h3><ul>
<li><p>找到更新对应的<code>FiberRoot</code>节点</p>
</li>
<li><p>如果符合条件重置<code>stack</code></p>
</li>
<li><p>如果符合条件就请求工作调度</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberScheduler.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleWork</span>(<span class="params">fiber: Fiber, expirationTime: ExpirationTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取FiberRoot</span></span><br><span class="line">  <span class="keyword">const</span> root = scheduleWorkToRoot(fiber, expirationTime);</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !isWorking &amp;&amp;</span><br><span class="line">    nextRenderExpirationTime !== NoWork &amp;&amp;</span><br><span class="line">    expirationTime &gt; nextRenderExpirationTime</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// This is an interruption. (Used for performance tracking.)</span></span><br><span class="line">    interruptedBy = fiber;</span><br><span class="line">    <span class="comment">// 中断，优先执行高优先级渲染</span></span><br><span class="line">    resetStack();</span><br><span class="line">  &#125;</span><br><span class="line">  markPendingPriorityLevel(root, expirationTime);</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="comment">// If we&#x27;re in the render phase, we don&#x27;t need to schedule this root</span></span><br><span class="line">    <span class="comment">// for an update, because we&#x27;ll do it before we exit...</span></span><br><span class="line">    !isWorking ||</span><br><span class="line">    isCommitting ||</span><br><span class="line">    <span class="comment">// ...unless this is a different root than the one we&#x27;re rendering.</span></span><br><span class="line">    nextRoot !== root</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">const</span> rootExpirationTime = root.expirationTime;</span><br><span class="line">    requestWork(root, rootExpirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (nestedUpdateCount &gt; NESTED_UPDATE_LIMIT) &#123;</span><br><span class="line">    <span class="comment">// Reset this back to zero so subsequent updates don&#x27;t throw.</span></span><br><span class="line">    nestedUpdateCount = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> interruptedWork = nextUnitOfWork.return;</span><br><span class="line">    <span class="keyword">while</span> (interruptedWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// undo setState</span></span><br><span class="line">      unwindInterruptedWork(interruptedWork);</span><br><span class="line">      interruptedWork = interruptedWork.return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nextRoot = <span class="literal">null</span>;</span><br><span class="line">  nextRenderExpirationTime = NoWork;</span><br><span class="line">  nextLatestAbsoluteTimeoutMs = -<span class="number">1</span>;</span><br><span class="line">  nextRenderDidError = <span class="literal">false</span>;</span><br><span class="line">  nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历找到FiberRoot</span></span><br><span class="line"><span class="comment">// 并对Fiber的return和alternate的expirationTime做处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleWorkToRoot</span>(<span class="params">fiber: Fiber, expirationTime</span>): <span class="title">FiberRoot</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update the source fiber&#x27;s expiration time</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.expirationTime &lt; expirationTime) &#123;</span><br><span class="line">    fiber.expirationTime = expirationTime;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> alternate = fiber.alternate;</span><br><span class="line">  <span class="keyword">if</span> (alternate !== <span class="literal">null</span> &amp;&amp; alternate.expirationTime &lt; expirationTime) &#123;</span><br><span class="line">    alternate.expirationTime = expirationTime;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Walk the parent path to the root and update the child expiration time.</span></span><br><span class="line">  <span class="keyword">let</span> node = fiber.return;</span><br><span class="line">  <span class="keyword">let</span> root = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span> &amp;&amp; fiber.tag === HostRoot) &#123;</span><br><span class="line">    root = fiber.stateNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      alternate = node.alternate;</span><br><span class="line">      <span class="keyword">if</span> (node.childExpirationTime &lt; expirationTime) &#123;</span><br><span class="line">        node.childExpirationTime = expirationTime;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          alternate !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">          alternate.childExpirationTime &lt; expirationTime</span><br><span class="line">        ) &#123;</span><br><span class="line">          alternate.childExpirationTime = expirationTime;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">        alternate !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        alternate.childExpirationTime &lt; expirationTime</span><br><span class="line">      ) &#123;</span><br><span class="line">        alternate.childExpirationTime = expirationTime;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.return === <span class="literal">null</span> &amp;&amp; node.tag === HostRoot) &#123;</span><br><span class="line">        root = node.stateNode;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      node = node.return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="requestWork"><a href="#requestWork" class="headerlink" title="requestWork"></a>requestWork</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// requestWork is called by the scheduler whenever a root receives an update.</span></span><br><span class="line"><span class="comment">// It&#x27;s up to the renderer to call renderRoot at some point in the future.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestWork</span>(<span class="params">root: FiberRoot, expirationTime: ExpirationTime</span>) </span>&#123;</span><br><span class="line">  addRootToSchedule(root, expirationTime);</span><br><span class="line">  <span class="keyword">if</span> (isRendering) &#123;</span><br><span class="line">    <span class="comment">// Prevent reentrancy. Remaining work will be scheduled at the end of</span></span><br><span class="line">    <span class="comment">// the currently rendering batch.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 批处理 重要</span></span><br><span class="line">  <span class="keyword">if</span> (isBatchingUpdates) &#123;</span><br><span class="line">    <span class="comment">// Flush work at the end of the batch.</span></span><br><span class="line">    <span class="keyword">if</span> (isUnbatchingUpdates) &#123;</span><br><span class="line">      <span class="comment">// ...unless we&#x27;re inside unbatchedUpdates, in which case we should</span></span><br><span class="line">      <span class="comment">// flush it now.</span></span><br><span class="line">      nextFlushedRoot = root;</span><br><span class="line">      nextFlushedExpirationTime = Sync;</span><br><span class="line">      performWorkOnRoot(root, Sync, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始进入调度</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Get rid of Sync and use current time?</span></span><br><span class="line">  <span class="keyword">if</span> (expirationTime === Sync) &#123;</span><br><span class="line">    performSyncWork();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    scheduleCallbackWithExpirationTime(root, expirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addRootToSchedule</span>(<span class="params">root: FiberRoot, expirationTime: ExpirationTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Add the root to the schedule.</span></span><br><span class="line">  <span class="comment">// Check if this root is already part of the schedule.</span></span><br><span class="line">  <span class="keyword">if</span> (root.nextScheduledRoot === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// This root is not already scheduled. Add it.</span></span><br><span class="line">    root.expirationTime = expirationTime;</span><br><span class="line">    <span class="keyword">if</span> (lastScheduledRoot === <span class="literal">null</span>) &#123;</span><br><span class="line">      firstScheduledRoot = lastScheduledRoot = root;</span><br><span class="line">      root.nextScheduledRoot = root;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      lastScheduledRoot.nextScheduledRoot = root;</span><br><span class="line">      lastScheduledRoot = root;</span><br><span class="line">      lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// This root is already scheduled, but its priority may have increased.</span></span><br><span class="line">    <span class="keyword">const</span> remainingExpirationTime = root.expirationTime;</span><br><span class="line">    <span class="keyword">if</span> (expirationTime &gt; remainingExpirationTime) &#123;</span><br><span class="line">      <span class="comment">// Update the priority.</span></span><br><span class="line">      root.expirationTime = expirationTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：performSyncWork 和 scheduleCallbackWithExpirationTime 有什么区别？</p>
<h3 id="batchedUpdates"><a href="#batchedUpdates" class="headerlink" title="batchedUpdates"></a>batchedUpdates</h3><p>先看下案例演示 <code>demos/batchedUpdates</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberScheduler.js</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Batching should be implemented at the renderer level, not inside</span></span><br><span class="line"><span class="comment">// the reconciler.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">batchedUpdates</span>&lt;<span class="title">A</span>, <span class="title">R</span>&gt;(<span class="params">fn: (a: A) =&gt; R, a: A</span>): <span class="title">R</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> previousIsBatchingUpdates = isBatchingUpdates;</span><br><span class="line">  isBatchingUpdates = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(a);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isBatchingUpdates = previousIsBatchingUpdates;</span><br><span class="line">    <span class="keyword">if</span> (!isBatchingUpdates &amp;&amp; !isRendering) &#123;</span><br><span class="line">      performSyncWork();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：setState 是同步的还是异步的？</p>
<p>setState 方法本身调用是同步的，但是调用了 setState 并不标志着 state 立马更新，这个更新过程取决于当前执行环境的上下文，如果处于 batchedUpdates 状态，那 state 不是立马更新的。反之有可能是立马更新的</p>
<p>比如，flushSync 是立马更新的，而 ConcurrentMode 不是立马更新的</p>
<h3 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h3><ul>
<li><p>维护时间片</p>
</li>
<li><p>模拟 requestIdleCallback</p>
</li>
<li><p>调度列表和超时判断</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberScheduler.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  now,</span><br><span class="line">  scheduleDeferredCallback,</span><br><span class="line">  cancelDeferredCallback,</span><br><span class="line">  shouldYield,</span><br><span class="line">  prepareForCommit,</span><br><span class="line">  resetAfterCommit,</span><br><span class="line">  scheduleTimeout,</span><br><span class="line">  cancelTimeout,</span><br><span class="line">  noTimeout,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./ReactFiberHostConfig&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleCallbackWithExpirationTime</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (callbackExpirationTime !== NoWork) &#123;</span><br><span class="line">    <span class="comment">// A callback is already scheduled. Check its expiration time (timeout).</span></span><br><span class="line">    <span class="keyword">if</span> (expirationTime &lt; callbackExpirationTime) &#123;</span><br><span class="line">      <span class="comment">// Existing callback has sufficient timeout. Exit.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (callbackID !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Existing callback has insufficient timeout. Cancel and schedule a</span></span><br><span class="line">        <span class="comment">// new one.</span></span><br><span class="line">        cancelDeferredCallback(callbackID);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The request callback timer is already running. Don&#x27;t start a new one.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    startRequestCallbackTimer();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  callbackExpirationTime = expirationTime;</span><br><span class="line">  <span class="keyword">const</span> currentMs = now() - originalStartTimeMs;</span><br><span class="line">  <span class="keyword">const</span> expirationTimeMs = expirationTimeToMs(expirationTime);</span><br><span class="line">  <span class="keyword">const</span> timeout = expirationTimeMs - currentMs;</span><br><span class="line">  callbackID = scheduleDeferredCallback(performAsyncWork, &#123; timeout &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react-dom\src\client\ReactDOMHostConfig.js</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  unstable_now <span class="keyword">as</span> now,</span><br><span class="line">  unstable_scheduleCallback <span class="keyword">as</span> scheduleDeferredCallback,</span><br><span class="line">  unstable_shouldYield <span class="keyword">as</span> shouldYield,</span><br><span class="line">  unstable_cancelCallback <span class="keyword">as</span> cancelDeferredCallback,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;scheduler&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\scheduler\src\Scheduler.js</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  ImmediatePriority <span class="keyword">as</span> unstable_ImmediatePriority,</span><br><span class="line">  UserBlockingPriority <span class="keyword">as</span> unstable_UserBlockingPriority,</span><br><span class="line">  NormalPriority <span class="keyword">as</span> unstable_NormalPriority,</span><br><span class="line">  IdlePriority <span class="keyword">as</span> unstable_IdlePriority,</span><br><span class="line">  LowPriority <span class="keyword">as</span> unstable_LowPriority,</span><br><span class="line">  unstable_runWithPriority,</span><br><span class="line">  unstable_scheduleCallback,</span><br><span class="line">  unstable_cancelCallback,</span><br><span class="line">  unstable_wrapCallback,</span><br><span class="line">  unstable_getCurrentPriorityLevel,</span><br><span class="line">  unstable_shouldYield,</span><br><span class="line">  unstable_continueExecution,</span><br><span class="line">  unstable_pauseExecution,</span><br><span class="line">  unstable_getFirstCallbackNode,</span><br><span class="line">  getCurrentTime <span class="keyword">as</span> unstable_now,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_scheduleCallback</span>(<span class="params">callback, deprecated_options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> startTime =</span><br><span class="line">    currentEventStartTime !== -<span class="number">1</span> ? currentEventStartTime : getCurrentTime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> expirationTime;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> deprecated_options === <span class="string">&quot;object&quot;</span> &amp;&amp;</span><br><span class="line">    deprecated_options !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> deprecated_options.timeout === <span class="string">&quot;number&quot;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> Remove this branch once we lift expiration times out of React.</span></span><br><span class="line">    expirationTime = startTime + deprecated_options.timeout;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (currentPriorityLevel) &#123;</span><br><span class="line">      <span class="keyword">case</span> ImmediatePriority:</span><br><span class="line">        expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> UserBlockingPriority:</span><br><span class="line">        expirationTime = startTime + USER_BLOCKING_PRIORITY;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> IdlePriority:</span><br><span class="line">        expirationTime = startTime + IDLE_PRIORITY;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> LowPriority:</span><br><span class="line">        expirationTime = startTime + LOW_PRIORITY_TIMEOUT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> NormalPriority:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> newNode = &#123;</span><br><span class="line">    callback,</span><br><span class="line">    priorityLevel: currentPriorityLevel,</span><br><span class="line">    expirationTime,</span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">    previous: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert the new callback into the list, ordered first by expiration, then</span></span><br><span class="line">  <span class="comment">// by insertion. So the new callback is inserted any other callback with</span></span><br><span class="line">  <span class="comment">// equal expiration.</span></span><br><span class="line">  <span class="keyword">if</span> (firstCallbackNode === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// This is the first callback in the list.</span></span><br><span class="line">    firstCallbackNode = newNode.next = newNode.previous = newNode;</span><br><span class="line">    ensureHostCallbackIsScheduled();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> node = firstCallbackNode;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.expirationTime &gt; expirationTime) &#123;</span><br><span class="line">        <span class="comment">// The new callback expires before this one.</span></span><br><span class="line">        next = node;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      node = node.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (node !== firstCallbackNode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// No callback with a later expiration was found, which means the new</span></span><br><span class="line">      <span class="comment">// callback has the latest expiration in the list.</span></span><br><span class="line">      next = firstCallbackNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next === firstCallbackNode) &#123;</span><br><span class="line">      <span class="comment">// The new callback has the earliest expiration in the entire list.</span></span><br><span class="line">      firstCallbackNode = newNode;</span><br><span class="line">      ensureHostCallbackIsScheduled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> previous = next.previous;</span><br><span class="line">    previous.next = next.previous = newNode;</span><br><span class="line">    newNode.next = next;</span><br><span class="line">    newNode.previous = previous;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_cancelCallback</span>(<span class="params">callbackNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> next = callbackNode.next;</span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Already cancelled.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next === callbackNode) &#123;</span><br><span class="line">    <span class="comment">// This is the only scheduled callback. Clear the list.</span></span><br><span class="line">    firstCallbackNode = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Remove the callback from its position in the list.</span></span><br><span class="line">    <span class="keyword">if</span> (callbackNode === firstCallbackNode) &#123;</span><br><span class="line">      firstCallbackNode = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> previous = callbackNode.previous;</span><br><span class="line">    previous.next = next;</span><br><span class="line">    next.previous = previous;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  callbackNode.next = callbackNode.previous = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureHostCallbackIsScheduled</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isExecutingCallback) &#123;</span><br><span class="line">    <span class="comment">// Don&#x27;t schedule work yet; wait until the next time we yield.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Schedule the host callback using the earliest expiration in the list.</span></span><br><span class="line">  <span class="keyword">var</span> expirationTime = firstCallbackNode.expirationTime;</span><br><span class="line">  <span class="keyword">if</span> (!isHostCallbackScheduled) &#123;</span><br><span class="line">    isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Cancel the existing host callback.</span></span><br><span class="line">    cancelHostCallback();</span><br><span class="line">  &#125;</span><br><span class="line">  requestHostCallback(flushWork, expirationTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hasNativePerformanceNow =</span><br><span class="line">  <span class="keyword">typeof</span> performance === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> performance.now === <span class="string">&quot;function&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (hasNativePerformanceNow) &#123;</span><br><span class="line">  <span class="keyword">var</span> Performance = performance;</span><br><span class="line">  getCurrentTime = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Performance.now();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  getCurrentTime = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localDate.now();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟requestIdleCallback</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> requestHostCallback;</span><br><span class="line"><span class="keyword">var</span> cancelHostCallback;</span><br><span class="line"><span class="keyword">var</span> shouldYieldToHost;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> globalValue = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">  globalValue = <span class="built_in">window</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">global</span> !== <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">  globalValue = <span class="built_in">global</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (globalValue &amp;&amp; globalValue._schedMock) &#123;</span><br><span class="line">  <span class="comment">// Dynamic injection, only for testing purposes.</span></span><br><span class="line">  <span class="comment">// 测试使用代码片段</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  <span class="comment">// If Scheduler runs in a non-DOM environment, it falls back to a naive</span></span><br><span class="line">  <span class="comment">// implementation using setTimeout.</span></span><br><span class="line">  <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">&quot;undefined&quot;</span> ||</span><br><span class="line">  <span class="comment">// Check if MessageChannel is supported, too.</span></span><br><span class="line">  <span class="keyword">typeof</span> MessageChannel !== <span class="string">&quot;function&quot;</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// 非浏览器环境，如JavaScriptCore，使用原生setTimeout实现</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 浏览器环境</span></span><br><span class="line">  <span class="comment">// 开始模拟requestIdleCallback</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> scheduledHostCallback = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> isMessageEventScheduled = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> timeoutTime = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> isAnimationFrameScheduled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> isFlushingHostCallback = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> frameDeadline = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// We start out assuming that we run at 30fps but then the heuristic tracking</span></span><br><span class="line">  <span class="comment">// will adjust this value to a faster fps if we get more frequent animation</span></span><br><span class="line">  <span class="comment">// frames.</span></span><br><span class="line">  <span class="keyword">var</span> previousFrameTime = <span class="number">33</span>;</span><br><span class="line">  <span class="keyword">var</span> activeFrameTime = <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">  shouldYieldToHost = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> frameDeadline &lt;= getCurrentTime();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We use the postMessage trick to defer idle work until after the repaint.</span></span><br><span class="line">  <span class="keyword">var</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">  <span class="keyword">var</span> port = channel.port2;</span><br><span class="line">  channel.port1.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    isMessageEventScheduled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> prevScheduledCallback = scheduledHostCallback;</span><br><span class="line">    <span class="keyword">var</span> prevTimeoutTime = timeoutTime;</span><br><span class="line">    scheduledHostCallback = <span class="literal">null</span>;</span><br><span class="line">    timeoutTime = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> currentTime = getCurrentTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> didTimeout = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (frameDeadline - currentTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// There&#x27;s no time left in this idle period. Check if the callback has</span></span><br><span class="line">      <span class="comment">// a timeout and whether it&#x27;s been exceeded.</span></span><br><span class="line">      <span class="keyword">if</span> (prevTimeoutTime !== -<span class="number">1</span> &amp;&amp; prevTimeoutTime &lt;= currentTime) &#123;</span><br><span class="line">        <span class="comment">// Exceeded the timeout. Invoke the callback even though there&#x27;s no</span></span><br><span class="line">        <span class="comment">// time left.</span></span><br><span class="line">        didTimeout = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No timeout.</span></span><br><span class="line">        <span class="keyword">if</span> (!isAnimationFrameScheduled) &#123;</span><br><span class="line">          <span class="comment">// Schedule another animation callback so we retry later.</span></span><br><span class="line">          isAnimationFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">          requestAnimationFrameWithTimeout(animationTick);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Exit without invoking the callback.</span></span><br><span class="line">        scheduledHostCallback = prevScheduledCallback;</span><br><span class="line">        timeoutTime = prevTimeoutTime;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prevScheduledCallback !== <span class="literal">null</span>) &#123;</span><br><span class="line">      isFlushingHostCallback = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        prevScheduledCallback(didTimeout);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        isFlushingHostCallback = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> animationTick = <span class="function"><span class="keyword">function</span> (<span class="params">rafTime</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (scheduledHostCallback !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Eagerly schedule the next animation callback at the beginning of the</span></span><br><span class="line">      <span class="comment">// frame. If the scheduler queue is not empty at the end of the frame, it</span></span><br><span class="line">      <span class="comment">// will continue flushing inside that callback. If the queue *is* empty,</span></span><br><span class="line">      <span class="comment">// then it will exit immediately. Posting the callback at the start of the</span></span><br><span class="line">      <span class="comment">// frame ensures it&#x27;s fired within the earliest possible frame. If we</span></span><br><span class="line">      <span class="comment">// waited until the end of the frame to post the callback, we risk the</span></span><br><span class="line">      <span class="comment">// browser skipping a frame and not firing the callback until the frame</span></span><br><span class="line">      <span class="comment">// after that.</span></span><br><span class="line">      requestAnimationFrameWithTimeout(animationTick);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// No pending work. Exit.</span></span><br><span class="line">      isAnimationFrameScheduled = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> nextFrameTime = rafTime - frameDeadline + activeFrameTime;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      nextFrameTime &lt; activeFrameTime &amp;&amp;</span><br><span class="line">      previousFrameTime &lt; activeFrameTime</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nextFrameTime &lt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="comment">// Defensive coding. We don&#x27;t support higher frame rates than 120hz.</span></span><br><span class="line">        <span class="comment">// If the calculated frame time gets lower than 8, it is probably a bug.</span></span><br><span class="line">        nextFrameTime = <span class="number">8</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// If one frame goes long, then the next one can be short to catch up.</span></span><br><span class="line">      <span class="comment">// If two frames are short in a row, then that&#x27;s an indication that we</span></span><br><span class="line">      <span class="comment">// actually have a higher frame rate than what we&#x27;re currently optimizing.</span></span><br><span class="line">      <span class="comment">// We adjust our heuristic dynamically accordingly. For example, if we&#x27;re</span></span><br><span class="line">      <span class="comment">// running on 120hz display or 90hz VR display.</span></span><br><span class="line">      <span class="comment">// Take the max of the two in case one of them was an anomaly due to</span></span><br><span class="line">      <span class="comment">// missed frame deadlines.</span></span><br><span class="line">      activeFrameTime =</span><br><span class="line">        nextFrameTime &lt; previousFrameTime ? previousFrameTime : nextFrameTime;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      previousFrameTime = nextFrameTime;</span><br><span class="line">    &#125;</span><br><span class="line">    frameDeadline = rafTime + activeFrameTime;</span><br><span class="line">    <span class="keyword">if</span> (!isMessageEventScheduled) &#123;</span><br><span class="line">      isMessageEventScheduled = <span class="literal">true</span>;</span><br><span class="line">      port.postMessage(<span class="literal">undefined</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  requestHostCallback = <span class="function"><span class="keyword">function</span> (<span class="params">callback, absoluteTimeout</span>) </span>&#123;</span><br><span class="line">    scheduledHostCallback = callback;</span><br><span class="line">    timeoutTime = absoluteTimeout;</span><br><span class="line">    <span class="keyword">if</span> (isFlushingHostCallback || absoluteTimeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Don&#x27;t wait for the next frame. Continue working ASAP, in a new event.</span></span><br><span class="line">      port.postMessage(<span class="literal">undefined</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isAnimationFrameScheduled) &#123;</span><br><span class="line">      <span class="comment">// If rAF didn&#x27;t already schedule one, we need to schedule a frame.</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> If this rAF doesn&#x27;t materialize because the browser throttles, we</span></span><br><span class="line">      <span class="comment">// might want to still have setTimeout trigger rIC as a backup to ensure</span></span><br><span class="line">      <span class="comment">// that we keep performing work.</span></span><br><span class="line">      isAnimationFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">      requestAnimationFrameWithTimeout(animationTick);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  cancelHostCallback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    scheduledHostCallback = <span class="literal">null</span>;</span><br><span class="line">    isMessageEventScheduled = <span class="literal">false</span>;</span><br><span class="line">    timeoutTime = -<span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有过期任务强制输出</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushWork</span>(<span class="params">didTimeout</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Exit right away if we&#x27;re currently paused</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSchedulerDebugging &amp;&amp; isSchedulerPaused) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isExecutingCallback = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> previousDidTimeout = currentDidTimeout;</span><br><span class="line">  currentDidTimeout = didTimeout;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (didTimeout) &#123;</span><br><span class="line">      <span class="comment">// Flush all the expired callbacks without yielding.</span></span><br><span class="line">      <span class="keyword">while</span> (</span><br><span class="line">        firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// TODO Wrap i nfeature flag</span></span><br><span class="line">        <span class="comment">// Read the current time. Flush all the callbacks that expire at or</span></span><br><span class="line">        <span class="comment">// earlier than that time. Then read the current time again and repeat.</span></span><br><span class="line">        <span class="comment">// This optimizes for as few performance.now calls as possible.</span></span><br><span class="line">        <span class="keyword">var</span> currentTime = getCurrentTime();</span><br><span class="line">        <span class="comment">// 此处循环链表，执行flushFirstCallback直到第一个不超时的任务</span></span><br><span class="line">        <span class="keyword">if</span> (firstCallbackNode.expirationTime &lt;= currentTime) &#123;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            flushFirstCallback();</span><br><span class="line">          &#125; <span class="keyword">while</span> (</span><br><span class="line">            firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            firstCallbackNode.expirationTime &lt;= currentTime &amp;&amp;</span><br><span class="line">            !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused)</span><br><span class="line">          );</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Keep flushing callbacks until we run out of time in the frame.</span></span><br><span class="line">      <span class="keyword">if</span> (firstCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (enableSchedulerDebugging &amp;&amp; isSchedulerPaused) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          flushFirstCallback();</span><br><span class="line">        &#125; <span class="keyword">while</span> (firstCallbackNode !== <span class="literal">null</span> &amp;&amp; !shouldYieldToHost()); <span class="comment">// 帧时间还有的时候</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isExecutingCallback = <span class="literal">false</span>;</span><br><span class="line">    currentDidTimeout = previousDidTimeout;</span><br><span class="line">    <span class="keyword">if</span> (firstCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// There&#x27;s still work remaining. Request another callback.</span></span><br><span class="line">      ensureHostCallbackIsScheduled();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="performWork"><a href="#performWork" class="headerlink" title="performWork"></a>performWork</h3><ul>
<li><p>是否有 Deadline 区分</p>
</li>
<li><p>循环渲染 Root 的条件</p>
</li>
<li><p>超过时间片的处理</p>
</li>
</ul>
<h3 id="renderRoot"><a href="#renderRoot" class="headerlink" title="renderRoot"></a>renderRoot</h3><ul>
<li><p>调用 workLoop 进行循环单元更新</p>
</li>
<li><p>捕获错误并进行处理</p>
</li>
<li><p>走完流程之后进行善后</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberScheduler.js</span></span><br><span class="line"><span class="comment">// renderRoot  ==&gt; workLoop</span></span><br></pre></td></tr></table></figure>

<h2 id="节点更新-beginWork"><a href="#节点更新-beginWork" class="headerlink" title="节点更新 beginWork"></a>节点更新 beginWork</h2><h3 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h3><p>workLoop ==&gt; performUnitOfWork ==&gt; beginWork ==&gt; completeUnitOfWork</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberBeginWork.js</span></span><br><span class="line"><span class="comment">// beginWork</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> updateExpirationTime = workInProgress.expirationTime;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldProps = current.memoizedProps;</span><br><span class="line">    <span class="keyword">const</span> newProps = workInProgress.pendingProps;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      oldProps === newProps &amp;&amp;</span><br><span class="line">      !hasLegacyContextChanged() &amp;&amp;</span><br><span class="line">      updateExpirationTime &lt; renderExpirationTime</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// This fiber does not have any pending work. Bailout without entering</span></span><br><span class="line">      <span class="comment">// the begin phase. There&#x27;s still some bookkeeping we that needs to be done</span></span><br><span class="line">      <span class="comment">// in this optimized path, mostly pushing stuff onto the stack.</span></span><br><span class="line">      <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> HostRoot:</span><br><span class="line">          pushHostRootContext(workInProgress);</span><br><span class="line">          resetHydrationState();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HostComponent:</span><br><span class="line">          pushHostContext(workInProgress);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">          <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">          <span class="keyword">if</span> (isLegacyContextProvider(Component)) &#123;</span><br><span class="line">            pushLegacyContextProvider(workInProgress);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> HostPortal:</span><br><span class="line">          pushHostContainer(</span><br><span class="line">            workInProgress,</span><br><span class="line">            workInProgress.stateNode.containerInfo</span><br><span class="line">          );</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ContextProvider: &#123;</span><br><span class="line">          <span class="keyword">const</span> newValue = workInProgress.memoizedProps.value;</span><br><span class="line">          pushProvider(workInProgress, newValue);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Profiler:</span><br><span class="line">          <span class="keyword">if</span> (enableProfilerTimer) &#123;</span><br><span class="line">            workInProgress.effectTag |= Update;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SuspenseComponent: &#123;</span><br><span class="line">          <span class="keyword">const</span> state: SuspenseState | <span class="literal">null</span> = workInProgress.memoizedState;</span><br><span class="line">          <span class="keyword">const</span> didTimeout = state !== <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">if</span> (didTimeout) &#123;</span><br><span class="line">            <span class="comment">// If this boundary is currently timed out, we need to decide</span></span><br><span class="line">            <span class="comment">// whether to retry the primary children, or to skip over it and</span></span><br><span class="line">            <span class="comment">// go straight to the fallback. Check the priority of the primary</span></span><br><span class="line">            <span class="comment">// child fragment.</span></span><br><span class="line">            <span class="keyword">const</span> primaryChildFragment: Fiber = (workInProgress.child: any);</span><br><span class="line">            <span class="keyword">const</span> primaryChildExpirationTime =</span><br><span class="line">              primaryChildFragment.childExpirationTime;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">              primaryChildExpirationTime !== NoWork &amp;&amp;</span><br><span class="line">              primaryChildExpirationTime &gt;= renderExpirationTime</span><br><span class="line">            ) &#123;</span><br><span class="line">              <span class="comment">// The primary children have pending work. Use the normal path</span></span><br><span class="line">              <span class="comment">// to attempt to render the primary children again.</span></span><br><span class="line">              <span class="keyword">return</span> updateSuspenseComponent(</span><br><span class="line">                current,</span><br><span class="line">                workInProgress,</span><br><span class="line">                renderExpirationTime</span><br><span class="line">              );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// The primary children do not have pending work with sufficient</span></span><br><span class="line">              <span class="comment">// priority. Bailout.</span></span><br><span class="line">              <span class="comment">// 跳过更新</span></span><br><span class="line">              <span class="keyword">const</span> child = bailoutOnAlreadyFinishedWork(</span><br><span class="line">                current,</span><br><span class="line">                workInProgress,</span><br><span class="line">                renderExpirationTime</span><br><span class="line">              );</span><br><span class="line">              <span class="keyword">if</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// The fallback children have pending work. Skip over the</span></span><br><span class="line">                <span class="comment">// primary children and work on the fallback.</span></span><br><span class="line">                <span class="keyword">return</span> child.sibling;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderExpirationTime</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Before entering the begin phase, clear the expiration time.</span></span><br><span class="line">  workInProgress.expirationTime = NoWork;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> elementType = workInProgress.elementType;</span><br><span class="line">      <span class="keyword">return</span> mountIndeterminateComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        elementType,</span><br><span class="line">        renderExpirationTime</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LazyComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> elementType = workInProgress.elementType;</span><br><span class="line">      <span class="keyword">return</span> mountLazyComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        elementType,</span><br><span class="line">        updateExpirationTime,</span><br><span class="line">        renderExpirationTime</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> FunctionComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateFunctionComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderExpirationTime</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateClassComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderExpirationTime</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostRoot:</span><br><span class="line">      <span class="keyword">return</span> updateHostRoot(current, workInProgress, renderExpirationTime);</span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">      <span class="keyword">return</span> updateHostComponent(current, workInProgress, renderExpirationTime);</span><br><span class="line">    <span class="keyword">case</span> HostText:</span><br><span class="line">      <span class="keyword">return</span> updateHostText(current, workInProgress);</span><br><span class="line">    <span class="keyword">case</span> SuspenseComponent:</span><br><span class="line">      <span class="keyword">return</span> updateSuspenseComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderExpirationTime</span><br><span class="line">      );</span><br><span class="line">    <span class="keyword">case</span> HostPortal:</span><br><span class="line">      <span class="keyword">return</span> updatePortalComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderExpirationTime</span><br><span class="line">      );</span><br><span class="line">    <span class="keyword">case</span> ForwardRef: &#123;</span><br><span class="line">      <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === type</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(type, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateForwardRef(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        type,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderExpirationTime</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Fragment:</span><br><span class="line">      <span class="keyword">return</span> updateFragment(current, workInProgress, renderExpirationTime);</span><br><span class="line">    <span class="keyword">case</span> Mode:</span><br><span class="line">      <span class="keyword">return</span> updateMode(current, workInProgress, renderExpirationTime);</span><br><span class="line">    <span class="keyword">case</span> Profiler:</span><br><span class="line">      <span class="keyword">return</span> updateProfiler(current, workInProgress, renderExpirationTime);</span><br><span class="line">    <span class="keyword">case</span> ContextProvider:</span><br><span class="line">      <span class="keyword">return</span> updateContextProvider(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderExpirationTime</span><br><span class="line">      );</span><br><span class="line">    <span class="keyword">case</span> ContextConsumer:</span><br><span class="line">      <span class="keyword">return</span> updateContextConsumer(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderExpirationTime</span><br><span class="line">      );</span><br><span class="line">    <span class="keyword">case</span> MemoComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="comment">// Resolve outer props first, then resolve inner props.</span></span><br><span class="line">      <span class="keyword">let</span> resolvedProps = resolveDefaultProps(type, unresolvedProps);</span><br><span class="line">      resolvedProps = resolveDefaultProps(type.type, resolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateMemoComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        type,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        updateExpirationTime,</span><br><span class="line">        renderExpirationTime</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">      <span class="keyword">return</span> updateSimpleMemoComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        workInProgress.type,</span><br><span class="line">        workInProgress.pendingProps,</span><br><span class="line">        updateExpirationTime,</span><br><span class="line">        renderExpirationTime</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> IncompleteClassComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> mountIncompleteClassComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderExpirationTime</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      invariant(</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Unknown unit of work tag. This error is likely caused by a bug in &quot;</span> +</span><br><span class="line">          <span class="string">&quot;React. Please file an issue.&quot;</span></span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FunctionComponent"><a href="#FunctionComponent" class="headerlink" title="FunctionComponent"></a>FunctionComponent</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberBeginWork.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> FunctionComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="comment">// Suspend相关</span></span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateFunctionComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> unmaskedContext = getUnmaskedContext(workInProgress, Component, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> context = getMaskedContext(workInProgress, unmaskedContext);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> nextChildren;</span><br><span class="line">  prepareToReadContext(workInProgress, renderExpirationTime);</span><br><span class="line">  prepareToUseHooks(current, workInProgress, renderExpirationTime);</span><br><span class="line">  <span class="comment">// 函数组件里面又传入了第二个参数context</span></span><br><span class="line">  nextChildren = Component(nextProps, context);</span><br><span class="line">  nextChildren = finishHooks(Component, nextProps, nextChildren, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// React DevTools reads this flag.</span></span><br><span class="line">  workInProgress.effectTag |= PerformedWork;</span><br><span class="line">  <span class="comment">// 核心步骤，用于调和子结点nextChildren</span></span><br><span class="line">  reconcileChildren(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    nextChildren,</span><br><span class="line">    renderExpirationTime,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="reconcileChildren"><a href="#reconcileChildren" class="headerlink" title="reconcileChildren"></a>reconcileChildren</h3><ul>
<li><p>根据 props.children 生成 Fiber 子树</p>
</li>
<li><p>判断 Fiber 对象是否可以复用</p>
</li>
<li><p>列表根据 key 优化</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberBeginWork.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextChildren: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If this is a fresh new component that hasn&#x27;t been rendered yet, we</span></span><br><span class="line">    <span class="comment">// won&#x27;t update its child set by applying minimal side-effects. Instead,</span></span><br><span class="line">    <span class="comment">// we will add them all to the child before it gets rendered. That means</span></span><br><span class="line">    <span class="comment">// we can optimize this reconciliation pass by not tracking side-effects.</span></span><br><span class="line">    workInProgress.child = mountChildFibers(</span><br><span class="line">      workInProgress,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If the current child is the same as the work in progress, it means that</span></span><br><span class="line">    <span class="comment">// we haven&#x27;t yet started any work on these children. Therefore, we use</span></span><br><span class="line">    <span class="comment">// the clone algorithm to create a copy of all the current children.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we had any progressed work already, that is invalid at this point so</span></span><br><span class="line">    <span class="comment">// let&#x27;s throw it out.</span></span><br><span class="line">    workInProgress.child = reconcileChildFibers(</span><br><span class="line">      workInProgress,</span><br><span class="line">      current.child,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react-reconciler\src\ReactChildFiber.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reconcileChildFibers = ChildReconciler(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mountChildFibers = ChildReconciler(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This wrapper function exists because I expect to clone the code in each path</span></span><br><span class="line"><span class="comment">// to be able to optimize each path individually by branching early. This needs</span></span><br><span class="line"><span class="comment">// a compiler or we can do it manually. Helpers that don&#x27;t need this branching</span></span><br><span class="line"><span class="comment">// live outside of this function.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChildReconciler</span>(<span class="params">shouldTrackSideEffects</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">deleteChild</span>(<span class="params">returnFiber: Fiber, childToDelete: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!shouldTrackSideEffects) &#123;</span><br><span class="line">      <span class="comment">// Noop.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Deletions are added in reversed order so we add it to the front.</span></span><br><span class="line">    <span class="comment">// At this point, the return fiber&#x27;s effect list is empty except for</span></span><br><span class="line">    <span class="comment">// deletions, so we can just append the deletion to the list. The remaining</span></span><br><span class="line">    <span class="comment">// effects aren&#x27;t added until the complete phase. Once we implement</span></span><br><span class="line">    <span class="comment">// resuming, this may not be true.</span></span><br><span class="line">    <span class="keyword">const</span> last = returnFiber.lastEffect;</span><br><span class="line">    <span class="keyword">if</span> (last !== <span class="literal">null</span>) &#123;</span><br><span class="line">      last.nextEffect = childToDelete;</span><br><span class="line">      returnFiber.lastEffect = childToDelete;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;</span><br><span class="line">    &#125;</span><br><span class="line">    childToDelete.nextEffect = <span class="literal">null</span>;</span><br><span class="line">    childToDelete.effectTag = Deletion;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">deleteRemainingChildren</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | <span class="literal">null</span></span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!shouldTrackSideEffects) &#123;</span><br><span class="line">      <span class="comment">// Noop.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> For the shouldClone case, this could be micro-optimized a bit by</span></span><br><span class="line">    <span class="comment">// assuming that after the first child we&#x27;ve already added everything.</span></span><br><span class="line">    <span class="keyword">let</span> childToDelete = currentFirstChild;</span><br><span class="line">    <span class="keyword">while</span> (childToDelete !== <span class="literal">null</span>) &#123;</span><br><span class="line">      deleteChild(returnFiber, childToDelete);</span><br><span class="line">      childToDelete = childToDelete.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mapRemainingChildren</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Map</span>&lt;<span class="title">string</span> | <span class="title">number</span>, <span class="title">Fiber</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Add the remaining children to a temporary map so that we can find them by</span></span><br><span class="line">    <span class="comment">// keys quickly. Implicit (null) keys get added to this set with their index</span></span><br><span class="line">    <span class="comment">// instead.</span></span><br><span class="line">    <span class="keyword">const</span> existingChildren: <span class="built_in">Map</span>&lt;string | number, Fiber&gt; = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> existingChild = currentFirstChild;</span><br><span class="line">    <span class="keyword">while</span> (existingChild !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (existingChild.key !== <span class="literal">null</span>) &#123;</span><br><span class="line">        existingChildren.set(existingChild.key, existingChild);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        existingChildren.set(existingChild.index, existingChild);</span><br><span class="line">      &#125;</span><br><span class="line">      existingChild = existingChild.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> existingChildren;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">useFiber</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    pendingProps: mixed,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We currently set sibling to null and index to 0 here because it is easy</span></span><br><span class="line">    <span class="comment">// to forget to do before returning it. E.g. for the single child case.</span></span><br><span class="line">    <span class="keyword">const</span> clone = createWorkInProgress(fiber, pendingProps, expirationTime);</span><br><span class="line">    clone.index = <span class="number">0</span>;</span><br><span class="line">    clone.sibling = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">placeChild</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    newFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    lastPlacedIndex: number,</span></span></span><br><span class="line"><span class="function"><span class="params">    newIndex: number</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    newFiber.index = newIndex;</span><br><span class="line">    <span class="keyword">if</span> (!shouldTrackSideEffects) &#123;</span><br><span class="line">      <span class="comment">// Noop.</span></span><br><span class="line">      <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> current = newFiber.alternate;</span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldIndex = current.index;</span><br><span class="line">      <span class="keyword">if</span> (oldIndex &lt; lastPlacedIndex) &#123;</span><br><span class="line">        <span class="comment">// This is a move.</span></span><br><span class="line">        newFiber.effectTag = Placement;</span><br><span class="line">        <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This item can stay in place.</span></span><br><span class="line">        <span class="keyword">return</span> oldIndex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// This is an insertion.</span></span><br><span class="line">      newFiber.effectTag = Placement;</span><br><span class="line">      <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">placeSingleChild</span>(<span class="params">newFiber: Fiber</span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This is simpler for the single child case. We only need to do a</span></span><br><span class="line">    <span class="comment">// placement for inserting new children.</span></span><br><span class="line">    <span class="keyword">if</span> (shouldTrackSideEffects &amp;&amp; newFiber.alternate === <span class="literal">null</span>) &#123;</span><br><span class="line">      newFiber.effectTag = Placement;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newFiber;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">updateTextNode</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    textContent: string,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current === <span class="literal">null</span> || current.tag !== HostText) &#123;</span><br><span class="line">      <span class="comment">// Insert</span></span><br><span class="line">      <span class="keyword">const</span> created = createFiberFromText(</span><br><span class="line">        textContent,</span><br><span class="line">        returnFiber.mode,</span><br><span class="line">        expirationTime</span><br><span class="line">      );</span><br><span class="line">      created.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> created;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Update</span></span><br><span class="line">      <span class="keyword">const</span> existing = useFiber(current, textContent, expirationTime);</span><br><span class="line">      existing.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> existing;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">updateElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    element: ReactElement,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; current.elementType === element.type) &#123;</span><br><span class="line">      <span class="comment">// Move based on index</span></span><br><span class="line">      <span class="keyword">const</span> existing = useFiber(current, element.props, expirationTime);</span><br><span class="line">      existing.ref = coerceRef(returnFiber, current, element);</span><br><span class="line">      existing.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> existing;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Insert</span></span><br><span class="line">      <span class="keyword">const</span> created = createFiberFromElement(</span><br><span class="line">        element,</span><br><span class="line">        returnFiber.mode,</span><br><span class="line">        expirationTime</span><br><span class="line">      );</span><br><span class="line">      created.ref = coerceRef(returnFiber, current, element);</span><br><span class="line">      created.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> created;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">updatePortal</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    portal: ReactPortal,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      current === <span class="literal">null</span> ||</span><br><span class="line">      current.tag !== HostPortal ||</span><br><span class="line">      current.stateNode.containerInfo !== portal.containerInfo ||</span><br><span class="line">      current.stateNode.implementation !== portal.implementation</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// Insert</span></span><br><span class="line">      <span class="keyword">const</span> created = createFiberFromPortal(</span><br><span class="line">        portal,</span><br><span class="line">        returnFiber.mode,</span><br><span class="line">        expirationTime</span><br><span class="line">      );</span><br><span class="line">      created.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> created;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Update</span></span><br><span class="line">      <span class="keyword">const</span> existing = useFiber(current, portal.children || [], expirationTime);</span><br><span class="line">      existing.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> existing;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">updateFragment</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    fragment: Iterable&lt;*&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">    key: <span class="literal">null</span> | string</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current === <span class="literal">null</span> || current.tag !== Fragment) &#123;</span><br><span class="line">      <span class="comment">// Insert</span></span><br><span class="line">      <span class="keyword">const</span> created = createFiberFromFragment(</span><br><span class="line">        fragment,</span><br><span class="line">        returnFiber.mode,</span><br><span class="line">        expirationTime,</span><br><span class="line">        key</span><br><span class="line">      );</span><br><span class="line">      created.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> created;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Update</span></span><br><span class="line">      <span class="keyword">const</span> existing = useFiber(current, fragment, expirationTime);</span><br><span class="line">      existing.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> existing;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createChild</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChild: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&quot;string&quot;</span> || <span class="keyword">typeof</span> newChild === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// Text nodes don&#x27;t have keys. If the previous node is implicitly keyed</span></span><br><span class="line">      <span class="comment">// we can continue to replace it without aborting even if it is not a text</span></span><br><span class="line">      <span class="comment">// node.</span></span><br><span class="line">      <span class="keyword">const</span> created = createFiberFromText(</span><br><span class="line">        <span class="string">&quot;&quot;</span> + newChild,</span><br><span class="line">        returnFiber.mode,</span><br><span class="line">        expirationTime</span><br><span class="line">      );</span><br><span class="line">      created.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> created;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&quot;object&quot;</span> &amp;&amp; newChild !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (newChild.$$typeof) &#123;</span><br><span class="line">        <span class="keyword">case</span> REACT_ELEMENT_TYPE: &#123;</span><br><span class="line">          <span class="keyword">const</span> created = createFiberFromElement(</span><br><span class="line">            newChild,</span><br><span class="line">            returnFiber.mode,</span><br><span class="line">            expirationTime</span><br><span class="line">          );</span><br><span class="line">          created.ref = coerceRef(returnFiber, <span class="literal">null</span>, newChild);</span><br><span class="line">          created.return = returnFiber;</span><br><span class="line">          <span class="keyword">return</span> created;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> REACT_PORTAL_TYPE: &#123;</span><br><span class="line">          <span class="keyword">const</span> created = createFiberFromPortal(</span><br><span class="line">            newChild,</span><br><span class="line">            returnFiber.mode,</span><br><span class="line">            expirationTime</span><br><span class="line">          );</span><br><span class="line">          created.return = returnFiber;</span><br><span class="line">          <span class="keyword">return</span> created;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isArray(newChild) || getIteratorFn(newChild)) &#123;</span><br><span class="line">        <span class="keyword">const</span> created = createFiberFromFragment(</span><br><span class="line">          newChild,</span><br><span class="line">          returnFiber.mode,</span><br><span class="line">          expirationTime,</span><br><span class="line">          <span class="literal">null</span></span><br><span class="line">        );</span><br><span class="line">        created.return = returnFiber;</span><br><span class="line">        <span class="keyword">return</span> created;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      throwOnInvalidObjectType(returnFiber, newChild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">updateSlot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    oldFiber: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChild: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Update the fiber if the keys match, otherwise return null.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> key = oldFiber !== <span class="literal">null</span> ? oldFiber.key : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&quot;string&quot;</span> || <span class="keyword">typeof</span> newChild === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// Text nodes don&#x27;t have keys. If the previous node is implicitly keyed</span></span><br><span class="line">      <span class="comment">// we can continue to replace it without aborting even if it is not a text</span></span><br><span class="line">      <span class="comment">// node.</span></span><br><span class="line">      <span class="keyword">if</span> (key !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> updateTextNode(</span><br><span class="line">        returnFiber,</span><br><span class="line">        oldFiber,</span><br><span class="line">        <span class="string">&quot;&quot;</span> + newChild,</span><br><span class="line">        expirationTime</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&quot;object&quot;</span> &amp;&amp; newChild !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (newChild.$$typeof) &#123;</span><br><span class="line">        <span class="keyword">case</span> REACT_ELEMENT_TYPE: &#123;</span><br><span class="line">          <span class="keyword">if</span> (newChild.key === key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newChild.type === REACT_FRAGMENT_TYPE) &#123;</span><br><span class="line">              <span class="keyword">return</span> updateFragment(</span><br><span class="line">                returnFiber,</span><br><span class="line">                oldFiber,</span><br><span class="line">                newChild.props.children,</span><br><span class="line">                expirationTime,</span><br><span class="line">                key</span><br><span class="line">              );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> updateElement(</span><br><span class="line">              returnFiber,</span><br><span class="line">              oldFiber,</span><br><span class="line">              newChild,</span><br><span class="line">              expirationTime</span><br><span class="line">            );</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> REACT_PORTAL_TYPE: &#123;</span><br><span class="line">          <span class="keyword">if</span> (newChild.key === key) &#123;</span><br><span class="line">            <span class="keyword">return</span> updatePortal(</span><br><span class="line">              returnFiber,</span><br><span class="line">              oldFiber,</span><br><span class="line">              newChild,</span><br><span class="line">              expirationTime</span><br><span class="line">            );</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isArray(newChild) || getIteratorFn(newChild)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> updateFragment(</span><br><span class="line">          returnFiber,</span><br><span class="line">          oldFiber,</span><br><span class="line">          newChild,</span><br><span class="line">          expirationTime,</span><br><span class="line">          <span class="literal">null</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      throwOnInvalidObjectType(returnFiber, newChild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">updateFromMap</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    existingChildren: <span class="built_in">Map</span>&lt;string | number, Fiber&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    newIdx: number,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChild: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&quot;string&quot;</span> || <span class="keyword">typeof</span> newChild === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// Text nodes don&#x27;t have keys, so we neither have to check the old nor</span></span><br><span class="line">      <span class="comment">// new node for the key. If both are text nodes, they match.</span></span><br><span class="line">      <span class="keyword">const</span> matchedFiber = existingChildren.get(newIdx) || <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> updateTextNode(</span><br><span class="line">        returnFiber,</span><br><span class="line">        matchedFiber,</span><br><span class="line">        <span class="string">&quot;&quot;</span> + newChild,</span><br><span class="line">        expirationTime</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&quot;object&quot;</span> &amp;&amp; newChild !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (newChild.$$typeof) &#123;</span><br><span class="line">        <span class="keyword">case</span> REACT_ELEMENT_TYPE: &#123;</span><br><span class="line">          <span class="keyword">const</span> matchedFiber =</span><br><span class="line">            existingChildren.get(</span><br><span class="line">              newChild.key === <span class="literal">null</span> ? newIdx : newChild.key</span><br><span class="line">            ) || <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">if</span> (newChild.type === REACT_FRAGMENT_TYPE) &#123;</span><br><span class="line">            <span class="keyword">return</span> updateFragment(</span><br><span class="line">              returnFiber,</span><br><span class="line">              matchedFiber,</span><br><span class="line">              newChild.props.children,</span><br><span class="line">              expirationTime,</span><br><span class="line">              newChild.key</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> updateElement(</span><br><span class="line">            returnFiber,</span><br><span class="line">            matchedFiber,</span><br><span class="line">            newChild,</span><br><span class="line">            expirationTime</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> REACT_PORTAL_TYPE: &#123;</span><br><span class="line">          <span class="keyword">const</span> matchedFiber =</span><br><span class="line">            existingChildren.get(</span><br><span class="line">              newChild.key === <span class="literal">null</span> ? newIdx : newChild.key</span><br><span class="line">            ) || <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">return</span> updatePortal(</span><br><span class="line">            returnFiber,</span><br><span class="line">            matchedFiber,</span><br><span class="line">            newChild,</span><br><span class="line">            expirationTime</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isArray(newChild) || getIteratorFn(newChild)) &#123;</span><br><span class="line">        <span class="keyword">const</span> matchedFiber = existingChildren.get(newIdx) || <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> updateFragment(</span><br><span class="line">          returnFiber,</span><br><span class="line">          matchedFiber,</span><br><span class="line">          newChild,</span><br><span class="line">          expirationTime,</span><br><span class="line">          <span class="literal">null</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      throwOnInvalidObjectType(returnFiber, newChild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过key尽可能地复用可复用的Fiber节点，减少对象声明和内存回收的损耗</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reconcileChildrenArray</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChildren: <span class="built_in">Array</span>&lt;*&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This algorithm can&#x27;t optimize by searching from boths ends since we</span></span><br><span class="line">    <span class="comment">// don&#x27;t have backpointers on fibers. I&#x27;m trying to see how far we can get</span></span><br><span class="line">    <span class="comment">// with that model. If it ends up not being worth the tradeoffs, we can</span></span><br><span class="line">    <span class="comment">// add it later.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Even with a two ended optimization, we&#x27;d want to optimize for the case</span></span><br><span class="line">    <span class="comment">// where there are few changes and brute force the comparison instead of</span></span><br><span class="line">    <span class="comment">// going for the Map. It&#x27;d like to explore hitting that path first in</span></span><br><span class="line">    <span class="comment">// forward-only mode and only go for the Map once we notice that we need</span></span><br><span class="line">    <span class="comment">// lots of look ahead. This doesn&#x27;t handle reversal as well as two ended</span></span><br><span class="line">    <span class="comment">// search but that&#x27;s unusual. Besides, for the two ended optimization to</span></span><br><span class="line">    <span class="comment">// work on Iterables, we&#x27;d need to copy the whole set.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// In this first iteration, we&#x27;ll just live with hitting the bad case</span></span><br><span class="line">    <span class="comment">// (adding everything to a Map) in for every insert/move.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If you change this code, also update reconcileChildrenIterator() which</span></span><br><span class="line">    <span class="comment">// uses the same algorithm.</span></span><br><span class="line">    <span class="keyword">let</span> resultingFirstChild: Fiber | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> previousNewFiber: Fiber | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> oldFiber = currentFirstChild;</span><br><span class="line">    <span class="keyword">let</span> lastPlacedIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> newIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> nextOldFiber = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldFiber.index &gt; newIdx) &#123;</span><br><span class="line">        nextOldFiber = oldFiber;</span><br><span class="line">        oldFiber = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nextOldFiber = oldFiber.sibling;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> newFiber = updateSlot(</span><br><span class="line">        returnFiber,</span><br><span class="line">        oldFiber,</span><br><span class="line">        newChildren[newIdx],</span><br><span class="line">        expirationTime</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> This breaks on empty slots like null children. That&#x27;s</span></span><br><span class="line">        <span class="comment">// unfortunate because it triggers the slow path all the time. We need</span></span><br><span class="line">        <span class="comment">// a better way to communicate whether this was a miss or null,</span></span><br><span class="line">        <span class="comment">// boolean, undefined, etc.</span></span><br><span class="line">        <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          oldFiber = nextOldFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldFiber &amp;&amp; newFiber.alternate === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// We matched the slot, but we didn&#x27;t reuse the existing fiber, so we</span></span><br><span class="line">          <span class="comment">// need to delete the existing child.</span></span><br><span class="line">          deleteChild(returnFiber, oldFiber);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">      <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Move out of the loop. This only happens for the first run.</span></span><br><span class="line">        resultingFirstChild = newFiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Defer siblings if we&#x27;re not at the right index for this slot.</span></span><br><span class="line">        <span class="comment">// I.e. if we had null values before, then we want to defer this</span></span><br><span class="line">        <span class="comment">// for each null value. However, we also don&#x27;t want to call updateSlot</span></span><br><span class="line">        <span class="comment">// with the previous one.</span></span><br><span class="line">        previousNewFiber.sibling = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">      oldFiber = nextOldFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newIdx === newChildren.length) &#123;</span><br><span class="line">      <span class="comment">// We&#x27;ve reached the end of the new children. We can delete the rest.</span></span><br><span class="line">      deleteRemainingChildren(returnFiber, oldFiber);</span><br><span class="line">      <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If we don&#x27;t have any more existing children we can choose a fast path</span></span><br><span class="line">      <span class="comment">// since the rest will all be insertions.</span></span><br><span class="line">      <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">        <span class="keyword">const</span> newFiber = createChild(</span><br><span class="line">          returnFiber,</span><br><span class="line">          newChildren[newIdx],</span><br><span class="line">          expirationTime</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (!newFiber) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">        <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> Move out of the loop. This only happens for the first run.</span></span><br><span class="line">          resultingFirstChild = newFiber;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          previousNewFiber.sibling = newFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        previousNewFiber = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add all children to a key map for quick lookups.</span></span><br><span class="line">    <span class="keyword">const</span> existingChildren = mapRemainingChildren(returnFiber, oldFiber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep scanning and use the map to restore deleted items as moves.</span></span><br><span class="line">    <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">      <span class="keyword">const</span> newFiber = updateFromMap(</span><br><span class="line">        existingChildren,</span><br><span class="line">        returnFiber,</span><br><span class="line">        newIdx,</span><br><span class="line">        newChildren[newIdx],</span><br><span class="line">        expirationTime</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (newFiber) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">          <span class="keyword">if</span> (newFiber.alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// The new fiber is a work in progress, but if there exists a</span></span><br><span class="line">            <span class="comment">// current, that means that we reused the fiber. We need to delete</span></span><br><span class="line">            <span class="comment">// it from the child list so that we don&#x27;t add it to the deletion</span></span><br><span class="line">            <span class="comment">// list.</span></span><br><span class="line">            existingChildren.delete(</span><br><span class="line">              newFiber.key === <span class="literal">null</span> ? newIdx : newFiber.key</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">        <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          resultingFirstChild = newFiber;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          previousNewFiber.sibling = newFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        previousNewFiber = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">      <span class="comment">// Any existing children that weren&#x27;t consumed above were deleted. We need</span></span><br><span class="line">      <span class="comment">// to add them to the deletion list.</span></span><br><span class="line">      existingChildren.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> deleteChild(returnFiber, child));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reconcileChildrenIterator</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChildrenIterable: Iterable&lt;*&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This is the same implementation as reconcileChildrenArray(),</span></span><br><span class="line">    <span class="comment">// but using the iterator instead.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> iteratorFn = getIteratorFn(newChildrenIterable);</span><br><span class="line">    <span class="keyword">const</span> newChildren = iteratorFn.call(newChildrenIterable);</span><br><span class="line">    invariant(newChildren != <span class="literal">null</span>, <span class="string">&quot;An iterable object provided no iterator.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> resultingFirstChild: Fiber | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> previousNewFiber: Fiber | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> oldFiber = currentFirstChild;</span><br><span class="line">    <span class="keyword">let</span> lastPlacedIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> newIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> nextOldFiber = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> step = newChildren.next();</span><br><span class="line">    <span class="keyword">for</span> (</span><br><span class="line">      ;</span><br><span class="line">      oldFiber !== <span class="literal">null</span> &amp;&amp; !step.done;</span><br><span class="line">      newIdx++, step = newChildren.next()</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldFiber.index &gt; newIdx) &#123;</span><br><span class="line">        nextOldFiber = oldFiber;</span><br><span class="line">        oldFiber = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nextOldFiber = oldFiber.sibling;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> newFiber = updateSlot(</span><br><span class="line">        returnFiber,</span><br><span class="line">        oldFiber,</span><br><span class="line">        step.value,</span><br><span class="line">        expirationTime</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> This breaks on empty slots like null children. That&#x27;s</span></span><br><span class="line">        <span class="comment">// unfortunate because it triggers the slow path all the time. We need</span></span><br><span class="line">        <span class="comment">// a better way to communicate whether this was a miss or null,</span></span><br><span class="line">        <span class="comment">// boolean, undefined, etc.</span></span><br><span class="line">        <span class="keyword">if</span> (!oldFiber) &#123;</span><br><span class="line">          oldFiber = nextOldFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldFiber &amp;&amp; newFiber.alternate === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// We matched the slot, but we didn&#x27;t reuse the existing fiber, so we</span></span><br><span class="line">          <span class="comment">// need to delete the existing child.</span></span><br><span class="line">          deleteChild(returnFiber, oldFiber);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">      <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Move out of the loop. This only happens for the first run.</span></span><br><span class="line">        resultingFirstChild = newFiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Defer siblings if we&#x27;re not at the right index for this slot.</span></span><br><span class="line">        <span class="comment">// I.e. if we had null values before, then we want to defer this</span></span><br><span class="line">        <span class="comment">// for each null value. However, we also don&#x27;t want to call updateSlot</span></span><br><span class="line">        <span class="comment">// with the previous one.</span></span><br><span class="line">        previousNewFiber.sibling = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">      oldFiber = nextOldFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (step.done) &#123;</span><br><span class="line">      <span class="comment">// We&#x27;ve reached the end of the new children. We can delete the rest.</span></span><br><span class="line">      deleteRemainingChildren(returnFiber, oldFiber);</span><br><span class="line">      <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If we don&#x27;t have any more existing children we can choose a fast path</span></span><br><span class="line">      <span class="comment">// since the rest will all be insertions.</span></span><br><span class="line">      <span class="keyword">for</span> (; !step.done; newIdx++, step = newChildren.next()) &#123;</span><br><span class="line">        <span class="keyword">const</span> newFiber = createChild(returnFiber, step.value, expirationTime);</span><br><span class="line">        <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">        <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> Move out of the loop. This only happens for the first run.</span></span><br><span class="line">          resultingFirstChild = newFiber;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          previousNewFiber.sibling = newFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        previousNewFiber = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add all children to a key map for quick lookups.</span></span><br><span class="line">    <span class="keyword">const</span> existingChildren = mapRemainingChildren(returnFiber, oldFiber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep scanning and use the map to restore deleted items as moves.</span></span><br><span class="line">    <span class="keyword">for</span> (; !step.done; newIdx++, step = newChildren.next()) &#123;</span><br><span class="line">      <span class="keyword">const</span> newFiber = updateFromMap(</span><br><span class="line">        existingChildren,</span><br><span class="line">        returnFiber,</span><br><span class="line">        newIdx,</span><br><span class="line">        step.value,</span><br><span class="line">        expirationTime</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (newFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">          <span class="keyword">if</span> (newFiber.alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// The new fiber is a work in progress, but if there exists a</span></span><br><span class="line">            <span class="comment">// current, that means that we reused the fiber. We need to delete</span></span><br><span class="line">            <span class="comment">// it from the child list so that we don&#x27;t add it to the deletion</span></span><br><span class="line">            <span class="comment">// list.</span></span><br><span class="line">            existingChildren.delete(</span><br><span class="line">              newFiber.key === <span class="literal">null</span> ? newIdx : newFiber.key</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">        <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">          resultingFirstChild = newFiber;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          previousNewFiber.sibling = newFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        previousNewFiber = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">      <span class="comment">// Any existing children that weren&#x27;t consumed above were deleted. We need</span></span><br><span class="line">      <span class="comment">// to add them to the deletion list.</span></span><br><span class="line">      existingChildren.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> deleteChild(returnFiber, child));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reconcileSingleTextNode</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    textContent: string,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">    <span class="comment">// There&#x27;s no need to check for keys on text nodes since we don&#x27;t have a</span></span><br><span class="line">    <span class="comment">// way to define them.</span></span><br><span class="line">    <span class="keyword">if</span> (currentFirstChild !== <span class="literal">null</span> &amp;&amp; currentFirstChild.tag === HostText) &#123;</span><br><span class="line">      <span class="comment">// We already have an existing node so let&#x27;s just update it and delete</span></span><br><span class="line">      <span class="comment">// the rest.</span></span><br><span class="line">      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);</span><br><span class="line">      <span class="keyword">const</span> existing = useFiber(currentFirstChild, textContent, expirationTime);</span><br><span class="line">      existing.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> existing;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The existing first child is not a text node so we need to create one</span></span><br><span class="line">    <span class="comment">// and delete the existing ones.</span></span><br><span class="line">    deleteRemainingChildren(returnFiber, currentFirstChild);</span><br><span class="line">    <span class="keyword">const</span> created = createFiberFromText(</span><br><span class="line">      textContent,</span><br><span class="line">      returnFiber.mode,</span><br><span class="line">      expirationTime</span><br><span class="line">    );</span><br><span class="line">    created.return = returnFiber;</span><br><span class="line">    <span class="keyword">return</span> created;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reconcileSingleElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    element: ReactElement,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> key = element.key;</span><br><span class="line">    <span class="keyword">let</span> child = currentFirstChild;</span><br><span class="line">    <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> If key === null and child.key === null, then this only applies to</span></span><br><span class="line">      <span class="comment">// the first item in the list.</span></span><br><span class="line">      <span class="keyword">if</span> (child.key === key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          child.tag === Fragment</span><br><span class="line">            ? element.type === REACT_FRAGMENT_TYPE</span><br><span class="line">            : child.elementType === element.type</span><br><span class="line">        ) &#123;</span><br><span class="line">          deleteRemainingChildren(returnFiber, child.sibling);</span><br><span class="line">          <span class="keyword">const</span> existing = useFiber(</span><br><span class="line">            child,</span><br><span class="line">            element.type === REACT_FRAGMENT_TYPE</span><br><span class="line">              ? element.props.children</span><br><span class="line">              : element.props,</span><br><span class="line">            expirationTime</span><br><span class="line">          );</span><br><span class="line">          existing.ref = coerceRef(returnFiber, child, element);</span><br><span class="line">          existing.return = returnFiber;</span><br><span class="line">          <span class="keyword">return</span> existing;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          deleteRemainingChildren(returnFiber, child);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        deleteChild(returnFiber, child);</span><br><span class="line">      &#125;</span><br><span class="line">      child = child.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (element.type === REACT_FRAGMENT_TYPE) &#123;</span><br><span class="line">      <span class="keyword">const</span> created = createFiberFromFragment(</span><br><span class="line">        element.props.children,</span><br><span class="line">        returnFiber.mode,</span><br><span class="line">        expirationTime,</span><br><span class="line">        element.key</span><br><span class="line">      );</span><br><span class="line">      created.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> created;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> created = createFiberFromElement(</span><br><span class="line">        element,</span><br><span class="line">        returnFiber.mode,</span><br><span class="line">        expirationTime</span><br><span class="line">      );</span><br><span class="line">      created.ref = coerceRef(returnFiber, currentFirstChild, element);</span><br><span class="line">      created.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> created;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reconcileSinglePortal</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    portal: ReactPortal,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> key = portal.key;</span><br><span class="line">    <span class="keyword">let</span> child = currentFirstChild;</span><br><span class="line">    <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> If key === null and child.key === null, then this only applies to</span></span><br><span class="line">      <span class="comment">// the first item in the list.</span></span><br><span class="line">      <span class="keyword">if</span> (child.key === key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          child.tag === HostPortal &amp;&amp;</span><br><span class="line">          child.stateNode.containerInfo === portal.containerInfo &amp;&amp;</span><br><span class="line">          child.stateNode.implementation === portal.implementation</span><br><span class="line">        ) &#123;</span><br><span class="line">          deleteRemainingChildren(returnFiber, child.sibling);</span><br><span class="line">          <span class="keyword">const</span> existing = useFiber(</span><br><span class="line">            child,</span><br><span class="line">            portal.children || [],</span><br><span class="line">            expirationTime</span><br><span class="line">          );</span><br><span class="line">          existing.return = returnFiber;</span><br><span class="line">          <span class="keyword">return</span> existing;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          deleteRemainingChildren(returnFiber, child);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        deleteChild(returnFiber, child);</span><br><span class="line">      &#125;</span><br><span class="line">      child = child.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> created = createFiberFromPortal(</span><br><span class="line">      portal,</span><br><span class="line">      returnFiber.mode,</span><br><span class="line">      expirationTime</span><br><span class="line">    );</span><br><span class="line">    created.return = returnFiber;</span><br><span class="line">    <span class="keyword">return</span> created;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This API will tag the children with the side-effect of the reconciliation</span></span><br><span class="line">  <span class="comment">// itself. They will be added to the side-effect list as we pass through the</span></span><br><span class="line">  <span class="comment">// children and the parent.</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reconcileChildFibers</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChild: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    expirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function is not recursive.</span></span><br><span class="line">    <span class="comment">// If the top level item is an array, we treat it as a set of children,</span></span><br><span class="line">    <span class="comment">// not as a fragment. Nested arrays on the other hand will be treated as</span></span><br><span class="line">    <span class="comment">// fragment nodes. Recursion happens at the normal flow.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle top level unkeyed fragments as if they were arrays.</span></span><br><span class="line">    <span class="comment">// This leads to an ambiguity between &lt;&gt;&#123;[...]&#125;&lt;/&gt; and &lt;&gt;...&lt;/&gt;.</span></span><br><span class="line">    <span class="comment">// We treat the ambiguous cases above the same.</span></span><br><span class="line">    <span class="keyword">const</span> isUnkeyedTopLevelFragment =</span><br><span class="line">      <span class="keyword">typeof</span> newChild === <span class="string">&quot;object&quot;</span> &amp;&amp;</span><br><span class="line">      newChild !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">      newChild.type === REACT_FRAGMENT_TYPE &amp;&amp;</span><br><span class="line">      newChild.key === <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isUnkeyedTopLevelFragment) &#123;</span><br><span class="line">      newChild = newChild.props.children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle object types</span></span><br><span class="line">    <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> newChild === <span class="string">&quot;object&quot;</span> &amp;&amp; newChild !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (newChild.$$typeof) &#123;</span><br><span class="line">        <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">          <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">            reconcileSingleElement(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              expirationTime</span><br><span class="line">            )</span><br><span class="line">          );</span><br><span class="line">        <span class="keyword">case</span> REACT_PORTAL_TYPE:</span><br><span class="line">          <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">            reconcileSinglePortal(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              expirationTime</span><br><span class="line">            )</span><br><span class="line">          );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&quot;string&quot;</span> || <span class="keyword">typeof</span> newChild === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">        reconcileSingleTextNode(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          <span class="string">&quot;&quot;</span> + newChild,</span><br><span class="line">          expirationTime</span><br><span class="line">        )</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  数组</span></span><br><span class="line">    <span class="keyword">if</span> (isArray(newChild)) &#123;</span><br><span class="line">      <span class="keyword">return</span> reconcileChildrenArray(</span><br><span class="line">        returnFiber,</span><br><span class="line">        currentFirstChild,</span><br><span class="line">        newChild,</span><br><span class="line">        expirationTime</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getIteratorFn(newChild)) &#123;</span><br><span class="line">      <span class="keyword">return</span> reconcileChildrenIterator(</span><br><span class="line">        returnFiber,</span><br><span class="line">        currentFirstChild,</span><br><span class="line">        newChild,</span><br><span class="line">        expirationTime</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">      throwOnInvalidObjectType(returnFiber, newChild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Remaining cases are all treated as empty.</span></span><br><span class="line">    <span class="keyword">return</span> deleteRemainingChildren(returnFiber, currentFirstChild);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> reconcileChildFibers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ClassComponent"><a href="#ClassComponent" class="headerlink" title="ClassComponent"></a>ClassComponent</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberBeginWork.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateClassComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Push context providers early to prevent context stack mismatches.</span></span><br><span class="line">  <span class="comment">// During mounting we don&#x27;t know the child context yet as the instance doesn&#x27;t exist.</span></span><br><span class="line">  <span class="comment">// We will invalidate the child context in finishClassComponent() right after rendering.</span></span><br><span class="line">  <span class="keyword">let</span> hasContext;</span><br><span class="line">  <span class="keyword">if</span> (isLegacyContextProvider(Component)) &#123;</span><br><span class="line">    hasContext = <span class="literal">true</span>;</span><br><span class="line">    pushLegacyContextProvider(workInProgress);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    hasContext = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  prepareToReadContext(workInProgress, renderExpirationTime);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line">  <span class="keyword">let</span> shouldUpdate;</span><br><span class="line">  <span class="keyword">if</span> (instance === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// An class component without an instance only mounts if it suspended</span></span><br><span class="line">      <span class="comment">// inside a non- concurrent tree, in an inconsistent state. We want to</span></span><br><span class="line">      <span class="comment">// tree it like a new mount, even though an empty version of it already</span></span><br><span class="line">      <span class="comment">// committed. Disconnect the alternate pointers.</span></span><br><span class="line">      current.alternate = <span class="literal">null</span>;</span><br><span class="line">      workInProgress.alternate = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// Since this is conceptually a new fiber, schedule a Placement effect</span></span><br><span class="line">      workInProgress.effectTag |= Placement;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// In the initial pass we might need to construct the instance.</span></span><br><span class="line">    constructClassInstance(</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      nextProps,</span><br><span class="line">      renderExpirationTime</span><br><span class="line">    );</span><br><span class="line">    mountClassInstance(</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      nextProps,</span><br><span class="line">      renderExpirationTime</span><br><span class="line">    );</span><br><span class="line">    shouldUpdate = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// In a resume, we&#x27;ll already have an instance we can reuse.</span></span><br><span class="line">    shouldUpdate = resumeMountClassInstance(</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      nextProps,</span><br><span class="line">      renderExpirationTime</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    shouldUpdate = updateClassInstance(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      nextProps,</span><br><span class="line">      renderExpirationTime</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> nextUnitOfWork = finishClassComponent(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    shouldUpdate,</span><br><span class="line">    hasContext,</span><br><span class="line">    renderExpirationTime</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> nextUnitOfWork;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberClassComponent.js</span></span><br></pre></td></tr></table></figure>

<h3 id="IndeterminateComponent"><a href="#IndeterminateComponent" class="headerlink" title="IndeterminateComponent"></a>IndeterminateComponent</h3><ul>
<li>FunctionComponent 首次渲染初始化的时候就是 IndeterminateComponent</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountIndeterminateComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  _current,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// An indeterminate component only mounts if it suspended inside a non-</span></span><br><span class="line">    <span class="comment">// concurrent tree, in an inconsistent state. We want to treat it like</span></span><br><span class="line">    <span class="comment">// a new mount, even though an empty version of it already committed.</span></span><br><span class="line">    <span class="comment">// Disconnect the alternate pointers.</span></span><br><span class="line">    _current.alternate = <span class="literal">null</span>;</span><br><span class="line">    workInProgress.alternate = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// Since this is conceptually a new fiber, schedule a Placement effect</span></span><br><span class="line">    workInProgress.effectTag |= Placement;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> props = workInProgress.pendingProps;</span><br><span class="line">  <span class="keyword">const</span> unmaskedContext = getUnmaskedContext(workInProgress, Component, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> context = getMaskedContext(workInProgress, unmaskedContext);</span><br><span class="line"></span><br><span class="line">  prepareToReadContext(workInProgress, renderExpirationTime);</span><br><span class="line">  prepareToUseHooks(<span class="literal">null</span>, workInProgress, renderExpirationTime);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> value = Component(props, context);</span><br><span class="line">  <span class="comment">// React DevTools reads this flag.</span></span><br><span class="line">  workInProgress.effectTag |= PerformedWork;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="comment">// 此条件下面会举个列子</span></span><br><span class="line">    <span class="keyword">typeof</span> value === <span class="string">&quot;object&quot;</span> &amp;&amp;</span><br><span class="line">    value !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> value.render === <span class="string">&quot;function&quot;</span> &amp;&amp;</span><br><span class="line">    value.$$typeof === <span class="literal">undefined</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// Proceed under the assumption that this is a class instance</span></span><br><span class="line">    workInProgress.tag = ClassComponent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Throw out any hooks that were used.</span></span><br><span class="line">    resetHooks();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Push context providers early to prevent context stack mismatches.</span></span><br><span class="line">    <span class="comment">// During mounting we don&#x27;t know the child context yet as the instance doesn&#x27;t exist.</span></span><br><span class="line">    <span class="comment">// We will invalidate the child context in finishClassComponent() right after rendering.</span></span><br><span class="line">    <span class="keyword">let</span> hasContext = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (isLegacyContextProvider(Component)) &#123;</span><br><span class="line">      hasContext = <span class="literal">true</span>;</span><br><span class="line">      pushLegacyContextProvider(workInProgress);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      hasContext = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    workInProgress.memoizedState =</span><br><span class="line">      value.state !== <span class="literal">null</span> &amp;&amp; value.state !== <span class="literal">undefined</span> ? value.state : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> getDerivedStateFromProps = Component.getDerivedStateFromProps;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> getDerivedStateFromProps === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      applyDerivedStateFromProps(</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        getDerivedStateFromProps,</span><br><span class="line">        props</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    adoptClassInstance(workInProgress, value);</span><br><span class="line">    mountClassInstance(workInProgress, Component, props, renderExpirationTime);</span><br><span class="line">    <span class="keyword">return</span> finishClassComponent(</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      <span class="literal">true</span>,</span><br><span class="line">      hasContext,</span><br><span class="line">      renderExpirationTime</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Proceed under the assumption that this is a function component</span></span><br><span class="line">    workInProgress.tag = FunctionComponent;</span><br><span class="line">    value = finishHooks(Component, props, value, context);</span><br><span class="line">    reconcileChildren(<span class="literal">null</span>, workInProgress, value, renderExpirationTime);</span><br><span class="line">    <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 举例Demo</span></span><br><span class="line"><span class="comment">// 说明此时`let value = Component(props, context);`得到的结果会进入下面的if最终</span></span><br><span class="line"><span class="comment">// `workInProgress.tag = ClassComponent;` 即被认为是ClassComponent</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">IndeterminateComponentDemo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这样写就会报错，既然是ClassComponent了</span></span><br><span class="line">  <span class="comment">// useEffect(() =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(&quot;useEffect invoked&quot;);</span></span><br><span class="line">  <span class="comment">//   return () =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//     console.log(&quot;useEffect cleanup&quot;);</span></span><br><span class="line">  <span class="comment">//   &#125;;</span></span><br><span class="line">  <span class="comment">// &#125;, []);</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;componentDidMount invoked&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>IndeterminateComponentDemo<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HostRoot-的更新"><a href="#HostRoot-的更新" class="headerlink" title="HostRoot 的更新"></a>HostRoot 的更新</h3><h3 id="HostComponent-和-HostText-的更新"><a href="#HostComponent-和-HostText-的更新" class="headerlink" title="HostComponent 和 HostText 的更新"></a>HostComponent 和 HostText 的更新</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberBeginWork.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">current, workInProgress, renderExpirationTime</span>) </span>&#123;</span><br><span class="line">  pushHostContext(workInProgress); <span class="comment">// 为什么原生节点需要context</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    tryToClaimNextHydratableInstance(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line">  <span class="keyword">const</span> nextProps = workInProgress.pendingProps;</span><br><span class="line">  <span class="keyword">const</span> prevProps = current !== <span class="literal">null</span> ? current.memoizedProps : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> nextChildren = nextProps.children;</span><br><span class="line">  <span class="keyword">const</span> isDirectTextChild = shouldSetTextContent(type, nextProps);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isDirectTextChild) &#123;</span><br><span class="line">    <span class="comment">// We special case a direct text child of a host node. This is a common</span></span><br><span class="line">    <span class="comment">// case. We won&#x27;t handle it as a reified child. We will instead handle</span></span><br><span class="line">    <span class="comment">// this in the host environment that also have access to this prop. That</span></span><br><span class="line">    <span class="comment">// avoids allocating another HostText fiber and traversing it.</span></span><br><span class="line">    nextChildren = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevProps !== <span class="literal">null</span> &amp;&amp; shouldSetTextContent(type, prevProps)) &#123;</span><br><span class="line">    <span class="comment">// If we&#x27;re switching from a direct text child to a normal child, or to</span></span><br><span class="line">    <span class="comment">// empty, we need to schedule the text content to be reset.</span></span><br><span class="line">    workInProgress.effectTag |= ContentReset;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  markRef(current, workInProgress);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check the host config to see if the children are offscreen/hidden.</span></span><br><span class="line">  <span class="comment">// 设置hidden意味着永远不会被更新</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    renderExpirationTime !== Never &amp;&amp;</span><br><span class="line">    workInProgress.mode &amp; ConcurrentMode &amp;&amp;</span><br><span class="line">    shouldDeprioritizeSubtree(type, nextProps)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// Schedule this fiber to re-render at offscreen priority. Then bailout.</span></span><br><span class="line">    workInProgress.expirationTime = Never;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reconcileChildren(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    nextChildren,</span><br><span class="line">    renderExpirationTime</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostText</span>(<span class="params">current, workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    tryToClaimNextHydratableInstance(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Nothing to do here. This is terminal. We&#x27;ll do the completion step</span></span><br><span class="line">  <span class="comment">// immediately after.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Portal-的更新"><a href="#Portal-的更新" class="headerlink" title="Portal 的更新"></a>Portal 的更新</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-dom\src\client\ReactDOM.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPortal</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  container: DOMContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: ?string = <span class="literal">null</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> pass ReactDOM portal implementation as third argument</span></span><br><span class="line">  <span class="keyword">return</span> createPortalImpl(children, container, <span class="literal">null</span>, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\shared\ReactPortal.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPortal</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  containerInfo: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// <span class="doctag">TODO:</span> figure out the API for cross-renderer implementation.</span></span></span></span><br><span class="line"><span class="function"><span class="params">  implementation: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: ?string = <span class="literal">null</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ReactPortal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// This tag allow us to uniquely identify this as a React Portal</span></span><br><span class="line">    $$typeof: REACT_PORTAL_TYPE,</span><br><span class="line">    key: key == <span class="literal">null</span> ? <span class="literal">null</span> : <span class="string">&quot;&quot;</span> + key,</span><br><span class="line">    children,</span><br><span class="line">    containerInfo,</span><br><span class="line">    implementation,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react-reconciler\src\ReactChildFiber.js</span></span><br><span class="line"><span class="comment">// reconcileSinglePortal</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberBeginWork.js</span></span><br><span class="line"><span class="comment">// updatePortalComponent</span></span><br></pre></td></tr></table></figure>

<h3 id="ForwardRef-的更新"><a href="#ForwardRef-的更新" class="headerlink" title="ForwardRef 的更新"></a>ForwardRef 的更新</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateForwardRef</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> render = Component.render;</span><br><span class="line">  <span class="keyword">const</span> ref = workInProgress.ref;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The rest is a fork of updateFunctionComponent</span></span><br><span class="line">  <span class="keyword">let</span> nextChildren;</span><br><span class="line">  prepareToReadContext(workInProgress, renderExpirationTime);</span><br><span class="line">  prepareToUseHooks(current, workInProgress, renderExpirationTime);</span><br><span class="line">  nextChildren = render(nextProps, ref);</span><br><span class="line">  nextChildren = finishHooks(render, nextProps, nextChildren, ref);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// React DevTools reads this flag.</span></span><br><span class="line">  workInProgress.effectTag |= PerformedWork;</span><br><span class="line">  reconcileChildren(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    nextChildren,</span><br><span class="line">    renderExpirationTime</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Memo-组件的更新"><a href="#Memo-组件的更新" class="headerlink" title="Memo 组件的更新"></a>Memo 组件的更新</h3><h2 id="更新完成-completeUnitOfWork"><a href="#更新完成-completeUnitOfWork" class="headerlink" title="更新完成 completeUnitOfWork"></a>更新完成 completeUnitOfWork</h2><ul>
<li><p>根据是否有中断调用不同的处理</p>
</li>
<li><p>判断是否有兄弟节点调用不同的处理</p>
</li>
<li><p>完成节点后赋值 effect 链</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberScheduler.js</span></span><br><span class="line"><span class="comment">// performUnitOfWork</span></span><br><span class="line"><span class="comment">//     beginWork</span></span><br><span class="line"><span class="comment">//     completeUnitOfWork</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeUnitOfWork</span>(<span class="params">workInProgress: Fiber</span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Attempt to complete the current unit of work, then move to the</span></span><br><span class="line">  <span class="comment">// next sibling. If there are no more siblings, return to the</span></span><br><span class="line">  <span class="comment">// parent fiber.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// The current, flushed, state of this fiber is the alternate.</span></span><br><span class="line">    <span class="comment">// Ideally nothing should rely on this, but relying on it here</span></span><br><span class="line">    <span class="comment">// means that we don&#x27;t need an additional field on the work in</span></span><br><span class="line">    <span class="comment">// progress.</span></span><br><span class="line">    <span class="keyword">const</span> current = workInProgress.alternate;</span><br><span class="line">    <span class="keyword">const</span> returnFiber = workInProgress.return;</span><br><span class="line">    <span class="keyword">const</span> siblingFiber = workInProgress.sibling;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((workInProgress.effectTag &amp; Incomplete) === NoEffect) &#123;</span><br><span class="line">      <span class="comment">// This fiber completed.</span></span><br><span class="line">      <span class="comment">// Remember we&#x27;re completing this unit so we can find a boundary if it fails.</span></span><br><span class="line">      nextUnitOfWork = workInProgress;</span><br><span class="line">      <span class="keyword">if</span> (enableProfilerTimer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (workInProgress.mode &amp; ProfileMode) &#123;</span><br><span class="line">          startProfilerTimer(workInProgress);</span><br><span class="line">        &#125;</span><br><span class="line">        nextUnitOfWork = completeWork(</span><br><span class="line">          current,</span><br><span class="line">          workInProgress,</span><br><span class="line">          nextRenderExpirationTime</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (workInProgress.mode &amp; ProfileMode) &#123;</span><br><span class="line">          <span class="comment">// Update render duration assuming we didn&#x27;t error.</span></span><br><span class="line">          stopProfilerTimerIfRunningAndRecordDelta(workInProgress, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nextUnitOfWork = completeWork(</span><br><span class="line">          current,</span><br><span class="line">          workInProgress,</span><br><span class="line">          nextRenderExpirationTime</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      stopWorkTimer(workInProgress);</span><br><span class="line">      resetChildExpirationTime(workInProgress, nextRenderExpirationTime);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Completing this fiber spawned new work. Work on that next.</span></span><br><span class="line">        <span class="keyword">return</span> nextUnitOfWork;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        returnFiber !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// Do not append effects to parents if a sibling failed to complete</span></span><br><span class="line">        (returnFiber.effectTag &amp; Incomplete) === NoEffect</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// Append all the effects of the subtree and this fiber onto the effect</span></span><br><span class="line">        <span class="comment">// list of the parent. The completion order of the children affects the</span></span><br><span class="line">        <span class="comment">// side-effect order.</span></span><br><span class="line">        <span class="keyword">if</span> (returnFiber.firstEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">          returnFiber.firstEffect = workInProgress.firstEffect;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (workInProgress.lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (returnFiber.lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;</span><br><span class="line">          &#125;</span><br><span class="line">          returnFiber.lastEffect = workInProgress.lastEffect;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this fiber had side-effects, we append it AFTER the children&#x27;s</span></span><br><span class="line">        <span class="comment">// side-effects. We can perform certain side-effects earlier if</span></span><br><span class="line">        <span class="comment">// needed, by doing multiple passes over the effect list. We don&#x27;t want</span></span><br><span class="line">        <span class="comment">// to schedule our own side-effect on our own list because if end up</span></span><br><span class="line">        <span class="comment">// reusing children we&#x27;ll schedule this effect onto itself since we&#x27;re</span></span><br><span class="line">        <span class="comment">// at the end.</span></span><br><span class="line">        <span class="keyword">const</span> effectTag = workInProgress.effectTag;</span><br><span class="line">        <span class="comment">// Skip both NoWork and PerformedWork tags when creating the effect list.</span></span><br><span class="line">        <span class="comment">// PerformedWork effect is read by React DevTools but shouldn&#x27;t be committed.</span></span><br><span class="line">        <span class="keyword">if</span> (effectTag &gt; PerformedWork) &#123;</span><br><span class="line">          <span class="keyword">if</span> (returnFiber.lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">            returnFiber.lastEffect.nextEffect = workInProgress;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            returnFiber.firstEffect = workInProgress;</span><br><span class="line">          &#125;</span><br><span class="line">          returnFiber.lastEffect = workInProgress;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (siblingFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If there is more work to do in this returnFiber, do that next.</span></span><br><span class="line">        <span class="keyword">return</span> siblingFiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If there&#x27;s no more work in this returnFiber. Complete the returnFiber.</span></span><br><span class="line">        workInProgress = returnFiber;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We&#x27;ve reached the root.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; workInProgress.mode &amp; ProfileMode) &#123;</span><br><span class="line">        <span class="comment">// Record the render duration for the fiber that errored.</span></span><br><span class="line">        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Include the time spent working on failed children before continuing.</span></span><br><span class="line">        <span class="keyword">let</span> actualDuration = workInProgress.actualDuration;</span><br><span class="line">        <span class="keyword">let</span> child = workInProgress.child;</span><br><span class="line">        <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">          actualDuration += child.actualDuration;</span><br><span class="line">          child = child.sibling;</span><br><span class="line">        &#125;</span><br><span class="line">        workInProgress.actualDuration = actualDuration;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// This fiber did not complete because something threw. Pop values off</span></span><br><span class="line">      <span class="comment">// the stack without entering the complete phase. If this is a boundary,</span></span><br><span class="line">      <span class="comment">// capture values if possible.</span></span><br><span class="line">      <span class="keyword">const</span> next = unwindWork(workInProgress, nextRenderExpirationTime);</span><br><span class="line">      <span class="comment">// Because this fiber did not complete, don&#x27;t reset its expiration time.</span></span><br><span class="line">      <span class="keyword">if</span> (workInProgress.effectTag &amp; DidCapture) &#123;</span><br><span class="line">        <span class="comment">// Restarting an error boundary</span></span><br><span class="line">        stopFailedWorkTimer(workInProgress);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stopWorkTimer(workInProgress);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (next !== <span class="literal">null</span>) &#123;</span><br><span class="line">        stopWorkTimer(workInProgress);</span><br><span class="line">        <span class="keyword">if</span> (__DEV__ &amp;&amp; ReactFiberInstrumentation.debugTool) &#123;</span><br><span class="line">          ReactFiberInstrumentation.debugTool.onCompleteWork(workInProgress);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If completing this work spawned new work, do that next. We&#x27;ll come</span></span><br><span class="line">        <span class="comment">// back here again.</span></span><br><span class="line">        <span class="comment">// Since we&#x27;re restarting, remove anything that is not a host effect</span></span><br><span class="line">        <span class="comment">// from the effect tag.</span></span><br><span class="line">        next.effectTag &amp;= HostEffectMask;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (returnFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Mark the parent fiber as incomplete and clear its effect list.</span></span><br><span class="line">        returnFiber.firstEffect = returnFiber.lastEffect = <span class="literal">null</span>;</span><br><span class="line">        returnFiber.effectTag |= Incomplete;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (siblingFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If there is more work to do in this returnFiber, do that next.</span></span><br><span class="line">        <span class="keyword">return</span> siblingFiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If there&#x27;s no more work in this returnFiber. Complete the returnFiber.</span></span><br><span class="line">        workInProgress = returnFiber;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Without this explicit null return Flow complains of invalid return type</span></span><br><span class="line">  <span class="comment">// TODO Remove the above while(true) loop</span></span><br><span class="line">  <span class="comment">// eslint-disable-next-line no-unreachable</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重设-childExpirationTime"><a href="#重设-childExpirationTime" class="headerlink" title="重设 childExpirationTime"></a>重设 childExpirationTime</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetChildExpirationTime</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (renderTime !== Never &amp;&amp; workInProgress.childExpirationTime === Never) &#123;</span><br><span class="line">    <span class="comment">// The children of this component are hidden. Don&#x27;t bubble their</span></span><br><span class="line">    <span class="comment">// expiration times.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newChildExpirationTime = NoWork;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Bubble up the earliest expiration time.</span></span><br><span class="line">  <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; workInProgress.mode &amp; ProfileMode) &#123;</span><br><span class="line">    <span class="comment">// We&#x27;re in profiling mode.</span></span><br><span class="line">    <span class="comment">// Let&#x27;s use this same traversal to update the render durations.</span></span><br><span class="line">    <span class="keyword">let</span> actualDuration = workInProgress.actualDuration;</span><br><span class="line">    <span class="keyword">let</span> treeBaseDuration = workInProgress.selfBaseDuration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When a fiber is cloned, its actualDuration is reset to 0.</span></span><br><span class="line">    <span class="comment">// This value will only be updated if work is done on the fiber (i.e. it doesn&#x27;t bailout).</span></span><br><span class="line">    <span class="comment">// When work is done, it should bubble to the parent&#x27;s actualDuration.</span></span><br><span class="line">    <span class="comment">// If the fiber has not been cloned though, (meaning no work was done),</span></span><br><span class="line">    <span class="comment">// Then this value will reflect the amount of time spent working on a previous render.</span></span><br><span class="line">    <span class="comment">// In that case it should not bubble.</span></span><br><span class="line">    <span class="comment">// We determine whether it was cloned by comparing the child pointer.</span></span><br><span class="line">    <span class="keyword">const</span> shouldBubbleActualDurations =</span><br><span class="line">      workInProgress.alternate === <span class="literal">null</span> ||</span><br><span class="line">      workInProgress.child !== workInProgress.alternate.child;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> child = workInProgress.child;</span><br><span class="line">    <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> childUpdateExpirationTime = child.expirationTime;</span><br><span class="line">      <span class="keyword">const</span> childChildExpirationTime = child.childExpirationTime;</span><br><span class="line">      <span class="keyword">if</span> (childUpdateExpirationTime &gt; newChildExpirationTime) &#123;</span><br><span class="line">        newChildExpirationTime = childUpdateExpirationTime;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (childChildExpirationTime &gt; newChildExpirationTime) &#123;</span><br><span class="line">        newChildExpirationTime = childChildExpirationTime;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (shouldBubbleActualDurations) &#123;</span><br><span class="line">        actualDuration += child.actualDuration;</span><br><span class="line">      &#125;</span><br><span class="line">      treeBaseDuration += child.treeBaseDuration;</span><br><span class="line">      child = child.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    workInProgress.actualDuration = actualDuration;</span><br><span class="line">    workInProgress.treeBaseDuration = treeBaseDuration;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> child = workInProgress.child;</span><br><span class="line">    <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> childUpdateExpirationTime = child.expirationTime;</span><br><span class="line">      <span class="keyword">const</span> childChildExpirationTime = child.childExpirationTime;</span><br><span class="line">      <span class="keyword">if</span> (childUpdateExpirationTime &gt; newChildExpirationTime) &#123;</span><br><span class="line">        newChildExpirationTime = childUpdateExpirationTime;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (childChildExpirationTime &gt; newChildExpirationTime) &#123;</span><br><span class="line">        newChildExpirationTime = childChildExpirationTime;</span><br><span class="line">      &#125;</span><br><span class="line">      child = child.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  workInProgress.childExpirationTime = newChildExpirationTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="completeWork"><a href="#completeWork" class="headerlink" title="completeWork"></a>completeWork</h3><ul>
<li><p>pop 各种 context 相关内容</p>
</li>
<li><p>对 HostComponent 执行初始化</p>
</li>
<li><p>初始化监听事件</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LazyComponent:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent:</span><br><span class="line">    <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">if</span> (isLegacyContextProvider(Component)) &#123;</span><br><span class="line">        popLegacyContext(workInProgress);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostRoot: &#123;</span><br><span class="line">      popHostContainer(workInProgress);</span><br><span class="line">      popTopLevelLegacyContextObject(workInProgress);</span><br><span class="line">      <span class="keyword">const</span> fiberRoot = (workInProgress.stateNode: FiberRoot);</span><br><span class="line">      <span class="keyword">if</span> (fiberRoot.pendingContext) &#123;</span><br><span class="line">        fiberRoot.context = fiberRoot.pendingContext;</span><br><span class="line">        fiberRoot.pendingContext = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (current === <span class="literal">null</span> || current.child === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If we hydrated, pop so that we can delete any remaining children</span></span><br><span class="line">        <span class="comment">// that weren&#x27;t hydrated.</span></span><br><span class="line">        popHydrationState(workInProgress);</span><br><span class="line">        <span class="comment">// This resets the hacky state to fix isMounted before committing.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Delete this when we delete isMounted and findDOMNode.</span></span><br><span class="line">        workInProgress.effectTag &amp;= ~Placement;</span><br><span class="line">      &#125;</span><br><span class="line">      updateHostContainer(workInProgress);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">      popHostContext(workInProgress);</span><br><span class="line">      <span class="keyword">const</span> rootContainerInstance = getRootHostContainer();</span><br><span class="line">      <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line">      <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; workInProgress.stateNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        updateHostComponent(</span><br><span class="line">          current,</span><br><span class="line">          workInProgress,</span><br><span class="line">          type,</span><br><span class="line">          newProps,</span><br><span class="line">          rootContainerInstance</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current.ref !== workInProgress.ref) &#123;</span><br><span class="line">          markRef(workInProgress);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!newProps) &#123;</span><br><span class="line">          invariant(</span><br><span class="line">            workInProgress.stateNode !== <span class="literal">null</span>,</span><br><span class="line">            <span class="string">&quot;We must have new props for new mounts. This error is likely &quot;</span> +</span><br><span class="line">              <span class="string">&quot;caused by a bug in React. Please file an issue.&quot;</span></span><br><span class="line">          );</span><br><span class="line">          <span class="comment">// This can happen when we abort work.</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> currentHostContext = getHostContext();</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Move createInstance to beginWork and keep it on a context</span></span><br><span class="line">        <span class="comment">// &quot;stack&quot; as the parent. Then append children as we go in beginWork</span></span><br><span class="line">        <span class="comment">// or completeWork depending on we want to add then top-&gt;down or</span></span><br><span class="line">        <span class="comment">// bottom-&gt;up. Top-&gt;down is faster in IE11.</span></span><br><span class="line">        <span class="keyword">let</span> wasHydrated = popHydrationState(workInProgress);</span><br><span class="line">        <span class="keyword">if</span> (wasHydrated) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> Move this and createInstance step into the beginPhase</span></span><br><span class="line">          <span class="comment">// to consolidate.</span></span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            prepareToHydrateHostInstance(</span><br><span class="line">              workInProgress,</span><br><span class="line">              rootContainerInstance,</span><br><span class="line">              currentHostContext</span><br><span class="line">            )</span><br><span class="line">          ) &#123;</span><br><span class="line">            <span class="comment">// If changes to the hydrated node needs to be applied at the</span></span><br><span class="line">            <span class="comment">// commit-phase we mark this as such.</span></span><br><span class="line">            markUpdate(workInProgress);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> instance = createInstance(</span><br><span class="line">            <span class="comment">// createElement</span></span><br><span class="line">            type,</span><br><span class="line">            newProps,</span><br><span class="line">            rootContainerInstance,</span><br><span class="line">            currentHostContext,</span><br><span class="line">            workInProgress</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">          appendAllChildren(instance, workInProgress, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Certain renderers require commit-time effects for initial mount.</span></span><br><span class="line">          <span class="comment">// (eg DOM renderer supports auto-focus for certain elements).</span></span><br><span class="line">          <span class="comment">// Make sure such renderers get scheduled for later work.</span></span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            finalizeInitialChildren(</span><br><span class="line">              instance,</span><br><span class="line">              type,</span><br><span class="line">              newProps,</span><br><span class="line">              rootContainerInstance,</span><br><span class="line">              currentHostContext</span><br><span class="line">            )</span><br><span class="line">          ) &#123;</span><br><span class="line">            markUpdate(workInProgress);</span><br><span class="line">          &#125;</span><br><span class="line">          workInProgress.stateNode = instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (workInProgress.ref !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// If there is a ref on a host node we need to schedule a callback</span></span><br><span class="line">          markRef(workInProgress);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostText: &#123;</span><br><span class="line">      <span class="keyword">let</span> newText = newProps;</span><br><span class="line">      <span class="keyword">if</span> (current &amp;&amp; workInProgress.stateNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> oldText = current.memoizedProps;</span><br><span class="line">        <span class="comment">// If we have an alternate, that means this is an update and we need</span></span><br><span class="line">        <span class="comment">// to schedule a side-effect to do the updates.</span></span><br><span class="line">        updateHostText(current, workInProgress, oldText, newText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> newText !== <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">          invariant(</span><br><span class="line">            workInProgress.stateNode !== <span class="literal">null</span>,</span><br><span class="line">            <span class="string">&quot;We must have new props for new mounts. This error is likely &quot;</span> +</span><br><span class="line">              <span class="string">&quot;caused by a bug in React. Please file an issue.&quot;</span></span><br><span class="line">          );</span><br><span class="line">          <span class="comment">// This can happen when we abort work.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> rootContainerInstance = getRootHostContainer();</span><br><span class="line">        <span class="keyword">const</span> currentHostContext = getHostContext();</span><br><span class="line">        <span class="keyword">let</span> wasHydrated = popHydrationState(workInProgress);</span><br><span class="line">        <span class="keyword">if</span> (wasHydrated) &#123;</span><br><span class="line">          <span class="keyword">if</span> (prepareToHydrateHostTextInstance(workInProgress)) &#123;</span><br><span class="line">            markUpdate(workInProgress);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          workInProgress.stateNode = createTextInstance(</span><br><span class="line">            newText,</span><br><span class="line">            rootContainerInstance,</span><br><span class="line">            currentHostContext,</span><br><span class="line">            workInProgress</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ForwardRef:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SuspenseComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> nextState = workInProgress.memoizedState;</span><br><span class="line">      <span class="keyword">if</span> ((workInProgress.effectTag &amp; DidCapture) !== NoEffect) &#123;</span><br><span class="line">        <span class="comment">// Something suspended. Re-render with the fallback children.</span></span><br><span class="line">        workInProgress.expirationTime = renderExpirationTime;</span><br><span class="line">        <span class="comment">// Do not reset the effect list.</span></span><br><span class="line">        <span class="keyword">return</span> workInProgress;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> nextDidTimeout = nextState !== <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">const</span> prevDidTimeout = current !== <span class="literal">null</span> &amp;&amp; current.memoizedState !== <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; !nextDidTimeout &amp;&amp; prevDidTimeout) &#123;</span><br><span class="line">        <span class="comment">// We just switched from the fallback to the normal children. Delete</span></span><br><span class="line">        <span class="comment">// the fallback.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Would it be better to store the fallback fragment on</span></span><br><span class="line">        <span class="comment">// the stateNode during the begin phase?</span></span><br><span class="line">        <span class="keyword">const</span> currentFallbackChild: Fiber | <span class="literal">null</span> = (current.child: any).sibling;</span><br><span class="line">        <span class="keyword">if</span> (currentFallbackChild !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// Deletions go at the beginning of the return fiber&#x27;s effect list</span></span><br><span class="line">          <span class="keyword">const</span> first = workInProgress.firstEffect;</span><br><span class="line">          <span class="keyword">if</span> (first !== <span class="literal">null</span>) &#123;</span><br><span class="line">            workInProgress.firstEffect = currentFallbackChild;</span><br><span class="line">            currentFallbackChild.nextEffect = first;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            workInProgress.firstEffect = workInProgress.lastEffect =</span><br><span class="line">              currentFallbackChild;</span><br><span class="line">            currentFallbackChild.nextEffect = <span class="literal">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          currentFallbackChild.effectTag = Deletion;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The children either timed out after previously being visible, or</span></span><br><span class="line">      <span class="comment">// were restored after previously being hidden. Schedule an effect</span></span><br><span class="line">      <span class="comment">// to update their visiblity.</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        nextDidTimeout !== prevDidTimeout ||</span><br><span class="line">        <span class="comment">// Outside concurrent mode, the primary children commit in an</span></span><br><span class="line">        <span class="comment">// inconsistent state, even if they are hidden. So if they are hidden,</span></span><br><span class="line">        <span class="comment">// we need to schedule an effect to re-hide them, just in case.</span></span><br><span class="line">        ((workInProgress.effectTag &amp; ConcurrentMode) === NoContext &amp;&amp;</span><br><span class="line">          nextDidTimeout)</span><br><span class="line">      ) &#123;</span><br><span class="line">        workInProgress.effectTag |= Update;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Fragment:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Mode:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Profiler:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HostPortal:</span><br><span class="line">      popHostContainer(workInProgress);</span><br><span class="line">      updateHostContainer(workInProgress);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ContextProvider:</span><br><span class="line">      <span class="comment">// Pop provider fiber</span></span><br><span class="line">      popProvider(workInProgress);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ContextConsumer:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MemoComponent:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IncompleteClassComponent: &#123;</span><br><span class="line">      <span class="comment">// Same as class component case. I put it down here so that the tags are</span></span><br><span class="line">      <span class="comment">// sequential to ensure this switch is compiled to a jump table.</span></span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">if</span> (isLegacyContextProvider(Component)) &#123;</span><br><span class="line">        popLegacyContext(workInProgress);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      invariant(</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Unknown unit of work tag. This error is likely caused by a bug in &quot;</span> +</span><br><span class="line">          <span class="string">&quot;React. Please file an issue.&quot;</span></span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重要的也就HostComponent，HostText和SuspenseComponent</span></span><br></pre></td></tr></table></figure>

<h3 id="初次渲染中-completeWork-对于-DOM-节点的创建和-appendAllChil"><a href="#初次渲染中-completeWork-对于-DOM-节点的创建和-appendAllChil" class="headerlink" title="初次渲染中 completeWork 对于 DOM 节点的创建和 appendAllChil"></a>初次渲染中 completeWork 对于 DOM 节点的创建和 appendAllChil</h3><ul>
<li><p>diff properties 计算需要更新的内容</p>
</li>
<li><p>不同 dom properties 处理不同</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberCompleteWork.js</span></span><br><span class="line"><span class="keyword">let</span> appendAllChildren;</span><br><span class="line"><span class="keyword">let</span> updateHostContainer;</span><br><span class="line"><span class="keyword">let</span> updateHostComponent;</span><br><span class="line"><span class="keyword">let</span> updateHostText;</span><br><span class="line"><span class="keyword">if</span> (supportsMutation) &#123;</span><br><span class="line">  <span class="comment">// Mutation mode</span></span><br><span class="line"></span><br><span class="line">  appendAllChildren = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    parent: Instance,</span></span></span><br><span class="line"><span class="function"><span class="params">    workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    needsVisibilityToggle: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">    isHidden: boolean</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="comment">// We only have the top Fiber that was created but we need recurse down its</span></span><br><span class="line">    <span class="comment">// children to find all the terminal nodes.</span></span><br><span class="line">    <span class="keyword">let</span> node = workInProgress.child;</span><br><span class="line">    <span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.tag === HostComponent || node.tag === HostText) &#123;</span><br><span class="line">        <span class="comment">// 找到第一层HostComponent并执行appendChild, 并不会嵌套appendChild</span></span><br><span class="line">        appendInitialChild(parent, node.stateNode);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.tag === HostPortal) &#123;</span><br><span class="line">        <span class="comment">// If we have a portal child, then we don&#x27;t want to traverse</span></span><br><span class="line">        <span class="comment">// down its children. Instead, we&#x27;ll get insertions from each child in</span></span><br><span class="line">        <span class="comment">// the portal directly.</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        node.child.return = node;</span><br><span class="line">        node = node.child;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node === workInProgress) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (node.sibling === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.return === <span class="literal">null</span> || node.return === workInProgress) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.return; <span class="comment">// 向上查找</span></span><br><span class="line">      &#125;</span><br><span class="line">      node.sibling.return = node.return;</span><br><span class="line">      node = node.sibling; <span class="comment">// 兄弟节点之间</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  updateHostContainer = <span class="function"><span class="keyword">function</span> (<span class="params">workInProgress: Fiber</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Noop</span></span><br><span class="line">  &#125;;</span><br><span class="line">  updateHostComponent = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    current: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    type: Type,</span></span></span><br><span class="line"><span class="function"><span class="params">    newProps: Props,</span></span></span><br><span class="line"><span class="function"><span class="params">    rootContainerInstance: Container</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="comment">// If we have an alternate, that means this is an update and we need to</span></span><br><span class="line">    <span class="comment">// schedule a side-effect to do the updates.</span></span><br><span class="line">    <span class="keyword">const</span> oldProps = current.memoizedProps;</span><br><span class="line">    <span class="keyword">if</span> (oldProps === newProps) &#123;</span><br><span class="line">      <span class="comment">// In mutation mode, this is sufficient for a bailout because</span></span><br><span class="line">      <span class="comment">// we won&#x27;t touch this node even if children changed.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we get updated because one of our children updated, we don&#x27;t</span></span><br><span class="line">    <span class="comment">// have newProps so we&#x27;ll have to reuse them.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Split the update API as separate for the props vs. children.</span></span><br><span class="line">    <span class="comment">// Even better would be if children weren&#x27;t special cased at all tho.</span></span><br><span class="line">    <span class="keyword">const</span> instance: Instance = workInProgress.stateNode;</span><br><span class="line">    <span class="keyword">const</span> currentHostContext = getHostContext();</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Experiencing an error where oldProps is null. Suggests a host</span></span><br><span class="line">    <span class="comment">// component is hitting the resume path. Figure out why. Possibly</span></span><br><span class="line">    <span class="comment">// related to `hidden`.</span></span><br><span class="line">    <span class="keyword">const</span> updatePayload = prepareUpdate(</span><br><span class="line">      instance,</span><br><span class="line">      type,</span><br><span class="line">      oldProps,</span><br><span class="line">      newProps,</span><br><span class="line">      rootContainerInstance,</span><br><span class="line">      currentHostContext</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Type this specific to this type of component.</span></span><br><span class="line">    workInProgress.updateQueue = (updatePayload: any);</span><br><span class="line">    <span class="comment">// If the update payload indicates that there is a change or if there</span></span><br><span class="line">    <span class="comment">// is a new ref we mark this as an update. All the work is done in commitWork.</span></span><br><span class="line">    <span class="keyword">if</span> (updatePayload) &#123;</span><br><span class="line">      markUpdate(workInProgress);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  updateHostText = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    current: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    oldText: string,</span></span></span><br><span class="line"><span class="function"><span class="params">    newText: string</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="comment">// If the text differs, mark it as an update. All the work in done in commitWork.</span></span><br><span class="line">    <span class="keyword">if</span> (oldText !== newText) &#123;</span><br><span class="line">      markUpdate(workInProgress);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (supportsPersistence) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新-DOM-时进行的-diff-判断"><a href="#更新-DOM-时进行的-diff-判断" class="headerlink" title="更新 DOM 时进行的 diff 判断"></a>更新 DOM 时进行的 diff 判断</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-dom\src\client\ReactDOMHostConfig.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">prepareUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  domElement: Instance,</span></span></span><br><span class="line"><span class="function"><span class="params">  type: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldProps: Props,</span></span></span><br><span class="line"><span class="function"><span class="params">  newProps: Props,</span></span></span><br><span class="line"><span class="function"><span class="params">  rootContainerInstance: Container,</span></span></span><br><span class="line"><span class="function"><span class="params">  hostContext: HostContext</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">null</span> | <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> diffProperties(</span><br><span class="line">    domElement,</span><br><span class="line">    type,</span><br><span class="line">    oldProps,</span><br><span class="line">    newProps,</span><br><span class="line">    rootContainerInstance</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react-dom\src\client\ReactDOMComponent.js</span></span><br><span class="line"><span class="comment">// Calculate the diff between the two objects.</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diffProperties</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  domElement: Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  lastRawProps: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextRawProps: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  rootContainerElement: Element | Document</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">null</span> | <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> updatePayload: <span class="literal">null</span> | <span class="built_in">Array</span>&lt;any&gt; = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> lastProps: <span class="built_in">Object</span>;</span><br><span class="line">  <span class="keyword">let</span> nextProps: <span class="built_in">Object</span>;</span><br><span class="line">  <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;input&quot;</span>:</span><br><span class="line">      lastProps = ReactDOMInputGetHostProps(domElement, lastRawProps);</span><br><span class="line">      nextProps = ReactDOMInputGetHostProps(domElement, nextRawProps);</span><br><span class="line">      updatePayload = [];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;option&quot;</span>:</span><br><span class="line">      lastProps = ReactDOMOptionGetHostProps(domElement, lastRawProps);</span><br><span class="line">      nextProps = ReactDOMOptionGetHostProps(domElement, nextRawProps);</span><br><span class="line">      updatePayload = [];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;select&quot;</span>:</span><br><span class="line">      lastProps = ReactDOMSelectGetHostProps(domElement, lastRawProps);</span><br><span class="line">      nextProps = ReactDOMSelectGetHostProps(domElement, nextRawProps);</span><br><span class="line">      updatePayload = [];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;textarea&quot;</span>:</span><br><span class="line">      lastProps = ReactDOMTextareaGetHostProps(domElement, lastRawProps);</span><br><span class="line">      nextProps = ReactDOMTextareaGetHostProps(domElement, nextRawProps);</span><br><span class="line">      updatePayload = [];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      lastProps = lastRawProps;</span><br><span class="line">      nextProps = nextRawProps;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="keyword">typeof</span> lastProps.onClick !== <span class="string">&quot;function&quot;</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> nextProps.onClick === <span class="string">&quot;function&quot;</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> This cast may not be sound for SVG, MathML or custom elements.</span></span><br><span class="line">        trapClickOnNonInteractiveElement(((domElement: any): HTMLElement));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assertValidProps(tag, nextProps);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> propKey;</span><br><span class="line">  <span class="keyword">let</span> styleName;</span><br><span class="line">  <span class="keyword">let</span> styleUpdates = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (propKey <span class="keyword">in</span> lastProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      nextProps.hasOwnProperty(propKey) ||</span><br><span class="line">      !lastProps.hasOwnProperty(propKey) ||</span><br><span class="line">      lastProps[propKey] == <span class="literal">null</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (propKey === STYLE) &#123;</span><br><span class="line">      <span class="keyword">const</span> lastStyle = lastProps[propKey];</span><br><span class="line">      <span class="keyword">for</span> (styleName <span class="keyword">in</span> lastStyle) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastStyle.hasOwnProperty(styleName)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!styleUpdates) &#123;</span><br><span class="line">            styleUpdates = &#123;&#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          styleUpdates[styleName] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) &#123;</span><br><span class="line">      <span class="comment">// Noop. This is handled by the clear text mechanism.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      propKey === SUPPRESS_CONTENT_EDITABLE_WARNING ||</span><br><span class="line">      propKey === SUPPRESS_HYDRATION_WARNING</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// Noop</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === AUTOFOCUS) &#123;</span><br><span class="line">      <span class="comment">// Noop. It doesn&#x27;t work on updates anyway.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registrationNameModules.hasOwnProperty(propKey)) &#123;</span><br><span class="line">      <span class="comment">// This is a special case. If any listener updates we need to ensure</span></span><br><span class="line">      <span class="comment">// that the &quot;current&quot; fiber pointer gets updated so we need a commit</span></span><br><span class="line">      <span class="comment">// to update this element.</span></span><br><span class="line">      <span class="keyword">if</span> (!updatePayload) &#123;</span><br><span class="line">        updatePayload = [];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// For all other deleted properties we add it to the queue. We use</span></span><br><span class="line">      <span class="comment">// the whitelist in the commit phase instead.</span></span><br><span class="line">      (updatePayload = updatePayload || []).push(propKey, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (propKey <span class="keyword">in</span> nextProps) &#123;</span><br><span class="line">    <span class="keyword">const</span> nextProp = nextProps[propKey];</span><br><span class="line">    <span class="keyword">const</span> lastProp = lastProps != <span class="literal">null</span> ? lastProps[propKey] : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !nextProps.hasOwnProperty(propKey) ||</span><br><span class="line">      nextProp === lastProp ||</span><br><span class="line">      (nextProp == <span class="literal">null</span> &amp;&amp; lastProp == <span class="literal">null</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (propKey === STYLE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (lastProp) &#123;</span><br><span class="line">        <span class="comment">// Unset styles on `lastProp` but not on `nextProp`.</span></span><br><span class="line">        <span class="keyword">for</span> (styleName <span class="keyword">in</span> lastProp) &#123;</span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            lastProp.hasOwnProperty(styleName) &amp;&amp;</span><br><span class="line">            (!nextProp || !nextProp.hasOwnProperty(styleName))</span><br><span class="line">          ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!styleUpdates) &#123;</span><br><span class="line">              styleUpdates = &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            styleUpdates[styleName] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Update styles that changed since `lastProp`.</span></span><br><span class="line">        <span class="keyword">for</span> (styleName <span class="keyword">in</span> nextProp) &#123;</span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            nextProp.hasOwnProperty(styleName) &amp;&amp;</span><br><span class="line">            lastProp[styleName] !== nextProp[styleName]</span><br><span class="line">          ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!styleUpdates) &#123;</span><br><span class="line">              styleUpdates = &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            styleUpdates[styleName] = nextProp[styleName];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Relies on `updateStylesByID` not mutating `styleUpdates`.</span></span><br><span class="line">        <span class="keyword">if</span> (!styleUpdates) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!updatePayload) &#123;</span><br><span class="line">            updatePayload = [];</span><br><span class="line">          &#125;</span><br><span class="line">          updatePayload.push(propKey, styleUpdates);</span><br><span class="line">        &#125;</span><br><span class="line">        styleUpdates = nextProp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === DANGEROUSLY_SET_INNER_HTML) &#123;</span><br><span class="line">      <span class="keyword">const</span> nextHtml = nextProp ? nextProp[HTML] : <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">const</span> lastHtml = lastProp ? lastProp[HTML] : <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">if</span> (nextHtml != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastHtml !== nextHtml) &#123;</span><br><span class="line">          (updatePayload = updatePayload || []).push(propKey, <span class="string">&quot;&quot;</span> + nextHtml);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> It might be too late to clear this if we have children</span></span><br><span class="line">        <span class="comment">// inserted already.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === CHILDREN) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        lastProp !== nextProp &amp;&amp;</span><br><span class="line">        (<span class="keyword">typeof</span> nextProp === <span class="string">&quot;string&quot;</span> || <span class="keyword">typeof</span> nextProp === <span class="string">&quot;number&quot;</span>)</span><br><span class="line">      ) &#123;</span><br><span class="line">        (updatePayload = updatePayload || []).push(propKey, <span class="string">&quot;&quot;</span> + nextProp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      propKey === SUPPRESS_CONTENT_EDITABLE_WARNING ||</span><br><span class="line">      propKey === SUPPRESS_HYDRATION_WARNING</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// Noop</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registrationNameModules.hasOwnProperty(propKey)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nextProp != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We eagerly listen to this even though we haven&#x27;t committed yet.</span></span><br><span class="line">        ensureListeningTo(rootContainerElement, propKey);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!updatePayload &amp;&amp; lastProp !== nextProp) &#123;</span><br><span class="line">        <span class="comment">// This is a special case. If any listener updates we need to ensure</span></span><br><span class="line">        <span class="comment">// that the &quot;current&quot; props pointer gets updated so we need a commit</span></span><br><span class="line">        <span class="comment">// to update this element.</span></span><br><span class="line">        updatePayload = [];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// For any other property we always add it to the queue and then we</span></span><br><span class="line">      <span class="comment">// filter it out using the whitelist during the commit.</span></span><br><span class="line">      (updatePayload = updatePayload || []).push(propKey, nextProp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (styleUpdates) &#123;</span><br><span class="line">    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> updatePayload;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the diff.</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateProperties</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  domElement: Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  updatePayload: <span class="built_in">Array</span>&lt;any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  lastRawProps: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextRawProps: <span class="built_in">Object</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update checked *before* name.</span></span><br><span class="line">  <span class="comment">// In the middle of an update, it is possible to have multiple checked.</span></span><br><span class="line">  <span class="comment">// When a checked radio tries to change name, browser makes another radio&#x27;s checked false.</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    tag === <span class="string">&quot;input&quot;</span> &amp;&amp;</span><br><span class="line">    nextRawProps.type === <span class="string">&quot;radio&quot;</span> &amp;&amp;</span><br><span class="line">    nextRawProps.name != <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    ReactDOMInputUpdateChecked(domElement, nextRawProps);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> wasCustomComponentTag = isCustomComponent(tag, lastRawProps);</span><br><span class="line">  <span class="keyword">const</span> isCustomComponentTag = isCustomComponent(tag, nextRawProps);</span><br><span class="line">  <span class="comment">// Apply the diff.</span></span><br><span class="line">  updateDOMProperties(</span><br><span class="line">    domElement,</span><br><span class="line">    updatePayload,</span><br><span class="line">    wasCustomComponentTag,</span><br><span class="line">    isCustomComponentTag</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Ensure that an update gets scheduled if any of the special props</span></span><br><span class="line">  <span class="comment">// changed.</span></span><br><span class="line">  <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;input&quot;</span>:</span><br><span class="line">      <span class="comment">// Update the wrapper around inputs *after* updating props. This has to</span></span><br><span class="line">      <span class="comment">// happen after `updateDOMProperties`. Otherwise HTML5 input validations</span></span><br><span class="line">      <span class="comment">// raise warnings and prevent the new value from being assigned.</span></span><br><span class="line">      ReactDOMInputUpdateWrapper(domElement, nextRawProps);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;textarea&quot;</span>:</span><br><span class="line">      ReactDOMTextareaUpdateWrapper(domElement, nextRawProps);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;select&quot;</span>:</span><br><span class="line">      <span class="comment">// &lt;select&gt; value update needs to occur after &lt;option&gt; children</span></span><br><span class="line">      <span class="comment">// reconciliation</span></span><br><span class="line">      ReactDOMSelectPostUpdateWrapper(domElement, nextRawProps);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDOMProperties</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  domElement: Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  updatePayload: <span class="built_in">Array</span>&lt;any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  wasCustomComponentTag: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  isCustomComponentTag: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Handle wasCustomComponentTag</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; updatePayload.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> propKey = updatePayload[i];</span><br><span class="line">    <span class="keyword">const</span> propValue = updatePayload[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (propKey === STYLE) &#123;</span><br><span class="line">      setValueForStyles(domElement, propValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === DANGEROUSLY_SET_INNER_HTML) &#123;</span><br><span class="line">      setInnerHTML(domElement, propValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === CHILDREN) &#123;</span><br><span class="line">      setTextContent(domElement, propValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="completeWork-阶段对于-HostText-的更新"><a href="#completeWork-阶段对于-HostText-的更新" class="headerlink" title="completeWork 阶段对于 HostText 的更新"></a>completeWork 阶段对于 HostText 的更新</h3><h3 id="renderRoot-中对于错误的处理"><a href="#renderRoot-中对于错误的处理" class="headerlink" title="renderRoot 中对于错误的处理"></a>renderRoot 中对于错误的处理</h3><ul>
<li><p>给报错节点增加 InComplate 副作用</p>
</li>
<li><p>给父链上具有 error boundary 的节点增加副作用</p>
</li>
<li><p>创建错误相关的更新</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberScheduler.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// onUncaughtError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  throwException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  completeUnitOfWork  停止子节点渲染</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     thenable处理</span></span><br><span class="line"><span class="comment">//     renderDidError</span></span><br><span class="line"><span class="comment">//     createCapturedValue</span></span><br><span class="line"><span class="comment">//     createClassErrorUpdate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上查找第一个能处理错误的逻辑</span></span><br><span class="line"><span class="comment">// getDerivedStateFromError</span></span><br><span class="line"><span class="comment">// componentDidCatch</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClassErrorUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  errorInfo: CapturedValue&lt;mixed&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Update</span>&lt;<span class="title">mixed</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> update = createUpdate(expirationTime);</span><br><span class="line">  update.tag = CaptureUpdate;</span><br><span class="line">  <span class="keyword">const</span> getDerivedStateFromError = fiber.type.getDerivedStateFromError;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> getDerivedStateFromError === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> error = errorInfo.value;</span><br><span class="line">    update.payload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getDerivedStateFromError(error);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> inst = fiber.stateNode;</span><br><span class="line">  <span class="keyword">if</span> (inst !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> inst.componentDidCatch === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    update.callback = <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> getDerivedStateFromError !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// To preserve the preexisting retry behavior of error boundaries,</span></span><br><span class="line">        <span class="comment">// we keep track of which ones already failed during this batch.</span></span><br><span class="line">        <span class="comment">// This gets reset before we yield back to the browser.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Warn in strict mode if getDerivedStateFromError is</span></span><br><span class="line">        <span class="comment">// not defined.</span></span><br><span class="line">        markLegacyErrorBoundaryAsFailed(<span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> error = errorInfo.value;</span><br><span class="line">      <span class="keyword">const</span> stack = errorInfo.stack;</span><br><span class="line">      logError(fiber, errorInfo);</span><br><span class="line">      <span class="built_in">this</span>.componentDidCatch(error, &#123;</span><br><span class="line">        componentStack: stack !== <span class="literal">null</span> ? stack : <span class="string">&quot;&quot;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unwindWork-以及-React-中的错误处理"><a href="#unwindWork-以及-React-中的错误处理" class="headerlink" title="unwindWork 以及 React 中的错误处理"></a>unwindWork 以及 React 中的错误处理</h3><ul>
<li><p>类似于 completeWork 对不同类型组件处理</p>
</li>
<li><p>对于 ShouldCapture 组件设置 DidCapture 副作用</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberUnwindWork.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unwindWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">if</span> (isLegacyContextProvider(Component)) &#123;</span><br><span class="line">        popLegacyContext(workInProgress);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> effectTag = workInProgress.effectTag;</span><br><span class="line">      <span class="keyword">if</span> (effectTag &amp; ShouldCapture) &#123;</span><br><span class="line">        <span class="comment">// effectTag包含ShouldCapture的话，就把ShouldCapture去掉，加上DidCapture</span></span><br><span class="line">        workInProgress.effectTag = (effectTag &amp; ~ShouldCapture) | DidCapture;</span><br><span class="line">        <span class="keyword">return</span> workInProgress;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostRoot: &#123;</span><br><span class="line">      popHostContainer(workInProgress);</span><br><span class="line">      popTopLevelLegacyContextObject(workInProgress);</span><br><span class="line">      <span class="keyword">const</span> effectTag = workInProgress.effectTag;</span><br><span class="line">      invariant(</span><br><span class="line">        (effectTag &amp; DidCapture) === NoEffect,</span><br><span class="line">        <span class="string">&quot;The root failed to unmount after an error. This is likely a bug in &quot;</span> +</span><br><span class="line">          <span class="string">&quot;React. Please file an issue.&quot;</span></span><br><span class="line">      );</span><br><span class="line">      workInProgress.effectTag = (effectTag &amp; ~ShouldCapture) | DidCapture;</span><br><span class="line">      <span class="keyword">return</span> workInProgress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">      popHostContext(workInProgress);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SuspenseComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> effectTag = workInProgress.effectTag;</span><br><span class="line">      <span class="keyword">if</span> (effectTag &amp; ShouldCapture) &#123;</span><br><span class="line">        workInProgress.effectTag = (effectTag &amp; ~ShouldCapture) | DidCapture;</span><br><span class="line">        <span class="comment">// Captured a suspense effect. Re-render the boundary.</span></span><br><span class="line">        <span class="keyword">return</span> workInProgress;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostPortal:</span><br><span class="line">      popHostContainer(workInProgress);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">case</span> ContextProvider:</span><br><span class="line">      popProvider(workInProgress);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提交阶段-commitRoot"><a href="#提交阶段-commitRoot" class="headerlink" title="提交阶段 commitRoot"></a>提交阶段 commitRoot</h2><ul>
<li><p>预备工作</p>
</li>
<li><p>三个循环</p>
</li>
<li><p>其他工作</p>
</li>
</ul>
<h3 id="入口-completeRoot"><a href="#入口-completeRoot" class="headerlink" title="入口 completeRoot"></a>入口 completeRoot</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberScheduler.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Check if there&#x27;s a batch that matches this expiration time.</span></span><br><span class="line">  <span class="keyword">const</span> firstBatch = root.firstBatch;</span><br><span class="line">  <span class="keyword">if</span> (firstBatch !== <span class="literal">null</span> &amp;&amp; firstBatch._expirationTime &gt;= expirationTime) &#123;</span><br><span class="line">    <span class="keyword">if</span> (completedBatches === <span class="literal">null</span>) &#123;</span><br><span class="line">      completedBatches = [firstBatch];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      completedBatches.push(firstBatch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (firstBatch._defer) &#123;</span><br><span class="line">      <span class="comment">// This root is blocked from committing by a batch. Unschedule it until</span></span><br><span class="line">      <span class="comment">// we receive another update.</span></span><br><span class="line">      root.finishedWork = finishedWork;</span><br><span class="line">      root.expirationTime = NoWork;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Commit the root.</span></span><br><span class="line">  root.finishedWork = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if this is a nested update (a sync update scheduled during the</span></span><br><span class="line">  <span class="comment">// commit phase).</span></span><br><span class="line">  <span class="keyword">if</span> (root === lastCommittedRootDuringThisBatch) &#123;</span><br><span class="line">    <span class="comment">// If the next root is the same as the previous root, this is a nested</span></span><br><span class="line">    <span class="comment">// update. To prevent an infinite loop, increment the nested update count.</span></span><br><span class="line">    nestedUpdateCount++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Reset whenever we switch roots.</span></span><br><span class="line">    lastCommittedRootDuringThisBatch = root;</span><br><span class="line">    nestedUpdateCount = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  commitRoot(root, finishedWork);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// commitRoot</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params">root: FiberRoot, finishedWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  isWorking = <span class="literal">true</span>;</span><br><span class="line">  isCommitting = <span class="literal">true</span>;</span><br><span class="line">  startCommitTimer();</span><br><span class="line">  <span class="keyword">const</span> committedExpirationTime = root.pendingCommitExpirationTime;</span><br><span class="line">  root.pendingCommitExpirationTime = NoWork;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update the pending priority levels to account for the work that we are</span></span><br><span class="line">  <span class="comment">// about to commit. This needs to happen before calling the lifecycles, since</span></span><br><span class="line">  <span class="comment">// they may schedule additional updates.</span></span><br><span class="line">  <span class="keyword">const</span> updateExpirationTimeBeforeCommit = finishedWork.expirationTime;</span><br><span class="line">  <span class="keyword">const</span> childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;</span><br><span class="line">  <span class="keyword">const</span> earliestRemainingTimeBeforeCommit =</span><br><span class="line">    childExpirationTimeBeforeCommit &gt; updateExpirationTimeBeforeCommit</span><br><span class="line">      ? childExpirationTimeBeforeCommit</span><br><span class="line">      : updateExpirationTimeBeforeCommit;</span><br><span class="line">  markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> prevInteractions: <span class="built_in">Set</span>&lt;Interaction&gt; = (<span class="literal">null</span>: any);</span><br><span class="line">  <span class="comment">// Reset this to null before calling lifecycles</span></span><br><span class="line">  ReactCurrentOwner.current = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> firstEffect;</span><br><span class="line">  <span class="keyword">if</span> (finishedWork.effectTag &gt; PerformedWork) &#123;</span><br><span class="line">    <span class="comment">// A fiber&#x27;s effect list consists only of its children, not itself. So if</span></span><br><span class="line">    <span class="comment">// the root has an effect, we need to add it to the end of the list. The</span></span><br><span class="line">    <span class="comment">// resulting list is the set that would belong to the root&#x27;s parent, if</span></span><br><span class="line">    <span class="comment">// it had one; that is, all the effects in the tree including the root.</span></span><br><span class="line">    <span class="keyword">if</span> (finishedWork.lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">      finishedWork.lastEffect.nextEffect = finishedWork;</span><br><span class="line">      firstEffect = finishedWork.firstEffect;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      firstEffect = finishedWork;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There is no effect on the root.</span></span><br><span class="line">    firstEffect = finishedWork.firstEffect;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  prepareForCommit(root.containerInfo);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Invoke instances of getSnapshotBeforeUpdate before mutation.</span></span><br><span class="line">  nextEffect = firstEffect;</span><br><span class="line">  startCommitSnapshotEffectsTimer();</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> didError = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> error;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      commitBeforeMutationLifecycles();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      didError = <span class="literal">true</span>;</span><br><span class="line">      error = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (didError) &#123;</span><br><span class="line">      invariant(</span><br><span class="line">        nextEffect !== <span class="literal">null</span>,</span><br><span class="line">        <span class="string">&quot;Should have next effect. This error is likely caused by a bug &quot;</span> +</span><br><span class="line">          <span class="string">&quot;in React. Please file an issue.&quot;</span></span><br><span class="line">      );</span><br><span class="line">      captureCommitPhaseError(nextEffect, error);</span><br><span class="line">      <span class="comment">// Clean-up</span></span><br><span class="line">      <span class="keyword">if</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">        nextEffect = nextEffect.nextEffect;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  stopCommitSnapshotEffectsTimer();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Commit all the side-effects within a tree. We&#x27;ll do this in two passes.</span></span><br><span class="line">  <span class="comment">// The first pass performs all the host insertions, updates, deletions and</span></span><br><span class="line">  <span class="comment">// ref unmounts.</span></span><br><span class="line">  nextEffect = firstEffect;</span><br><span class="line">  startCommitHostEffectsTimer();</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> didError = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      commitAllHostEffects();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      didError = <span class="literal">true</span>;</span><br><span class="line">      error = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (didError) &#123;</span><br><span class="line">      invariant(</span><br><span class="line">        nextEffect !== <span class="literal">null</span>,</span><br><span class="line">        <span class="string">&quot;Should have next effect. This error is likely caused by a bug &quot;</span> +</span><br><span class="line">          <span class="string">&quot;in React. Please file an issue.&quot;</span></span><br><span class="line">      );</span><br><span class="line">      captureCommitPhaseError(nextEffect, error);</span><br><span class="line">      <span class="comment">// Clean-up</span></span><br><span class="line">      <span class="keyword">if</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">        nextEffect = nextEffect.nextEffect;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  stopCommitHostEffectsTimer();</span><br><span class="line"></span><br><span class="line">  resetAfterCommit(root.containerInfo);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The work-in-progress tree is now the current tree. This must come after</span></span><br><span class="line">  <span class="comment">// the first pass of the commit phase, so that the previous tree is still</span></span><br><span class="line">  <span class="comment">// current during componentWillUnmount, but before the second pass, so that</span></span><br><span class="line">  <span class="comment">// the finished work is current during componentDidMount/Update.</span></span><br><span class="line">  root.current = finishedWork;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In the second pass we&#x27;ll perform all life-cycles and ref callbacks.</span></span><br><span class="line">  <span class="comment">// Life-cycles happen as a separate pass so that all placements, updates,</span></span><br><span class="line">  <span class="comment">// and deletions in the entire tree have already been invoked.</span></span><br><span class="line">  <span class="comment">// This pass also triggers any renderer-specific initial effects.</span></span><br><span class="line">  nextEffect = firstEffect;</span><br><span class="line">  startCommitLifeCyclesTimer();</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> didError = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      commitAllLifeCycles(root, committedExpirationTime);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      didError = <span class="literal">true</span>;</span><br><span class="line">      error = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (didError) &#123;</span><br><span class="line">      invariant(</span><br><span class="line">        nextEffect !== <span class="literal">null</span>,</span><br><span class="line">        <span class="string">&quot;Should have next effect. This error is likely caused by a bug &quot;</span> +</span><br><span class="line">          <span class="string">&quot;in React. Please file an issue.&quot;</span></span><br><span class="line">      );</span><br><span class="line">      captureCommitPhaseError(nextEffect, error);</span><br><span class="line">      <span class="keyword">if</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">        nextEffect = nextEffect.nextEffect;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    enableHooks &amp;&amp;</span><br><span class="line">    firstEffect !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    rootWithPendingPassiveEffects !== <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// This commit included a passive effect. These do not need to fire until</span></span><br><span class="line">    <span class="comment">// after the next paint. Schedule an callback to fire them in an async</span></span><br><span class="line">    <span class="comment">// event. To ensure serial execution, the callback will be flushed early if</span></span><br><span class="line">    <span class="comment">// we enter rootWithPendingPassiveEffects commit phase before then.</span></span><br><span class="line">    <span class="keyword">let</span> callback = commitPassiveEffects.bind(<span class="literal">null</span>, root, firstEffect);</span><br><span class="line">    passiveEffectCallbackHandle = Schedule_scheduleCallback(callback);</span><br><span class="line">    passiveEffectCallback = callback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isCommitting = <span class="literal">false</span>;</span><br><span class="line">  isWorking = <span class="literal">false</span>;</span><br><span class="line">  stopCommitLifeCyclesTimer();</span><br><span class="line">  stopCommitTimer();</span><br><span class="line">  onCommitRoot(finishedWork.stateNode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> updateExpirationTimeAfterCommit = finishedWork.expirationTime;</span><br><span class="line">  <span class="keyword">const</span> childExpirationTimeAfterCommit = finishedWork.childExpirationTime;</span><br><span class="line">  <span class="keyword">const</span> earliestRemainingTimeAfterCommit =</span><br><span class="line">    childExpirationTimeAfterCommit &gt; updateExpirationTimeAfterCommit</span><br><span class="line">      ? childExpirationTimeAfterCommit</span><br><span class="line">      : updateExpirationTimeAfterCommit;</span><br><span class="line">  <span class="keyword">if</span> (earliestRemainingTimeAfterCommit === NoWork) &#123;</span><br><span class="line">    <span class="comment">// If there&#x27;s no remaining work, we can clear the set of already failed</span></span><br><span class="line">    <span class="comment">// error boundaries.</span></span><br><span class="line">    legacyErrorBoundariesThatAlreadyFailed = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  onCommit(root, earliestRemainingTimeAfterCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第一个循环-commitBeforeMutationLifecycles"><a href="#第一个循环-commitBeforeMutationLifecycles" class="headerlink" title="第一个循环 commitBeforeMutationLifecycles"></a>第一个循环 commitBeforeMutationLifecycles</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// commitBeforeMutationLifecycles</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationLifecycles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; Snapshot) &#123;</span><br><span class="line">      recordEffect();</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">      commitBeforeMutationLifeCycles(current, nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberCommitWork.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitBeforeMutationLifeCycles</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  finishedWork: Fiber</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">    <span class="keyword">case</span> ForwardRef:</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">      commitHookEffectList(UnmountSnapshot, NoHookEffect, finishedWork);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="keyword">if</span> (finishedWork.effectTag &amp; Snapshot) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> prevProps = current.memoizedProps;</span><br><span class="line">          <span class="keyword">const</span> prevState = current.memoizedState;</span><br><span class="line">          startPhaseTimer(finishedWork, <span class="string">&quot;getSnapshotBeforeUpdate&quot;</span>);</span><br><span class="line">          <span class="keyword">const</span> instance = finishedWork.stateNode;</span><br><span class="line">          <span class="comment">// We could update instance props and state here,</span></span><br><span class="line">          <span class="comment">// but instead we rely on them being set during last render.</span></span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> revisit this when we implement resuming.</span></span><br><span class="line">          <span class="comment">// 获取快照getSnapshotBeforeUpdate</span></span><br><span class="line">          <span class="keyword">const</span> snapshot = instance.getSnapshotBeforeUpdate(</span><br><span class="line">            finishedWork.elementType === finishedWork.type</span><br><span class="line">              ? prevProps</span><br><span class="line">              : resolveDefaultProps(finishedWork.type, prevProps),</span><br><span class="line">            prevState</span><br><span class="line">          );</span><br><span class="line">          instance.__reactInternalSnapshotBeforeUpdate = snapshot;</span><br><span class="line">          stopPhaseTimer();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostRoot:</span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">    <span class="keyword">case</span> HostText:</span><br><span class="line">    <span class="keyword">case</span> HostPortal:</span><br><span class="line">    <span class="keyword">case</span> IncompleteClassComponent:</span><br><span class="line">      <span class="comment">// Nothing to do for these component types</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      invariant(</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;This unit of work tag should not have side-effects. This error is &quot;</span> +</span><br><span class="line">          <span class="string">&quot;likely caused by a bug in React. Please file an issue.&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二个循环-commitAllHostEffects"><a href="#第二个循环-commitAllHostEffects" class="headerlink" title="第二个循环 commitAllHostEffects"></a>第二个循环 commitAllHostEffects</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllHostEffects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    recordEffect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文本节点Reset</span></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; ContentReset) &#123;</span><br><span class="line">      commitResetTextContent(nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ref节点Detach</span></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; Ref) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">      <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">        commitDetachRef(current);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入，更新，删除</span></span><br><span class="line">    <span class="comment">// The following switch statement is only concerned about placement,</span></span><br><span class="line">    <span class="comment">// updates, and deletions. To avoid needing to add a case for every</span></span><br><span class="line">    <span class="comment">// possible bitmap value, we remove the secondary effects from the</span></span><br><span class="line">    <span class="comment">// effect tag and switch on that value.</span></span><br><span class="line">    <span class="keyword">let</span> primaryEffectTag = effectTag &amp; (Placement | Update | Deletion);</span><br><span class="line">    <span class="keyword">switch</span> (primaryEffectTag) &#123;</span><br><span class="line">      <span class="keyword">case</span> Placement: &#123;</span><br><span class="line">        commitPlacement(nextEffect);</span><br><span class="line">        <span class="comment">// Clear the &quot;placement&quot; from effect tag so that we know that this is inserted, before</span></span><br><span class="line">        <span class="comment">// any life-cycles like componentDidMount gets called.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> findDOMNode doesn&#x27;t rely on this any more but isMounted</span></span><br><span class="line">        <span class="comment">// does and isMounted is deprecated anyway so we should be able</span></span><br><span class="line">        <span class="comment">// to kill this.</span></span><br><span class="line">        nextEffect.effectTag &amp;= ~Placement; <span class="comment">// 现在是在循环里面，所以Placement执行完了就剔除</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> PlacementAndUpdate: &#123;</span><br><span class="line">        <span class="comment">// Placement</span></span><br><span class="line">        commitPlacement(nextEffect);</span><br><span class="line">        <span class="comment">// Clear the &quot;placement&quot; from effect tag so that we know that this is inserted, before</span></span><br><span class="line">        <span class="comment">// any life-cycles like componentDidMount gets called.</span></span><br><span class="line">        nextEffect.effectTag &amp;= ~Placement;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update</span></span><br><span class="line">        <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">        commitWork(current, nextEffect);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> Update: &#123;</span><br><span class="line">        <span class="keyword">const</span> current = nextEffect.alternate;</span><br><span class="line">        commitWork(current, nextEffect);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> Deletion: &#123;</span><br><span class="line">        commitDeletion(nextEffect);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Placement-commitPlacement"><a href="#Placement-commitPlacement" class="headerlink" title="Placement commitPlacement"></a>Placement commitPlacement</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberCommitWork.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitPlacement</span>(<span class="params">finishedWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Recursively insert all host nodes into the parent.</span></span><br><span class="line">  <span class="keyword">const</span> parentFiber = getHostParentFiber(finishedWork);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note: these two variables *must* always be updated together.</span></span><br><span class="line">  <span class="keyword">let</span> parent;</span><br><span class="line">  <span class="keyword">let</span> isContainer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (parentFiber.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">      parent = parentFiber.stateNode;</span><br><span class="line">      isContainer = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HostRoot:</span><br><span class="line">      parent = parentFiber.stateNode.containerInfo;</span><br><span class="line">      isContainer = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HostPortal:</span><br><span class="line">      parent = parentFiber.stateNode.containerInfo;</span><br><span class="line">      isContainer = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      invariant(</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Invalid host parent fiber. This error is likely caused by a bug &quot;</span> +</span><br><span class="line">          <span class="string">&quot;in React. Please file an issue.&quot;</span></span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (parentFiber.effectTag &amp; ContentReset) &#123;</span><br><span class="line">    <span class="comment">// Reset the text content of the parent before doing any insertions</span></span><br><span class="line">    resetTextContent(parent);</span><br><span class="line">    <span class="comment">// Clear ContentReset from the effect tag</span></span><br><span class="line">    parentFiber.effectTag &amp;= ~ContentReset;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> before = getHostSibling(finishedWork);</span><br><span class="line">  <span class="comment">// We only have the top Fiber that was inserted but we need recurse down its</span></span><br><span class="line">  <span class="comment">// children to find all the terminal nodes.</span></span><br><span class="line">  <span class="keyword">let</span> node: Fiber = finishedWork;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.tag === HostComponent || node.tag === HostText) &#123;</span><br><span class="line">      <span class="keyword">if</span> (before) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isContainer) &#123;</span><br><span class="line">          insertInContainerBefore(parent, node.stateNode, before);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          insertBefore(parent, node.stateNode, before);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isContainer) &#123;</span><br><span class="line">          appendChildToContainer(parent, node.stateNode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          appendChild(parent, node.stateNode);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.tag === HostPortal) &#123;</span><br><span class="line">      <span class="comment">// If the insertion itself is a portal, then we don&#x27;t want to traverse</span></span><br><span class="line">      <span class="comment">// down its children. Instead, we&#x27;ll get insertions from each child in</span></span><br><span class="line">      <span class="comment">// the portal directly.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.child !== <span class="literal">null</span>) &#123;</span><br><span class="line">      node.child.return = node;</span><br><span class="line">      node = node.child;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node === finishedWork) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node.sibling === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.return === <span class="literal">null</span> || node.return === finishedWork) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      node = node.return;</span><br><span class="line">    &#125;</span><br><span class="line">    node.sibling.return = node.return;</span><br><span class="line">    node = node.sibling;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Update-commitWork"><a href="#Update-commitWork" class="headerlink" title="Update commitWork"></a>Update commitWork</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">current: Fiber | <span class="literal">null</span>, finishedWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!supportsMutation) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">      <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">      <span class="keyword">case</span> ForwardRef:</span><br><span class="line">      <span class="keyword">case</span> MemoComponent:</span><br><span class="line">      <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">        <span class="comment">// Note: We currently never use MountMutation, but useLayout uses</span></span><br><span class="line">        <span class="comment">// UnmountMutation.</span></span><br><span class="line">        commitHookEffectList(UnmountMutation, MountMutation, finishedWork);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    commitContainer(finishedWork);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">    <span class="keyword">case</span> ForwardRef:</span><br><span class="line">    <span class="keyword">case</span> MemoComponent:</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent: &#123;</span><br><span class="line">      <span class="comment">// Note: We currently never use MountMutation, but useLayout uses</span></span><br><span class="line">      <span class="comment">// UnmountMutation.</span></span><br><span class="line">      commitHookEffectList(UnmountMutation, MountMutation, finishedWork);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> instance: Instance = finishedWork.stateNode;</span><br><span class="line">      <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Commit the work prepared earlier.</span></span><br><span class="line">        <span class="keyword">const</span> newProps = finishedWork.memoizedProps;</span><br><span class="line">        <span class="comment">// For hydration we reuse the update path but we treat the oldProps</span></span><br><span class="line">        <span class="comment">// as the newProps. The updatePayload will contain the real change in</span></span><br><span class="line">        <span class="comment">// this case.</span></span><br><span class="line">        <span class="keyword">const</span> oldProps = current !== <span class="literal">null</span> ? current.memoizedProps : newProps;</span><br><span class="line">        <span class="keyword">const</span> type = finishedWork.type;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Type the updateQueue to be specific to host components.</span></span><br><span class="line">        <span class="comment">// 这个就是需要更新的对象数组updatePayload</span></span><br><span class="line">        <span class="keyword">const</span> updatePayload: <span class="literal">null</span> | UpdatePayload =</span><br><span class="line">          (finishedWork.updateQueue: any);</span><br><span class="line">        finishedWork.updateQueue = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (updatePayload !== <span class="literal">null</span>) &#123;</span><br><span class="line">          commitUpdate(</span><br><span class="line">            instance,</span><br><span class="line">            updatePayload,</span><br><span class="line">            type,</span><br><span class="line">            oldProps,</span><br><span class="line">            newProps,</span><br><span class="line">            finishedWork</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostText: &#123;</span><br><span class="line">      invariant(</span><br><span class="line">        finishedWork.stateNode !== <span class="literal">null</span>,</span><br><span class="line">        <span class="string">&quot;This should have a text node initialized. This error is likely &quot;</span> +</span><br><span class="line">          <span class="string">&quot;caused by a bug in React. Please file an issue.&quot;</span></span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">const</span> textInstance: TextInstance = finishedWork.stateNode;</span><br><span class="line">      <span class="keyword">const</span> newText: string = finishedWork.memoizedProps;</span><br><span class="line">      <span class="comment">// For hydration we reuse the update path but we treat the oldProps</span></span><br><span class="line">      <span class="comment">// as the newProps. The updatePayload will contain the real change in</span></span><br><span class="line">      <span class="comment">// this case.</span></span><br><span class="line">      <span class="keyword">const</span> oldText: string =</span><br><span class="line">        current !== <span class="literal">null</span> ? current.memoizedProps : newText;</span><br><span class="line">      commitTextUpdate(textInstance, oldText, newText);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostRoot: &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Profiler: &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SuspenseComponent: &#123;</span><br><span class="line">      <span class="keyword">let</span> newState: SuspenseState | <span class="literal">null</span> = finishedWork.memoizedState;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> newDidTimeout;</span><br><span class="line">      <span class="keyword">let</span> primaryChildParent = finishedWork;</span><br><span class="line">      <span class="keyword">if</span> (newState === <span class="literal">null</span>) &#123;</span><br><span class="line">        newDidTimeout = <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newDidTimeout = <span class="literal">true</span>;</span><br><span class="line">        primaryChildParent = finishedWork.child;</span><br><span class="line">        <span class="keyword">if</span> (newState.timedOutAt === NoWork) &#123;</span><br><span class="line">          <span class="comment">// If the children had not already timed out, record the time.</span></span><br><span class="line">          <span class="comment">// This is used to compute the elapsed time during subsequent</span></span><br><span class="line">          <span class="comment">// attempts to render the children.</span></span><br><span class="line">          newState.timedOutAt = requestCurrentTime();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (primaryChildParent !== <span class="literal">null</span>) &#123;</span><br><span class="line">        hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If this boundary just timed out, then it will have a set of thenables.</span></span><br><span class="line">      <span class="comment">// For each thenable, attach a listener so that when it resolves, React</span></span><br><span class="line">      <span class="comment">// attempts to re-render the boundary in the primary (pre-timeout) state.</span></span><br><span class="line">      <span class="keyword">const</span> thenables: <span class="built_in">Set</span>&lt;Thenable&gt; | <span class="literal">null</span> = (finishedWork.updateQueue: any);</span><br><span class="line">      <span class="keyword">if</span> (thenables !== <span class="literal">null</span>) &#123;</span><br><span class="line">        finishedWork.updateQueue = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> retryCache = finishedWork.stateNode;</span><br><span class="line">        <span class="keyword">if</span> (retryCache === <span class="literal">null</span>) &#123;</span><br><span class="line">          retryCache = finishedWork.stateNode = <span class="keyword">new</span> PossiblyWeakSet();</span><br><span class="line">        &#125;</span><br><span class="line">        thenables.forEach(<span class="function">(<span class="params">thenable</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// Memoize using the boundary fiber to prevent redundant listeners.</span></span><br><span class="line">          <span class="keyword">let</span> retry = retryTimedOutBoundary.bind(<span class="literal">null</span>, finishedWork, thenable);</span><br><span class="line">          <span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">            retry = Schedule_tracing_wrap(retry);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (!retryCache.has(thenable)) &#123;</span><br><span class="line">            retryCache.add(thenable);</span><br><span class="line">            thenable.then(retry, retry);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> IncompleteClassComponent: &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      invariant(</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;This unit of work tag should not have side-effects. This error is &quot;</span> +</span><br><span class="line">          <span class="string">&quot;likely caused by a bug in React. Please file an issue.&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react-dom\src\client\ReactDOMHostConfig.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">commitUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  domElement: Instance,</span></span></span><br><span class="line"><span class="function"><span class="params">  updatePayload: <span class="built_in">Array</span>&lt;mixed&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  type: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldProps: Props,</span></span></span><br><span class="line"><span class="function"><span class="params">  newProps: Props,</span></span></span><br><span class="line"><span class="function"><span class="params">  internalInstanceHandle: <span class="built_in">Object</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update the props handle so that we know which props are the ones with</span></span><br><span class="line">  <span class="comment">// with current event handlers.</span></span><br><span class="line">  updateFiberProps(domElement, newProps);</span><br><span class="line">  <span class="comment">// Apply the diff to the DOM node.</span></span><br><span class="line">  updateProperties(domElement, updatePayload, type, oldProps, newProps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三个循环-commitAllLifeCycles"><a href="#第三个循环-commitAllLifeCycles" class="headerlink" title="第三个循环 commitAllLifeCycles"></a>第三个循环 commitAllLifeCycles</h3><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><h3 id="event-事件系统初始化-注入平台事件插件"><a href="#event-事件系统初始化-注入平台事件插件" class="headerlink" title="event 事件系统初始化 注入平台事件插件"></a>event 事件系统初始化 注入平台事件插件</h3><ul>
<li><p>确定插件注入顺序</p>
</li>
<li><p>注入插件模块序</p>
</li>
<li><p>计算 registrationModuleNames 等属性</p>
</li>
</ul>
<h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><h3 id="Hooks-的定义以及执行前后的准备和重置"><a href="#Hooks-的定义以及执行前后的准备和重置" class="headerlink" title="Hooks 的定义以及执行前后的准备和重置"></a>Hooks 的定义以及执行前后的准备和重置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages\react\src\React.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;enableHooks&#125; <span class="keyword">from</span> <span class="string">&#x27;shared/ReactFeatureFlags&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  useCallback,</span><br><span class="line">  useContext,</span><br><span class="line">  useEffect,</span><br><span class="line">  useImperativeMethods,</span><br><span class="line">  useLayoutEffect,</span><br><span class="line">  useMemo,</span><br><span class="line">  useReducer,</span><br><span class="line">  useRef,</span><br><span class="line">  useState,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;./ReactHooks&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> React = &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (enableHooks) &#123;</span><br><span class="line">  React.useCallback = useCallback;</span><br><span class="line">  React.useContext = useContext;</span><br><span class="line">  React.useEffect = useEffect;</span><br><span class="line">  React.useImperativeMethods = useImperativeMethods;</span><br><span class="line">  React.useLayoutEffect = useLayoutEffect;</span><br><span class="line">  React.useMemo = useMemo;</span><br><span class="line">  React.useReducer = useReducer;</span><br><span class="line">  React.useRef = useRef;</span><br><span class="line">  React.useState = useState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react\src\ReactHooks.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useState</span>&lt;<span class="title">S</span>&gt;(<span class="params">initialState: (() =&gt; S) | S</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ReactCurrentOwner <span class="keyword">from</span> <span class="string">&#x27;./ReactCurrentOwner&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveDispatcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = ReactCurrentOwner.currentDispatcher;</span><br><span class="line">  <span class="keyword">return</span> dispatcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react\src\ReactCurrentOwner.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Keeps track of the current owner.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The current owner is the component who should own any components that are</span></span><br><span class="line"><span class="comment"> * currently being constructed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> ReactCurrentOwner = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@type <span class="type">&#123;ReactComponent&#125;</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  current: (<span class="literal">null</span>: <span class="literal">null</span> | Fiber),</span><br><span class="line">  currentDispatcher: (<span class="literal">null</span>: <span class="literal">null</span> | Dispatcher),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReactCurrentOwner;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberScheduler.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRoot</span>(<span class="params">root: FiberRoot, isYieldy: boolean</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  flushPassiveEffects();</span><br><span class="line"></span><br><span class="line">  isWorking = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (enableHooks) &#123;</span><br><span class="line">    ReactCurrentOwner.currentDispatcher = Dispatcher;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ReactCurrentOwner.currentDispatcher = DispatcherWithoutHooks;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberDispatcher.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;readContext&#125; <span class="keyword">from</span> <span class="string">&#x27;./ReactFiberNewContext&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  useCallback,</span><br><span class="line">  useContext,</span><br><span class="line">  useEffect,</span><br><span class="line">  useImperativeMethods,</span><br><span class="line">  useLayoutEffect,</span><br><span class="line">  useMemo,</span><br><span class="line">  useReducer,</span><br><span class="line">  useRef,</span><br><span class="line">  useState,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;./ReactFiberHooks&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Dispatcher = &#123;</span><br><span class="line">  readContext,</span><br><span class="line">  useCallback,</span><br><span class="line">  useContext,</span><br><span class="line">  useEffect,</span><br><span class="line">  useImperativeMethods,</span><br><span class="line">  useLayoutEffect,</span><br><span class="line">  useMemo,</span><br><span class="line">  useReducer,</span><br><span class="line">  useRef,</span><br><span class="line">  useState,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DispatcherWithoutHooks = &#123;</span><br><span class="line">  readContext,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// packages\react-reconciler\src\ReactFiberHooks.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useState</span>&lt;<span class="title">S</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  initialState: (() =&gt; S) | S,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): [<span class="title">S</span>, <span class="title">Dispatch</span>&lt;<span class="title">BasicStateAction</span>&lt;<span class="title">S</span>&gt;&gt;] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useReducer(</span><br><span class="line">    basicStateReducer,</span><br><span class="line">    <span class="comment">// useReducer has a special case to support lazy useState initializers</span></span><br><span class="line">    (initialState: any),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicStateReducer</span>&lt;<span class="title">S</span>&gt;(<span class="params">state: S, action: BasicStateAction&lt;S&gt;</span>): <span class="title">S</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span> ? action(state) : action;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useReducer</span>&lt;<span class="title">S</span>, <span class="title">A</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  reducer: (S, A) =&gt; S,</span></span></span><br><span class="line"><span class="function"><span class="params">  initialState: S,</span></span></span><br><span class="line"><span class="function"><span class="params">  initialAction: A | <span class="keyword">void</span> | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): [<span class="title">S</span>, <span class="title">Dispatch</span>&lt;<span class="title">A</span>&gt;] </span>&#123;</span><br><span class="line">  currentlyRenderingFiber = resolveCurrentlyRenderingFiber();</span><br><span class="line">  workInProgressHook = createWorkInProgressHook();</span><br><span class="line">  <span class="keyword">let</span> queue: UpdateQueue&lt;A&gt; | <span class="literal">null</span> = (workInProgressHook.queue: any);</span><br><span class="line">  <span class="keyword">if</span> (queue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Already have a queue, so this is an update.</span></span><br><span class="line">    <span class="keyword">if</span> (isReRender) &#123;</span><br><span class="line">      <span class="comment">// This is a re-render. Apply the new render phase updates to the previous</span></span><br><span class="line">      <span class="comment">// work-in-progress hook.</span></span><br><span class="line">      <span class="keyword">const</span> dispatch: Dispatch&lt;A&gt; = (queue.dispatch: any);</span><br><span class="line">      <span class="keyword">if</span> (renderPhaseUpdates !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Render phase updates are stored in a map of queue -&gt; linked list</span></span><br><span class="line">        <span class="keyword">const</span> firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);</span><br><span class="line">        <span class="keyword">if</span> (firstRenderPhaseUpdate !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">          renderPhaseUpdates.delete(queue);</span><br><span class="line">          <span class="keyword">let</span> newState = workInProgressHook.memoizedState;</span><br><span class="line">          <span class="keyword">let</span> update = firstRenderPhaseUpdate;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// Process this render phase update. We don&#x27;t have to check the</span></span><br><span class="line">            <span class="comment">// priority because it will always be the same as the current</span></span><br><span class="line">            <span class="comment">// render&#x27;s.</span></span><br><span class="line">            <span class="keyword">const</span> action = update.action;</span><br><span class="line">            newState = reducer(newState, action);</span><br><span class="line">            update = update.next;</span><br><span class="line">          &#125; <span class="keyword">while</span> (update !== <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">          workInProgressHook.memoizedState = newState;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Don&#x27;t persist the state accumlated from the render phase updates to</span></span><br><span class="line">          <span class="comment">// the base state unless the queue is empty.</span></span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> Not sure if this is the desired semantics, but it&#x27;s what we</span></span><br><span class="line">          <span class="comment">// do for gDSFP. I can&#x27;t remember why.</span></span><br><span class="line">          <span class="keyword">if</span> (workInProgressHook.baseUpdate === queue.last) &#123;</span><br><span class="line">            workInProgressHook.baseState = newState;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> [newState, dispatch];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> [workInProgressHook.memoizedState, dispatch];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The last update in the entire queue</span></span><br><span class="line">    <span class="keyword">const</span> last = queue.last;</span><br><span class="line">    <span class="comment">// The last update that is part of the base state.</span></span><br><span class="line">    <span class="keyword">const</span> baseUpdate = workInProgressHook.baseUpdate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the first unprocessed update.</span></span><br><span class="line">    <span class="keyword">let</span> first;</span><br><span class="line">    <span class="keyword">if</span> (baseUpdate !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (last !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// For the first update, the queue is a circular linked list where</span></span><br><span class="line">        <span class="comment">// `queue.last.next = queue.first`. Once the first update commits, and</span></span><br><span class="line">        <span class="comment">// the `baseUpdate` is no longer empty, we can unravel the list.</span></span><br><span class="line">        last.next = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      first = baseUpdate.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      first = last !== <span class="literal">null</span> ? last.next : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (first !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> newState = workInProgressHook.baseState;</span><br><span class="line">      <span class="keyword">let</span> newBaseState = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">let</span> newBaseUpdate = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">let</span> prevUpdate = baseUpdate;</span><br><span class="line">      <span class="keyword">let</span> update = first;</span><br><span class="line">      <span class="keyword">let</span> didSkip = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> updateExpirationTime = update.expirationTime;</span><br><span class="line">        <span class="keyword">if</span> (updateExpirationTime &lt; renderExpirationTime) &#123;</span><br><span class="line">          <span class="comment">// Priority is insufficient. Skip this update. If this is the first</span></span><br><span class="line">          <span class="comment">// skipped update, the previous update/state is the new base</span></span><br><span class="line">          <span class="comment">// update/state.</span></span><br><span class="line">          <span class="keyword">if</span> (!didSkip) &#123;</span><br><span class="line">            didSkip = <span class="literal">true</span>;</span><br><span class="line">            newBaseUpdate = prevUpdate;</span><br><span class="line">            newBaseState = newState;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Update the remaining priority in the queue.</span></span><br><span class="line">          <span class="keyword">if</span> (updateExpirationTime &gt; remainingExpirationTime) &#123;</span><br><span class="line">            remainingExpirationTime = updateExpirationTime;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// Process this update.</span></span><br><span class="line">          <span class="keyword">const</span> action = update.action;</span><br><span class="line">          newState = reducer(newState, action);</span><br><span class="line">        &#125;</span><br><span class="line">        prevUpdate = update;</span><br><span class="line">        update = update.next;</span><br><span class="line">      &#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!didSkip) &#123;</span><br><span class="line">        newBaseUpdate = prevUpdate;</span><br><span class="line">        newBaseState = newState;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      workInProgressHook.memoizedState = newState;</span><br><span class="line">      workInProgressHook.baseUpdate = newBaseUpdate;</span><br><span class="line">      workInProgressHook.baseState = newBaseState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dispatch: Dispatch&lt;A&gt; = (queue.dispatch: any);</span><br><span class="line">    <span class="keyword">return</span> [workInProgressHook.memoizedState, dispatch];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// There&#x27;s no existing queue, so this is the initial render.</span></span><br><span class="line">  <span class="keyword">if</span> (reducer === basicStateReducer) &#123;</span><br><span class="line">    <span class="comment">// Special case for `useState`.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      initialState = initialState();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialAction !== <span class="literal">undefined</span> &amp;&amp; initialAction !== <span class="literal">null</span>) &#123;</span><br><span class="line">    initialState = reducer(initialState, initialAction);</span><br><span class="line">  &#125;</span><br><span class="line">  workInProgressHook.memoizedState = workInProgressHook.baseState = initialState;</span><br><span class="line">  queue = workInProgressHook.queue = &#123;</span><br><span class="line">    last: <span class="literal">null</span>,</span><br><span class="line">    dispatch: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> dispatch: Dispatch&lt;A&gt; = (queue.dispatch = (dispatchAction.bind(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    currentlyRenderingFiber,</span><br><span class="line">    queue,</span><br><span class="line">  ): any));</span><br><span class="line">  <span class="keyword">return</span> [workInProgressHook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>useState 的底层结构还是 Fiber，在函数组件里面函数组件本身是一个 Fiber，而 hooks 则是更细粒度的 Fiber</p>
</blockquote>
]]></content>
      <categories>
        <category>UI框架</category>
        <category>草稿</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>源码</tag>
      </tags>
  </entry>
</search>
